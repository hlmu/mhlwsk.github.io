<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[2018 HIT CSAPP大作业] 程序人生 Hello’s P2P</title>
    <url>/archives/44834.html</url>
    <content><![CDATA[<h1 id="摘-要"><a href="#摘-要" class="headerlink" title="摘  要"></a>摘  要</h1><p>计算机系统是由硬件和软件组成的，它们共同工作来运行应用程序。即使是最简单的一个应用程序，也需要计算机系统中的每个主要组成部分协调工作。本文以hello程序的运行为切入点，解释了当在系统上运行hello程序时，系统发生的编译、链接、加载、进程管理、存储管理等过程，以及它们的运行机制。<br><strong>关键词</strong>：操作系统；计算机组成原理；汇编<br><a id="more"></a></p>
<h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h2><p><strong>Hello的P2P（Program to process）和020（From Zero to Zero）过程</strong><br>用户在文本编辑器中编写代码得到hello.c。hello.c经过预处理（cpp）变成hello.i（修改了的源程序），经过编译（ccl）生成hello.s（汇编程序），经过汇编生成hello.o（可重定位目标程序），经过链接（ld）生成hello（可执行目标程序）。<br>用户键入命令，bash自行fork一个process，并在这个process中调用execve执行hello。execve加载hello，并调用_start函数，不久控制权被转移到hello的main函数。<br>hello调用write等系统函数在屏幕打印信息，随后退出，接下来终止的hello进程被父进程bash回收。<br>实验中所用的hello.c代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大作业的 hello.c 程序</span></span><br><span class="line"><span class="comment">// gcc -m64 -no-pie -fno-PIC hello.c -o hello</span></span><br><span class="line"><span class="comment">// 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等。</span></span><br><span class="line"><span class="comment">// 可以 运行 ps  jobs  pstree fg 等命令</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sleepsecs=<span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage: Hello 学号 姓名！\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Hello %s %s\n"</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">		sleep(sleepsecs);</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h2><p>硬件环境：Intel(R) Core(TM) i5-3320M CPU；8.00GB RAM<br>软件环境：Windows 10 64位；Vmware Workstation 14 Pro；Ubuntu 16.04 LTS 64位<br>开发工具：CodeBlocks 64位；Visual Studio Code；GCC 5.4.0；objdump；EDB；readelf；hexedit</p>
<h2 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h2><p>为编写本论文，生成的中间结果文件的名字以及文件的作用。</p>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>文件作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>hello.i</td>
<td>hello预处理之后的文本文件</td>
</tr>
<tr>
<td>hello.s</td>
<td>hello编译之后的汇编文件</td>
</tr>
<tr>
<td>hello.o</td>
<td>hello汇编之后的可重定位目标文件</td>
</tr>
<tr>
<td>hello</td>
<td>hello链接之后的可执行目标文件</td>
</tr>
<tr>
<td>hello_o.objdump</td>
<td>hello.o的反汇编代码</td>
</tr>
<tr>
<td>hello_o.elf</td>
<td>hello.o的ELF文件信息</td>
</tr>
<tr>
<td>hello.objdump</td>
<td>hello的反汇编代码</td>
</tr>
<tr>
<td>hello.elf</td>
<td>hello的ELF文件信息</td>
</tr>
<tr>
<td>test.c</td>
<td>测试用代码</td>
</tr>
</tbody>
</table>
<h2 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h2><p>本章简要介绍了hello的P2P，O2O过程，并列出了本次实验的环境和中间结果。</p>
<h1 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h1><h2 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h2><p>预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的#include &lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件拓展名。<br>这个过程为接下来的编译过程“简化”了代码。</p>
<h2 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h2><p><strong>预处理命令：cpp hello.c &gt; hello.i</strong><br><img src="/images/2018-HIT-CSAPP-hello/t1.png" alt="pic1"></p>
<h2 id="2-3-Hello的预处理结果解析"><a href="#2-3-Hello的预处理结果解析" class="headerlink" title="2.3 Hello的预处理结果解析"></a>2.3 Hello的预处理结果解析</h2><p><img src="/images/2018-HIT-CSAPP-hello/t2.png" alt="pic2"><br>经过预处理的hello代码被展开，在main之前插入了大量代码。这些代码是根据#include从stdio.h、unistd.h、stdlib.h中提取的，其中包含了printf的声明等。<br><img src="/images/2018-HIT-CSAPP-hello/t3.png" alt="pic3"></p>
<h2 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h2><p>hello.c在编译之前需要经过预处理步骤，该步骤会根据hello.c中以#开头的命令展开相应代码并修改原始的C程序，以便下一步编译。</p>
<h1 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h1><h2 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h2><p>编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。</p>
<h2 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h2><p><strong>编译命令：gcc -S hello.i -o hello.s</strong><br><img src="/images/2018-HIT-CSAPP-hello/t4.png" alt="pic4"></p>
<h2 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h2><h3 id="3-3-1-hello-s中出现的标识"><a href="#3-3-1-hello-s中出现的标识" class="headerlink" title="3.3.1 hello.s中出现的标识"></a>3.3.1 hello.s中出现的标识</h3><ul>
<li>.file 源文件</li>
<li>.data 数据段</li>
<li>.globl 全局标识符</li>
<li>.string 字符串类型</li>
<li>.long long类型</li>
<li>.text 代码段</li>
</ul>
<h3 id="3-3-2-数据类型"><a href="#3-3-2-数据类型" class="headerlink" title="3.3.2 数据类型"></a>3.3.2 数据类型</h3><p>hello.c中出现的数据类型有整数类型（int）、字符串、字符指针数组。</p>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>hello.c中的整数类型有全局变量int sleepsecs，main的参数int argc，局部变量int i。<br>全局变量int sleepecs的定义如下，可以看到第六行为其分配大小4字节，第八行为其赋初值2。<br><img src="/images/2018-HIT-CSAPP-hello/t5.png" alt="pic5"><br>对sleepecs的调用采用了PC相对寻址：<br><img src="/images/2018-HIT-CSAPP-hello/t6.png" alt="pic6"><br>参数int argc，局部变量i出现在main的栈帧中，它们没有标识符，也不需要被声明，而是直接使用。<br><img src="/images/2018-HIT-CSAPP-hello/t7.png" alt="pic7"><br><img src="/images/2018-HIT-CSAPP-hello/t8.png" alt="pic8"></p>
<h4 id="字符串和字符指针数组"><a href="#字符串和字符指针数组" class="headerlink" title="字符串和字符指针数组"></a>字符串和字符指针数组</h4><p>两个printf语句中的格式字符串出现在.rodata段。<br><img src="/images/2018-HIT-CSAPP-hello/t9.png" alt="pic9"><br>作为main参数的<code>char *argv[]</code>则出现在栈帧中。<br><img src="/images/2018-HIT-CSAPP-hello/t10.png" alt="pic10"></p>
<h3 id="3-3-3运算与操作"><a href="#3-3-3运算与操作" class="headerlink" title="3.3.3运算与操作"></a>3.3.3运算与操作</h3><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><p>源程序21行对i赋值为零的操作使用mov语句实现的。<br><img src="/images/2018-HIT-CSAPP-hello/t11.png" alt="pic11"></p>
<h4 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h4><p>hello.c中的两个比较操作被解析为cmpl操作。<br><strong>argc!=3</strong><br><img src="/images/2018-HIT-CSAPP-hello/t12.png" alt="pic12"><br><strong>i&lt;10</strong><br><img src="/images/2018-HIT-CSAPP-hello/t13.png" alt="pic13"></p>
<h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>for循环中的i++采用addl来实现。<br><img src="/images/2018-HIT-CSAPP-hello/t14.png" alt="pic14"></p>
<h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><p>argv[1]：首先从-32(%rbp)读取argv地址存入rax，接下来rax增加8个字节，此时rax中存放的是&amp;(argv[1])，读取此地址指向的argv[1]放入rax，最后存入rsi。<br><img src="/images/2018-HIT-CSAPP-hello/t15.png" alt="pic15"><br>argv[2]：首先从-32(%rbp)读取argv地址存入rax，接下来rax增加16个字节，此时rax中存放的是&amp;(argv[2])，读取此地址指向的argv[2]放入rdx。<br><img src="/images/2018-HIT-CSAPP-hello/t16.png" alt="pic16"></p>
<h3 id="3-3-4控制转移"><a href="#3-3-4控制转移" class="headerlink" title="3.3.4控制转移"></a>3.3.4控制转移</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p><strong>if(argc!=3) {}</strong><br>比较argc与3的大小，然后通过条件跳转je，实现若argc==3，则跳过if语句的代码块。<br><img src="/images/2018-HIT-CSAPP-hello/t17.png" alt="pic17"><br><img src="/images/2018-HIT-CSAPP-hello/t18.png" alt="pic18"></p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>.L2初始化<br><img src="/images/2018-HIT-CSAPP-hello/t19.png" alt="pic19"><br>.L3判断循环条件</p>
<p><img src="/images/2018-HIT-CSAPP-hello/t20.png" alt="pic20"><br>.L4循环块（51行为迭代i）<br><img src="/images/2018-HIT-CSAPP-hello/t21.png" alt="pic21"><br>首先给i赋值为0，然后跳转到.L3以比较i是否小于等于9，如果小于等于9，则跳转到循环块.L4，否则继续执行循环外的语句getchar。而循环块执行到末尾会继续执行循环判断条件.L3，重复以上步骤直至循环结束。</p>
<h3 id="3-3-5-函数调用"><a href="#3-3-5-函数调用" class="headerlink" title="3.3.5 函数调用"></a>3.3.5 函数调用</h3><p>对printf的调用，参数被存放在寄存器传递。以printf(“Hello %s %s\n”,argv[1],argv[2]);为例，格式化字符串被存放在edi传递，argv[1]被放在rsi，argv[2]被放在rdx。使用call来调用printf，而printf的返回值则会被存入eax返回。<br><img src="/images/2018-HIT-CSAPP-hello/t22.png" alt="pic22"><br>对exit函数的调用，参数被存放在edi传递，然后使用call调用exit。<br><img src="/images/2018-HIT-CSAPP-hello/t23.png" alt="pic23"><br>对sleep的调用，参数被存放在edi传递，然后使用call调用sleep。<br><img src="/images/2018-HIT-CSAPP-hello/t24.png" alt="pic24"><br>对getchar的调用直接使用了call。<br>main函数的返回值放在eax传递。<br><img src="/images/2018-HIT-CSAPP-hello/t25.png" alt="pic25"></p>
<h2 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h2><p>本章主要阐述了汇编操作是怎样处理源程序中的数据、各种操作、控制转移、函数调用的。<br>编译器将C语言代码转换成汇编代码，并最终转换生成机器码。这个转换过程中需要对原始代码中的数据和操作进行映射得到相应汇编代码下的解决方案，而由于全局变量引用等因素的影响，这个过程不是简单的一一映射关系。</p>
<h1 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h1><h2 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h2><p>汇编器（as）将hello.s翻译成机器指令，把这些指令打包成可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。</p>
<h2 id="4-2-在Ubuntu下汇编的命令"><a href="#4-2-在Ubuntu下汇编的命令" class="headerlink" title="4.2 在Ubuntu下汇编的命令"></a>4.2 在Ubuntu下汇编的命令</h2><p><strong>汇编命令as hello.s -o hello.o</strong></p>
<p><img src="/images/2018-HIT-CSAPP-hello/t26.png" alt="pic26"></p>
<h2 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h2><p>分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ELF头</td>
<td>描述了生成该文件的系统的大小和字节顺序以及帮助链接器语法分析和解释目标文件的信息</td>
</tr>
<tr>
<td>.text</td>
<td>已编译的程序的机器代码</td>
</tr>
<tr>
<td>.rodata</td>
<td>只读数据</td>
</tr>
<tr>
<td>.data</td>
<td>已初始化的全局和静态C变量</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化的全局和静态C变量</td>
</tr>
<tr>
<td>.symtab</td>
<td>一个符号表，存放在程序中定义和引用的函数和全局变量的信息</td>
</tr>
<tr>
<td>.rel.text</td>
<td>.text节的重定位记录表</td>
</tr>
<tr>
<td>.rel.data</td>
<td>被模块引用或定义的所有全局变量的重定位信息</td>
</tr>
<tr>
<td>.debug</td>
<td>一个调试符号表</td>
</tr>
<tr>
<td>.line</td>
<td>原始C源程序的行号和.text节中机器指令之间的映射</td>
</tr>
<tr>
<td>.strtab</td>
<td>一个字符串表</td>
</tr>
<tr>
<td>节头部表</td>
<td>每个节的偏移量大小</td>
</tr>
</tbody>
</table>
<p>ELF头（ELF header）以一个16字节的序列开始，这个序列描述了生成该文件的系统的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表（section header table）的文件偏移，以及节头部表中条目的大小和数量。<br><img src="/images/2018-HIT-CSAPP-hello/t27.png" alt="pic27"><br>不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。<br><img src="/images/2018-HIT-CSAPP-hello/t28.png" alt="pic28"><br>.rela.text 一个.text节中位置的列表，当链接器把这个目标文件和其它文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。<br>如下图中有八个重定位记录。重定位记录的结构如下所示：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> offset;    <span class="comment">/* Offset of the reference to relocate */</span> </span><br><span class="line">	<span class="keyword">int</span> symbol:<span class="number">24</span>, <span class="comment">/* Symbol of the reference should point to */</span></span><br><span class="line">	type:<span class="number">8</span>;	       <span class="comment">/* Relocation type */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure></p>
<p>以下图对sleepsecs的重定位记录为例。它的offset为0x5c，即需要修改的位置是.text段偏移量0x5c处；sybol为0x9，对应.symtab中第9号索引（sleepsecs）；type是0x2，即类型为重定位PC相对引用。<br><img src="/images/2018-HIT-CSAPP-hello/t29.png" alt="pic29"><br><img src="/images/2018-HIT-CSAPP-hello/t30.png" alt="pic30"><br>.symtab 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。</p>
<h2 id="4-4-Hello-o的结果解析"><a href="#4-4-Hello-o的结果解析" class="headerlink" title="4.4 Hello.o的结果解析"></a>4.4 Hello.o的结果解析</h2><p><img src="/images/2018-HIT-CSAPP-hello/t31.png" alt="pic31"><br>hello.o的反汇编与hello.s的差别总体不大，主要体现在以下几方面：</p>
<ol>
<li>全局变量引用 hello.o反汇编采用的是offset(%rip)的形式，而hello.s采用的是symbol(%rip)的形式。</li>
<li>函数调用 hello.o反汇编采用的是call offset的形式，而hello.s采用call symbol的形式。</li>
<li>分支转移 hello.o反汇编采用的是jmp offset的形式，而hello.s采用jmp Label的形式。</li>
<li>栈帧大小不同。<br>机器指令由指令指示符、（寄存器指示符）、（常数字）组成。</li>
</ol>
<p>机器语言与汇编语言大致具有一一对应的关系。但有些特殊情况，比如：</p>
<ol>
<li>转移控制 汇编语言中的jmp指令有直接跳转（在hello.o的反汇编中这个地址为绝对地址）和间接跳转，而转换成机器码后跳转指令会有几种不同的编码，最常用的是PC相对的，还有给出绝对地址的。而汇编器和链接器会选择适当的跳转目的编码。</li>
<li>一条指令可能有多个汇编码中的别名，例如jle和jg。</li>
<li>函数调用，在hello.o的反汇编文件中，call的地址是下一条指令的地址，而对应机器码中的操作码为0。这是因为hello.c中调用的函数都是共享库中的函数，在链接后才能确定函数的最终地址。因而在hello.o中只是将call的地址置为下一条指令的地址，而机器码的操作数则为目标位置（这里为下一条指令）相对于下一条指令的偏移，即0。</li>
</ol>
<h2 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h2><p>本章阐述了hello从hello.s到hello.o的汇编过程。分析了hello.o的ELF格式，并通过查看比较反汇编代码和汇编代码分析了汇编语言与机器码的关系。<br>汇编过程将汇编语言转换为机器码，生成可重定位目标文件，这个文件根据ELF格式对机器码进行打包，并为接下来的链接过程做好了准备。</p>
<h1 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h1><h2 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h2><p>链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可以被加载（复制）到内存执行。链接可以执行于编译时，也可以执行于加载时，甚至执行于运行时。<br>链接器使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的其中一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其它文件。</p>
<h2 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h2><p><code>ld -dynamic-linker /lib64/ld-linux-x86-64.so.2  /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o hello.o -lc /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o /usr/lib/x86_64-linux-gnu/crtn.o -z relro -o hello.out</code><br><img src="/images/2018-HIT-CSAPP-hello/t32.png" alt="pic32"></p>
<h2 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h2><p>Linux的ELF文件格式如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ELF头</td>
<td>描述文件的总体格式，包括程序的入口点</td>
</tr>
<tr>
<td>段头部表</td>
<td>将连续的文件映射到运行时内存段</td>
</tr>
<tr>
<td>.init</td>
<td>定义了一个小函数<code>_init</code></td>
</tr>
<tr>
<td>.text</td>
<td>已编译的程序的机器代码</td>
</tr>
<tr>
<td>.rodata</td>
<td>只读数据</td>
</tr>
<tr>
<td>.data</td>
<td>已初始化的全局和静态C变量</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化的全局和静态C变量</td>
</tr>
<tr>
<td>.symtab</td>
<td>一个符号表，存放在程序中定义和引用的函数和全局变量的信息</td>
</tr>
<tr>
<td>.debug</td>
<td>一个调试符号表</td>
</tr>
<tr>
<td>.line</td>
<td>原始C源程序的行号和.text节中机器指令之间的映射</td>
</tr>
<tr>
<td>.strtab</td>
<td>一个字符串表</td>
</tr>
<tr>
<td>节头部表</td>
<td>每个节的偏移量大小</td>
</tr>
</tbody>
</table>
<h4 id="hello的ELF头"><a href="#hello的ELF头" class="headerlink" title="hello的ELF头"></a>hello的ELF头</h4><p><img src="/images/2018-HIT-CSAPP-hello/t33.png" alt="pic33"><br>节头部表 节头部表对hello中所有的节进行了声明，其中Size是每个节的大小，Offset是每个节在程序中的偏移量，Address是程序被载入后各段的虚拟地址。<br><img src="/images/2018-HIT-CSAPP-hello/t34.png" alt="pic34"></p>
<h4 id="段头部表"><a href="#段头部表" class="headerlink" title="段头部表"></a>段头部表</h4><p><img src="/images/2018-HIT-CSAPP-hello/t35.png" alt="pic35"></p>
<h2 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h2><p><strong>.plt 位于代码段的plt表</strong><br><img src="/images/2018-HIT-CSAPP-hello/t36.png" alt="pic36"><br><strong>.text 代码段 如图为hello!_start函数</strong><br><img src="/images/2018-HIT-CSAPP-hello/t37.png" alt="pic37"><br><strong>.rodata 只读数据段</strong><br><img src="/images/2018-HIT-CSAPP-hello/t38.png" alt="pic38"><br><strong>.data 数据段</strong><br><img src="/images/2018-HIT-CSAPP-hello/t39.png" alt="pic39"><br><strong>.bss 位初始化和被初始化为零的数据段</strong><br><img src="/images/2018-HIT-CSAPP-hello/t40.png" alt="pic40"><br><strong>.got 初始化前的got表</strong><br><img src="/images/2018-HIT-CSAPP-hello/t41.png" alt="pic41"></p>
<h2 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h2><p>hello相比hello多了许多节，如:</p>
<table>
<thead>
<tr>
<th>节</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>.interp</td>
<td>保存ld.so的路径</td>
</tr>
<tr>
<td>.rela.plt</td>
<td>.plt的重定位项目</td>
</tr>
<tr>
<td>.init</td>
<td>初始化代码</td>
</tr>
<tr>
<td>.plt</td>
<td>动态链接过程链接表</td>
</tr>
<tr>
<td>.got</td>
<td>动态链接全局偏移量表，用于存放变量</td>
</tr>
<tr>
<td>.got.plt</td>
<td>动态链接全局偏移量表，用于存放函数</td>
</tr>
</tbody>
</table>
<p>hello.o的objdump与hello的objdump主要有以下几点不同：</p>
<ol>
<li>hello.o的objdump没有<code>_init</code>函数、<code>_start</code>函数、plt表等。</li>
<li>hello.o的objdump中对全局变量的引用地址均为0，函数调用的地址也只是当前指令的下一条指令的地址。</li>
</ol>
<p>hello的重定位记录有两种，分别是PC相对地址的引用和绝对地址的引用。<br>进行重定位时，hello根据.rela.text和.rela.data中的重定位记录，在.symtab中查找需要修改的记录的符号，并结合符号与重定位记录中的位置信息对目标位置进行 修改。如果需要修改的符号是本地符号，则计算偏移量并修改目标位置；如果是共享库中的符号，则创建.got表项（如果是函数还需创建.plt项），并创建新的重定位记录指向.got表项。</p>
<h2 id="5-6-hello的执行流程"><a href="#5-6-hello的执行流程" class="headerlink" title="5.6 hello的执行流程"></a>5.6 hello的执行流程</h2><table>
<thead>
<tr>
<th>hello执行过程中调用的函数</th>
<th>函数的地址</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_dl_start</code></td>
<td>0x7fb78d93ac38</td>
</tr>
<tr>
<td><code>_dl_init</code></td>
<td>0x7fb78d9424e0</td>
</tr>
<tr>
<td><code>_start</code></td>
<td>0x400550</td>
</tr>
<tr>
<td><code>__libc_start_main@plt</code></td>
<td>0x7fb78d590740</td>
</tr>
<tr>
<td><code>__libc_csu_init</code></td>
<td>0x4006d0</td>
</tr>
<tr>
<td><code>init</code></td>
<td>0x4004a8</td>
</tr>
<tr>
<td><code>main</code></td>
<td>0x400646</td>
</tr>
<tr>
<td><code>__GI_exit</code></td>
<td>0x7fb78d5aa030</td>
</tr>
<tr>
<td><code>__run_exit_handlers</code></td>
<td>0x7fb78d5a9f10</td>
</tr>
<tr>
<td><code>_dl_fini</code></td>
<td>0x7fb78d94aab0</td>
</tr>
<tr>
<td><code>_IO_cleanup</code></td>
<td>0x7fb78d5ec310</td>
</tr>
<tr>
<td><code>_IO_flush_all_lockp</code></td>
<td>0x7fb785ec020</td>
</tr>
</tbody>
</table>
<h2 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h2><p>无论在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。<br>而要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表（GOT）。在GOT中，每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个8字节条目。编译器还为GOT中每个条目生成 一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。<br>hello中对.got的初始化是由_dl_start函数执行的。下面的四张图片反应了这一过程：</p>
<p><img src="/images/2018-HIT-CSAPP-hello/t42.png" alt="pic42"><br>.got <code>_dl_start</code>执行前<br><img src="/images/2018-HIT-CSAPP-hello/t43.png" alt="pic43"><br>.got.plt <code>_dl_start</code>执行前<br><img src="/images/2018-HIT-CSAPP-hello/t44.png" alt="pic44"><br>.got <code>_dl_start</code>执行后<br><img src="/images/2018-HIT-CSAPP-hello/t45.png" alt="pic45"><br>.got.plt <code>_dl_start</code>执行后</p>
<p>hello要调取由共享库定义的函数puts，printf，而程序调用一个由共享库定义的函数，编译器没有办法预测这个函数的运行地址，因为定义它的共享模块在运行时可以加载到任何位置。为了解决这个问题，GNU编译系统使用了延迟绑定技术：<br>当hello尝试调用puts时，不直接调用puts，而是调用进入puts对应的PLT条目。这个条目会尝试利用GOT项进行间接跳转。<br><img src="/images/2018-HIT-CSAPP-hello/t46.png" alt="pic46"><br>第一次被调用时，GOT项的值为PLT条目中的下一条指令地址，因而接下来会跳回PLT条目，在把puts的ID 0压入栈后，会转到PLT[0]的位置，PLT[0]通过GOT[1]间接地把动态链接器的一个参数压入栈中，然后通过GOT[2]跳转进动态链接器中。动态链接器使用两个栈条目来确定puts的运行时位置，用这个地址重写puts的GOT项，再把控制传递给puts。<br><img src="/images/2018-HIT-CSAPP-hello/t47.png" alt="pic47"><br>在下一次执行到puts对应的PLT条目时，GOT项已经被修改，因此利用GOT项进行的间接跳转会直接跳转到puts函数。<br><img src="/images/2018-HIT-CSAPP-hello/t48.png" alt="pic48"></p>
<h2 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h2><p>本章讨论了hello的链接过程。链接过程可以发生在编译时，也可以发生在加载时，甚至可以发生在程序执行时。静态链接直接将目标文件和库文件打包至一个可执行文件中，而动态链接则只在可执行目标文件中添加相应重定向记录，并通过GOT表项和延迟绑定的方法实现对目标模块中符号的引用。</p>
<h1 id="第6章-hello进程管理"><a href="#第6章-hello进程管理" class="headerlink" title="第6章 hello进程管理"></a>第6章 hello进程管理</h1><h2 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h2><p><strong>概念</strong>：进程是一个执行中的程序的实例，系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p><strong>作用</strong>：进程提供给应用程序两个关键抽象：</p>
<ol>
<li>逻辑控制流<br>a)    每个程序似乎独占地使用CPU<br>b)    通过OS内核的上下文切换机制提供</li>
<li>私有地址空间<br>a)    每个程序似乎独占地使用内存系统<br>b)    OS内核的虚拟内存机制提供</li>
</ol>
<h2 id="6-2-简述壳Shell-bash的作用与处理流程"><a href="#6-2-简述壳Shell-bash的作用与处理流程" class="headerlink" title="6.2 简述壳Shell-bash的作用与处理流程"></a>6.2 简述壳Shell-bash的作用与处理流程</h2><p><strong>概念</strong>：shell是一个交互型的应用级程序，它代表用户运行其它程序。它执行一系列的读/求值步骤，然后终止。其中读步骤读取来自用户的一个命令行，求值步骤解析命令行，并代表用户运行程序。</p>
<p><strong>处理流程</strong>：读取来自用户的命令行并解析，如果是内部命令则直接执行内部命令，否则fork一个shell进程，并在这个进程中用execve加载目标程序，按照命令中的参数决定在前台或者后台运行目标程序，当前台程序结束时用waitpid回收进程。</p>
<h2 id="6-3-Hello的fork进程创建过程"><a href="#6-3-Hello的fork进程创建过程" class="headerlink" title="6.3 Hello的fork进程创建过程"></a>6.3 Hello的fork进程创建过程</h2><p>在bash中输入 <code>./hello 1******* ***</code> 并敲击回车后，bash解析此条命令，发现./hello不是bash内置命令，于是在当前目录尝试寻找并执行hello文件。此时bash使用fork函数创建一个子进程（这个子进程得到与父进程用户级虚拟地址空间相同但是独立的一份副本），并更改这个子进程的进程组编号。并准备在这个子进程执行execve。</p>
<h2 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h2><p>在新创建的子进程中，execve函数加载并运行hello，且带参数列表argv和环境变量envp。在execve加载了hello之后，它调用<code>_start</code>，<code>_start</code>设置栈，并将控制传递给新程序的主函数。</p>
<h2 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h2><p>在输入合适参数执行hello程序之后，hello进程一开始运行在用户模式。内核为hello维持一个上下文，它由一系列的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构（比如页表、进程表、文件表）。</p>
<p>在hello运行时，也有一些其它进程在并行地运行，这些进程的逻辑流的执行时间与hello的逻辑流重叠，称为并发流。而一个进程和其它进程轮流运行的概念叫作多任务，一个进程执行它的控制流的一部分的每一时间段叫做时间片。因此，多任务也叫做时间分片。<br><img src="/images/2018-HIT-CSAPP-hello/t49.png" alt="pic49"><br>不久hello调用printf与sleep，这两个函数引发系统调用，系统调用使得进程从用户模式变为内核模式，处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式，而执行sleep系统调用时，内核可能会执行上下文切换而非将控制返回给hello进程。在切换的第一部分中，内核代表hello在内核模式下执行指令，然后在某一时刻，它开始代表另一个进程在内核模式下执行指令，在切换之后，内核代表那个进程在用户模式下执行指令。<br>而这个切换过程可以分为三个步骤<br>1) 保存当前进程的上下文<br>2) 恢复某个先前被抢占的进程被保存的上下文<br>3) 将控制传递给这个新恢复的进程。</p>
<p><img src="/images/2018-HIT-CSAPP-hello/t50.png" alt="pic50"><br>这时我们说内核调度了一个新的进程，在内核调度了一个新的进程后，它就抢占了当前进程。<br>不仅仅是系统调用会导致上下文切换，中断也会。当hello执行了一段时间（通常是1-10ms）后，定时器引发的中断也会导致内核执行上下文切换并调度一个新的进程。<br>接下来的十秒中，内核继续执行上下文切换，轮流运行hello与其它进程，十次循环结束后，hello返回，程序终止。</p>
<h2 id="6-6-hello的异常与信号处理"><a href="#6-6-hello的异常与信号处理" class="headerlink" title="6.6 hello的异常与信号处理"></a>6.6 hello的异常与信号处理</h2><h3 id="6-6-1-hello在运行时可能会出现的异常"><a href="#6-6-1-hello在运行时可能会出现的异常" class="headerlink" title="6.6.1 hello在运行时可能会出现的异常"></a>6.6.1 hello在运行时可能会出现的异常</h3><p><strong>故障</strong>：缺页异常 加载完成后hello进程的页表被映射到hello文件，但还未将实际代码拷贝至内存，在执行到相应地址的代码时会引发缺页异常，拷贝相关代码。<br><strong>中断</strong>：如来自键盘的信号（见下文） 定时器中断<br><strong>陷阱</strong>：系统调用造成，如sleep函数<br><strong>终止</strong>：不可恢复的错误，如hello执行时硬件被物理伤害造成奇偶校验错误。</p>
<h3 id="6-6-2-hello在运行时可能会接受到的信号"><a href="#6-6-2-hello在运行时可能会接受到的信号" class="headerlink" title="6.6.2 hello在运行时可能会接受到的信号"></a>6.6.2 hello在运行时可能会接受到的信号</h3><p><strong>SIGINT 中断信号</strong> 当用户键入ctrl+c时会产生这个信号，接受这个信号，程序默认终止，如果有已经定义的handler，则会执行handler。<br><img src="/images/2018-HIT-CSAPP-hello/t51.png" alt="pic51"><br><strong>SIGTSTP 停止信号</strong> 当用户键入ctrl+z时会产生这个信号，接受这个信号的默认行为是中止程序，这个默认行为不可更改。<br><img src="/images/2018-HIT-CSAPP-hello/t52.png" alt="pic52"><br><strong>SIGKILL 终止信号</strong> 使用kill -9向hello发出这个信号，接受这个信号的默认行为是终止程序，这个默认行为不可更改。<br><img src="/images/2018-HIT-CSAPP-hello/t53.png" alt="pic53"><br><strong>SIGCHLD 子进程信号</strong> hello终止或中止时会向父进程（bash）发出这个信号。如果hello中止；则bash会将其标记为中止状态，如果hello已经终止，则bash会回收hello进程。</p>
<h2 id="6-7本章小结"><a href="#6-7本章小结" class="headerlink" title="6.7本章小结"></a>6.7本章小结</h2><p>本章介绍了进程的概念与作用，并通过hello程序演示了进程的执行过程。<br>简要介绍了shell的工作流程，并分析了linux下的异常处理机制，介绍了应用程序的信号处理。</p>
<p>shell执行程序是通过fork函数以及execve创建新的进程并执行程序的。<br>程序运行中可能会遇到异常，异常分为中断、陷阱、故障、终止四类，由异常处理子程序来处理，信号作为一种特殊的异常，实现了对程序运行终止等操作的控制。</p>
<h1 id="第7章-hello的存储管理"><a href="#第7章-hello的存储管理" class="headerlink" title="第7章 hello的存储管理"></a>第7章 hello的存储管理</h1><h2 id="7-1-hello的存储器地址空间"><a href="#7-1-hello的存储器地址空间" class="headerlink" title="7.1 hello的存储器地址空间"></a>7.1 hello的存储器地址空间</h2><p><strong>逻辑地址空间</strong>：段地址：偏移地址<br>23：8048000 段寄存器（CS等16位）：偏移地址（16/32/64）</p>
<ul>
<li>实模式下：逻辑地址CS：EA=物理地址CS * 16 + EA</li>
<li>保护模式下：以段描述符作为下标，到GDT/LDT表查表获得段地址，<br>段地址+偏移地址=线性地址。</li>
</ul>
<p><strong>线性地址空间</strong>: 非负整数地址的有序集合:：{0, 1, 2, 3 … }<br><strong>虚拟地址空间</strong>: N = 2n 个虚拟地址的集合=线性地址空间<br>{0, 1, 2, 3, …, N-1}<br><strong>物理地址空间</strong>: M = 2m 个物理地址的集合<br>    {0, 1, 2, 3, …, M-1}<br>Intel采用段页式存储管理（MMU实现）<br><strong>段式管理</strong>：  逻辑地址-&gt;线性地址==虚拟地址<br><strong>页式管理</strong>：  虚拟地址-&gt;物理地址</p>
<h2 id="7-2-Intel逻辑地址到线性地址的变换-段式管理"><a href="#7-2-Intel逻辑地址到线性地址的变换-段式管理" class="headerlink" title="7.2 Intel逻辑地址到线性地址的变换-段式管理"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h2><p>实模式下：逻辑地址CS：EA=物理地址CS * 16 + EA<br>保护模式下：以段描述符作为下标，到GDT/LDT表查表获得段地址，<br>段地址+偏移地址=线性地址。<br><img src="/images/2018-HIT-CSAPP-hello/t54.png" alt="pic54"></p>
<h2 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h2><p>hello的线性地址到物理地址的变换需要查询页表得出，hello的线性地址被分成两个部分，第一部分虚拟页号VPN用于在页表查询物理页号PPN，而第二部分虚拟页偏移量VPO则与查询到的物理页号PPN一起组成物理地址。<br><img src="/images/2018-HIT-CSAPP-hello/t55.png" alt="pic55"></p>
<h2 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h2><p><img src="/images/2018-HIT-CSAPP-hello/t56.png" alt="pic56"><br>虚拟地址VA被分成VPN和VPO两部分，VPN被分为TLBT和TLBI用于在TLB中查询。根据TLBI确定TLB中的组索引，并根据TLBT判断PPN是否已被缓存到TLB中，如果TLB命中，则直接返回PPN，否则会到页表中查询PPN。在页表中查询PPN时，VPN会被分为四个部分，分别用作一二三四级页表的索引，而前三级页表的查询结果为下一级页表的基地址，第四级页表的查询结果为PPN。将查询到的PPN与VPO组合，得到物理地址PA。</p>
<h2 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h2><p>MMU发送物理地址PA给L1缓存，L1缓存从物理地址中抽取出缓存偏移CO、缓存组索引CI以及缓存标记CT。高速缓存根据CI找到缓存中的一组，并通过CT判断是否已经缓存地址对应的数据，若缓存命中，则根据偏移量直接从缓存中读取数据并返回；若缓存不命中，则继续从L2、L3缓存中查询，若仍未命中，则从主存中读取数据。</p>
<h2 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h2><p>当fork函数被新进程调用时，内核为新进程创建各种数据结构，并分配给它唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</p>
<p>当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p>
<h2 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h2><p>execve函数在当前进程中加载并运行包含在可执行文件hello中的程序，加载并运行hello时出现的内存映射有：</p>
<ol>
<li>映射私有区域 为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。Bss区域时请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。 </li>
<li>映射共享区域 如果hello程序与共享对象（或目标链接），比如C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。<br><img src="/images/2018-HIT-CSAPP-hello/t57.png" alt="pic57"></li>
</ol>
<h2 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h2><p><strong>缺页故障</strong>：虚拟内存中的字不在物理内存中（DRAM缓存不命中）<br>如下图，VP3已经被映射到页表中，但却没有被缓存到物理内存中，此时堆VP3的引用会引发缺页故障。<br><img src="/images/2018-HIT-CSAPP-hello/t58.png" alt="pic58"><br>缺页会导致页面出错引发一个缺页中断，而缺页异常处理程序会选择一个牺牲页（如下图选择了VP4，将VP4从内存交换到磁盘，并从磁盘读取VP3交换到物理内存）。<br><img src="/images/2018-HIT-CSAPP-hello/t59.png" alt="pic59"><br>此时令导致缺页的指令重新启动，就可以使得页面命中了。</p>
<h2 id="7-9动态存储分配管理"><a href="#7-9动态存储分配管理" class="headerlink" title="7.9动态存储分配管理"></a>7.9动态存储分配管理</h2><p>printf会调用malloc，接下来提一下动态内存分配的基本原理。</p>
<p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的需内存片，要么是已分配的，要么是空闲的。已分配的块显示地保留为供应用程序使用。空闲块可以用来分配。空闲块保持空闲，直到它显示地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显示执行的，要么是内存分配器自身隐式执行的。</p>
<p>两种堆的数据结构组织形式：</p>
<h4 id="带标签的隐式空闲链表"><a href="#带标签的隐式空闲链表" class="headerlink" title="带标签的隐式空闲链表"></a>带标签的隐式空闲链表</h4><p>带标签的隐式空闲链表的数据组织方式如下图：<br><img src="/images/2018-HIT-CSAPP-hello/t60.png" alt="pic60"><br>空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。</p>
<h4 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h4><p>显式空闲链表将链表的指针存放在空闲块的主体里面。堆被组织成一个双向空闲链表，在每个空闲块中，都包含一个pred和succ指针，如下图所示：<br><img src="/images/2018-HIT-CSAPP-hello/t61.png" alt="pic61"></p>
<h2 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h2><p>现代操作系统多采用虚拟内存系统，访存时地址需要从逻辑地址翻译到虚拟地址并进一步翻译成物理地址。<br>操作系统通过地址的页式管理来实现对磁盘的缓存、内存管理、内存保护等功能。<br>虚拟内存为便捷的加载、进程管理提供了可能。<br>程序运行过程中往往涉及动态内存分配，动态内存分配通过动态内存分配器完成。</p>
<h1 id="第8章-hello的IO管理"><a href="#第8章-hello的IO管理" class="headerlink" title="第8章 hello的IO管理"></a>第8章 hello的IO管理</h1><h2 id="8-1-Linux的IO设备管理方法"><a href="#8-1-Linux的IO设备管理方法" class="headerlink" title="8.1 Linux的IO设备管理方法"></a>8.1 Linux的IO设备管理方法</h2><p>一个linux文件就是一个m个字节的序列：<br>    <strong>B0, B1, … Bk, …, Bm-1</strong></p>
<p>所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：UNIX I/O。</p>
<h2 id="8-2-简述Unix-IO接口及其函数"><a href="#8-2-简述Unix-IO接口及其函数" class="headerlink" title="8.2 简述Unix IO接口及其函数"></a>8.2 简述Unix IO接口及其函数</h2><h4 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h4><p><code>int open(char *filename, int flags, mode_t mode);</code><br>open函数将filename转换为一个文件描述符，并返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。<br><code>int close(int fd);</code><br>进程通过调用close关闭一个打开的文件。</p>
<h4 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h4><p><code>ssize_t read(int fd, void *buf, size_t n);</code><br>read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。<br><code>ssize_t write(int fd, const void *buf, size_t n);</code><br>write函数从内存位置buf复制之多n个字节到描述符fd的当前文件位置。<br><code>DIO *opendir(const char *name);</code><br>函数opendir以路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。<br><code>struct dirent *readdir(DIR *dirp);</code><br>每次对readdir的调用返回的都是指向流dirp中下一个目录项的指针，或者，如果没有更过目录项则返回NULL。<br><code>int closedir(DIR *dirp);</code><br>函数closedir关闭流并释放其所有的资源。</p>
<h4 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h4><p><code>int dup2(int oldfd, int newfd);</code><br>dup2函数复制描述符表表项oldfd到描述符表项newfd，覆盖描述符表表项newfd以前的内容。如果newfd已经打开了，dup2会在复制oldfd之前关闭newfd。</p>
<h2 id="8-3-printf的实现分析"><a href="#8-3-printf的实现分析" class="headerlink" title="8.3 printf的实现分析"></a>8.3 printf的实现分析</h2><p>printf函数的实现大致与下面代码一致：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    va_list arg = (va_list)((<span class="keyword">char</span> *)(&amp;fmt) + <span class="number">4</span>);</span><br><span class="line">    i = <span class="built_in">vsprintf</span>(buf, fmt, arg);</span><br><span class="line">    write(buf, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中va_list_arg是边长参数列表中的第一个参数的地址，vsprintf的作用是以fmt作为格式字符串，根据arg中的参数，向buf中输出格式化后的字符串。write则是Unix I/O接口，它将栈中参数存入寄存器，并由它来进行系统调用。write的实现大致如下，其中ecx是字符个数，ebx存放第一个字符地址：<br>write:<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   mov eax, _NR_write</span><br><span class="line">   mov ebx, [esp + 4]</span><br><span class="line">   mov ecx, [esp + 8]</span><br><span class="line">int INT_VECTOR_SYS_CALL</span><br></pre></td></tr></table></figure></p>
<p>接下来syscall将字符串从寄存器中通过总线复制到显卡显存中。字符显示驱动子程序通过ASCII码在字模库中找到点阵信息并将其存储到vram中。接下来显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。此时字符串就被打印到了屏幕上。</p>
<h2 id="8-4-getchar的实现分析"><a href="#8-4-getchar的实现分析" class="headerlink" title="8.4 getchar的实现分析"></a>8.4 getchar的实现分析</h2><p>getchar函数的大致实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">return</span> (read(<span class="number">0</span>,&amp;c,<span class="number">1</span>)==<span class="number">1</span>)?(<span class="keyword">unsigned</span> <span class="keyword">char</span>)c:EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getchar函数通过调用read函数来读取字符。read函数由三个参数，第一个参数为文件描述符fd，fd为0表示标准输入；第二个参数为输入内容的指针；第三个参数为读入字符的个数。read函数的返回值是读入字符的个数，若出错则返回-1。</p>
<p>当用户按键时，键盘接口会产生一个键盘扫描码和一个中断请求，中断处理程序会从键盘接口取得按键扫描码并把它转换成ASCII码，保存到系统的键盘缓冲区。</p>
<p>read执行一个系统调用，按照系统调用从键盘缓冲区读取按键ASCII码，直到接受到回车键才返回。</p>
<h2 id="8-5本章小结"><a href="#8-5本章小结" class="headerlink" title="8.5本章小结"></a>8.5本章小结</h2><p>I/O时在主存和外部设备之间复制数据的过程。在Linux中，I/O的实现是通过Unix I/O函数来执行的。Linux把所有的I/O设备模型化为文件，并提供统一的Unix I/O接口，这使得所有的输入输出都能以一种统一且一致的方式来执行。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><h1 id="hello的一生"><a href="#hello的一生" class="headerlink" title="hello的一生"></a>hello的一生</h1><ol>
<li>用户从键盘输入，得到hello.c源文件。</li>
<li>编译器和汇编器对hello.c进行预处理，然后对其进行编译和汇编，得到可重定位目标文件hello.o。</li>
<li>链接器对hello.o进行链接，并得到可执行目标文件hello，此时hello已经可以被操作系统加载和执行。</li>
<li>bash执行hello，首先bash会fork一个进程，然后在这个新的进程中execve hello，execve会清空当前进程的数据并加载hello，然后把rip指向hello的程序入口，把控制权交给hello。</li>
<li>hello与许多进程并行执行，执行过程中由于系统调用或者计时器中断，会导致上下文切换，内核会选择另一个进程进行调度，并抢占当前的hello进程。</li>
<li>hello执行的过程中可能收到来自键盘或者其它进程的信号，当收到信号时hello会调用信号处理程序来进行处理，可能出现的行为有停止终止忽略等。</li>
<li>hello输出信息时需要调用printf和getchar，而printf和getchar的实现需要调用Unix I/O中的write和read函数，而它们的实现需要借助系统调用。</li>
<li>hello中的访存操作，需要经历逻辑地址到线性地址最后到物理地址的变换，而访问物理地址的数据可能已被缓存至高速缓冲区，也可能位于主存中，也可能位于磁盘中等待被交换到主存。</li>
<li>hello结束进程后，bash作为hello的父进程会回收hello进程。</li>
</ol>
<p>在Kernighan和Ritchie的关于C编程语言的经典教材中，他们通过一个简单的hello程序来向读者介绍C。尽管hello非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，计算机系统课程的学习，就是让我们了解当在系统上执行hello程序时，系统发生了什么以及为什么会这样。</p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>\[2019春软件构造\]优化笔记：我是如何将实验五的建图操作压缩到1.5s的</title>
    <url>/archives/3309.html</url>
    <content><![CDATA[<p>本文使用JGraphT存储Social Network中的人际关系图结构，使用JGraphT中的预设算法压缩建图时间。</p>
<p>注：这里的建图时间包含最短路求解与轨道插入，下文重点优化最短路求解时间。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前写完软件构造Lab2时，rainywang有建议过将Lab2的Graph ADT进行封装以便之后的使用。</p>
<p>在写Lab3时的Social Network时，为了保存和处理关系图，一开始我直接迁移了Lab2的代码，将Lab2的ADT搬到Lab3并添加了数个API。但看到标签为Larger的几个文件，心里还是对Lab2中<strong>naïve</strong>的ADT实现感到担忧。仅仅一个返回邻接顶点的操作时间复杂度都要O(n)，明显它是不能够胜任Lab3或者之后的Lab5的性能要求的。</p>
<p>rainywang在Lab2课程结束时，不仅建议过封装Lab2的ADT，也提出了这样一个疑问：网上是否已经有相关图算法ADT了？这个既是疑问又带有明显暗示的说法让人感到不安，显然图算法这个轮子已经被人重造过很多次了，我当然有理由相信有人已经为之写出了不错的java库。</p>
<p>抱着找找看的心理，在Google上尝试搜索了下”java graph library”，在返回的第一个结果发现了<a href="https://jgrapht.org/" rel="external nofollow noopener noreferrer" target="_blank">JGraphT</a>，它的开源许可证为 <code>Eclipse Public License - v 2.0</code>。</p>
<p><img src="https://jgrapht.org/img/logo.png" alt="JGraphT Logo"></p>
<blockquote>
<h3 id="a-Java-library-of-graph-theory-data-structures-and-algorithms"><a href="#a-Java-library-of-graph-theory-data-structures-and-algorithms" class="headerlink" title="a Java library of graph theory data structures and algorithms"></a>a Java library of graph theory data structures and algorithms</h3><h3 id="flexible"><a href="#flexible" class="headerlink" title="flexible"></a><em>flexible</em></h3><h5 id="any-object-can-be-used-for-vertex-and-edge-types-with-full-type-safety-via-generics"><a href="#any-object-can-be-used-for-vertex-and-edge-types-with-full-type-safety-via-generics" class="headerlink" title="any object can be used for vertex and edge types, with full type safety via generics"></a><strong>any object</strong> can be used for vertex and edge types, with full <strong>type safety</strong> via generics</h5><h5 id="edges-can-be-directed-or-undirected-weighted-or-unweighted"><a href="#edges-can-be-directed-or-undirected-weighted-or-unweighted" class="headerlink" title="edges can be directed or undirected, weighted or unweighted"></a>edges can be <strong>directed</strong> or <strong>undirected</strong>, <strong>weighted</strong> or <strong>unweighted</strong></h5><h5 id="simple-graphs-multigraphs-and-pseudographs"><a href="#simple-graphs-multigraphs-and-pseudographs" class="headerlink" title="simple graphs, multigraphs, and pseudographs"></a><strong>simple graphs</strong>, <strong>multigraphs</strong>, and <strong>pseudographs</strong></h5><h3 id="powerful"><a href="#powerful" class="headerlink" title="powerful"></a><em>powerful</em></h3><h5 id="specialized-iterators-for-graph-traversal-DFS-BFS-etc"><a href="#specialized-iterators-for-graph-traversal-DFS-BFS-etc" class="headerlink" title="specialized iterators for graph traversal (DFS, BFS, etc)"></a>specialized <strong>iterators</strong> for graph traversal (<strong>DFS</strong>, <strong>BFS</strong>, etc)</h5><h5 id="algorithms-for-path-finding-clique-detection-isomorphism-detection-coloring-common-ancestors-tours-connectivity-matching-cycle-detection-partitions-cuts-flows-centrality-spanning-and-the-list-goes-on"><a href="#algorithms-for-path-finding-clique-detection-isomorphism-detection-coloring-common-ancestors-tours-connectivity-matching-cycle-detection-partitions-cuts-flows-centrality-spanning-and-the-list-goes-on" class="headerlink" title="algorithms for path finding, clique detection, isomorphism detection, coloring, common ancestors, tours, connectivity, matching, cycle detection, partitions, cuts, flows, centrality, spanning, and the list goes on"></a><strong>algorithms</strong> for path finding, clique detection, isomorphism detection, coloring, common ancestors, tours, connectivity, matching, cycle detection, partitions, cuts, flows, centrality, spanning, <strong>and the list goes on</strong></h5><h3 id="efficient"><a href="#efficient" class="headerlink" title="efficient"></a><em>efficient</em></h3><h5 id="designed-for-performance-with-near-native-speed-in-many-cases"><a href="#designed-for-performance-with-near-native-speed-in-many-cases" class="headerlink" title="designed for performance, with near-native speed in many cases"></a>designed for performance, with <strong>near-native</strong> speed in many cases</h5><h5 id="adapters-for-memory-optimized-fastutil-representation"><a href="#adapters-for-memory-optimized-fastutil-representation" class="headerlink" title="adapters for memory-optimized fastutil representation"></a>adapters for memory-optimized <strong>fastutil</strong> representation</h5></blockquote>
<p>支持带权有向边、无向边，实现好的BFS和最短路算法，以及<strong>高效率</strong>。满足了Lab3的所有要求，同时也许能顺便满足Lab5的性能需求。此时我还有些犹豫，因为我不确定在Lab3 deadline将至的情况下，JGraphT的学习成本是否可以平衡掉之后代码的调试时间。不过考虑到JGraphT的算法实现较全可以比较容易的满足需求的变化，以及著名的<em>Don’t reinvent the wheel</em>原则，我还是花了两个小时来阅读文档，事后证明这是一个没有让我后悔的决定。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>JGraphT的Graph ADT默认支持两种边：带权边<code>DefaultWeightedEdge</code>和无权边<code>DefaultEdge</code>。Social Network需要保存人与人之间的关系以及亲密度，且<code>312change</code>中人的关系是有向的。因此我创建了两张有向图，分别用于保存人与人之间的关系以及亲密度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Graph&lt;String, DefaultWeightedEdge&gt; intimacy = <span class="keyword">new</span> SimpleDirectedWeightedGraph&lt;&gt;(DefaultWeightedEdge<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//亲密度图</span></span><br><span class="line"><span class="keyword">protected</span> Graph&lt;String, DefaultEdge&gt; relation = <span class="keyword">new</span> SimpleDirectedGraph&lt;&gt;(DefaultEdge<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//关系图</span></span><br></pre></td></tr></table></figure>
<p>对节点和边的操作类似于Lab2中定义的API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intimacy.addVertex(name1); <span class="comment">//插入节点</span></span><br><span class="line">DefaultWeightedEdge e = intimacy.addEdge(name1, name2); <span class="comment">//插入边</span></span><br><span class="line">intimacy.setEdgeWeight(e, intimacy); <span class="comment">//设置边权</span></span><br><span class="line">relation.removeEdge(name1, name2); <span class="comment">//删除边</span></span><br></pre></td></tr></table></figure>
<p>计算Friend所在的轨道需要得到Friend与中心点User的最短距离。担心之后可能出现奇怪的需求（如要求轨道以亲密度的最短距离来定义），我一开始没有根据<strong>关系没有边权</strong>或者说<strong>图边权相等</strong>这一条件采用BFS，而采用了在最短路问题中适用度更高的Dijkstra算法。JGraphT中的Dijkstra算法实现疑似使用了Decorator模式，调用十分简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DijkstraShortestPath&lt;String, DefaultEdge&gt; dijkstraAlg = <span class="keyword">new</span> DijkstraShortestPath&lt;&gt;(relation); <span class="comment">//定义算法</span></span><br><span class="line">SingleSourcePaths&lt;String, DefaultEdge&gt; iPaths = dijkstraAlg.getPaths(centralName); <span class="comment">//求以centralName为起点的单源最短路</span></span><br><span class="line"></span><br><span class="line">GraphPath&lt;String, DefaultEdge&gt; path = iPaths.getPath(name); <span class="comment">//获取name节点的最短路</span></span><br><span class="line"><span class="keyword">if</span>(path != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> track = path.getLength(); <span class="comment">//得到最短路距离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时对Lab3的Larger文件进行读取和建图操作时间已经压缩到了3s左右。</p>
<blockquote>
<p>这里还有一个有趣的插曲：在写完了Lab3不久，在一节形式语言与自动机课上，老师打趣地布置了一个画有2k个点的DFA的任务，并开玩笑说要画出这个图要相当一段时间，能画出这个图的学生期末加5分。JgraphT支持伪图非常适合用来表示自动机，而且自带GraphViz导出API。结果在下午老师布置那个任务之后的3个小时，我就画出了那张图。</p>
<p>这个项目放在<a href="https://github.com/mhlwsk/DFA" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/mhlwsk/DFA</a></p>
<p><del>果然软件构造助力数学课程的学习</del>。</p>
</blockquote>
<p>Lab5中的数据量急剧扩大，虽然Dijkstra的速度非常快（时间复杂度为O(E*log(E))，单纯建图只需要数秒），但仍有优化的余地。考虑到<strong>关系边权相等</strong>这一条件，我把Lab3中采用的Dijkstra换成了时间复杂度为O(n)的BFS，JGraphT中的BFS采用<strong>迭代器模式</strong>实现，它的调用也非常简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BreadthFirstIterator&lt;String, DefaultEdge&gt; bfsIterator = </span><br><span class="line">    <span class="keyword">new</span> BreadthFirstIterator&lt;&gt;(relation, centralName); <span class="comment">// 定义BFS序迭代器，以centralName为遍历起点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (bfsIterator.hasNext()) &#123;</span><br><span class="line">    String name = bfsIterator.next();</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> distance = bfsIterator.getDepth(name); <span class="comment">// 获取BFS深度</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时Lab5中的<code>SocialNetworkCircle.txt</code>文件建图时间已经压缩到了1.5s左右。</p>
<blockquote>
<p>这里有一个插曲：搜索JgraphT的API时，我发现一个<a href="https://jgrapht.org/javadoc-SNAPSHOT/org/jgrapht/alg/shortestpath/BFSShortestPath.html" rel="external nofollow noopener noreferrer" target="_blank">BFSShortestPath&lt;V,E&gt;</a>类，它的API与之前用到的<code>DijkstraShortestPath&lt;V,E&gt;</code>一致。一开始我尝试直接把后者改成前者，但编译器提示<code>BFSShortestPath&lt;V,E&gt;</code>不存在。在确认了不是包导入的问题后，我查看了Github上BFSShortestPath的<a href="https://github.com/jgrapht/jgrapht/blob/master/jgrapht-core/src/main/java/org/jgrapht/alg/shortestpath/BFSShortestPath.java" rel="external nofollow noopener noreferrer" target="_blank">源码</a>，发现这个文件是<code>13 Feb</code>创建的。而截至此文写作时（<code>1 June</code>）JgraphT最新的<code>release 1.3.0</code>是在<code>13 Nov 2018</code>发布的。也即JGraphT的doc比release都要新。显然这是Javadoc基于最新的源码自动生成的，这里不得不感叹一下javadoc的强大。</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>不要重新发明轮子</strong>，当面对一个具体问题时优先考虑下是否已经有较好的实现了，使用它们可能有助于减轻代码实现与调试导致的焦虑、脱发与偏头痛，并且能够获得较好的可靠性与效率。</p>
<p>不过，使用JGraphT似乎与过早优化原则相抵触：</p>
<blockquote>
<p><strong>Premature optimization is the root of all evil</strong> – Donald Knuth</p>
</blockquote>
<p>我的理解是，如果优化使得软件的其它各项指标（如可变性）急剧下降，那么滞后优化是必要的；而采用JGraphT作为一项优化使得应用的changeability反而有所增加，此时就不必拘泥教条。毕竟，软件开发的过程也是软件的各项指标相互折衷的过程。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>软件构造</tag>
      </tags>
  </entry>
  <entry>
    <title>[2019春软件构造]期末总结(思维导图)</title>
    <url>/archives/19868.html</url>
    <content><![CDATA[<p>图片较大，请右键另存为查看。<br><a id="more"></a></p>
<p><img src="/images/2019-software-construction/software-construction.png" alt="pic1"></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>软件构造</tag>
      </tags>
  </entry>
  <entry>
    <title>51Nod1022 石子归并（环形）[区间DP，四边形不等式优化]</title>
    <url>/archives/49567.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1022" rel="external nofollow noopener noreferrer" target="_blank">https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1022</a></p>
<p>线性石子合并，改成了环形并且n达到了1000。环形比较好解决，把n堆石子复制一遍放到原来的石子后边，长度仍然枚举到n，区间右边界枚举到<code>2*n</code>，答案就是所有长度为n的区间的解的最大值。<br>麻烦的是数据范围比较大，O(n^3)的算法无法解决，这里需要用到四边形不等式优化。<br>优化本身的数学证明比较麻烦，直接记条件和结论了。</p>
<blockquote>
<p><strong>四边形不等式优化条件</strong></p>
</blockquote>
<blockquote>
<p>在动态规划中，经常遇到形如下式的转台转移方程：<br><code>m(i,j)=min{m(i,k-1),m(k,j)}+w(i,j)(i≤k≤j)（min也可以改为max）</code><br>上述的m(i,j)表示区间[i,j]上的某个最优值。w(i,j)表示在转移时需要额外付出的代价。该方程的时间复杂度为O(N^3)。</p>
</blockquote>
<blockquote>
<p>下面我们通过四边形不等式来优化上述方程，首先介绍什么是”区间包含的单调性“和”四边形不等式“<br>（1）<strong>区间包含的单调性</strong>：如果对于<code>i≤i&#39;&lt;j≤j&#39;</code>，有<code>w(i&#39;,j)≤w(i,j&#39;)</code>，那么说明w具有区间包含的单调性。（可以形象理解为如果小区间包含于大区间中，那么小区间的w值不超过大区间的w值）<br>（2）<strong>四边形不等式</strong>：如果对于<code>i≤i&#39;&lt;j≤j&#39;</code>，有<code>w(i,j)+w(i&#39;,j&#39;)≤w(i&#39;,j)+w(i,j&#39;)</code>，我们称函数w满足四边形不等式。（可以形象理解为两个交错区间的w的和不超过小区间与大区间的w的和）</p>
</blockquote>
<blockquote>
<p>下面给出两个定理</p>
</blockquote>
<blockquote>
<p><strong>定理一：如果上述的w函数同时满足区间包含单调性和四边形不等式性质，那么函数m也满足四边形不等式性质。</strong><br>我们再定义s(i,j)表示m(i,j)取得最优值时对应的下标（即i≤k≤j时，k处的w值最大，则s(i,j)=k）。此时有如下定理<br><strong>定理二：假如m(i,j)满足四边形不等式，那么s(i,j)单调，即s(i,j)≤s(i,j+1)≤s(i+1,j+1)。</strong></p>
</blockquote>
<blockquote>
<p>好了，有了上述的两个定理后，我们发现如果w函数满足区间包含单调性和四边形不等式性质，那么有<code>s(i,j-1)≤s(i,j)≤s(i+1,j)</code>。即原来的状态转移方程可以改写为下式：<br><code>m(i,j)=min{m(i,k-1),m(k,j)}+w(i,j)(s(i,j-1)≤k≤s(i+1,j))（min也可以改为max）</code>  注：具体代码实现中k取满足条件的最大值或最小值，下文代码取的最大值。</p>
</blockquote>
<blockquote>
<p>由于这个状态转移方程枚举的是区间长度L=j-i，而s(i,j-1)和s(i+1,j)的长度为L-1，是之间已经计算过的，可以直接调用。不仅如此，区间的长度最多有n个，对于固定的长度L，不同的状态也有n个，故时间复杂度为O(N^2)，而原来的时间复杂度为O(N^3)，实现了优化！今后只需要根据方程的形式以及w函数是否满足两条性质即可考虑使用四边形不等式来优化了。</p>
</blockquote>
<blockquote>
<p>引用自<a href="https://blog.csdn.net/u014800748/article/details/45750737" rel="external nofollow noopener noreferrer" target="_blank">XDU_Skyline的博客</a></p>
</blockquote>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) &#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]-sum[i-n<span class="number">-1</span>]+sum[i-n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j++)</span><br><span class="line">        dp[i][j] = i==j ? <span class="number">0</span> : inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*n;i++) &#123;</span><br><span class="line">        dp[i][i+<span class="number">1</span>]=sum[i+<span class="number">1</span>]-sum[i<span class="number">-1</span>];</span><br><span class="line">        s[i][i+<span class="number">1</span>]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=<span class="number">2</span>*n;l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=s[l][r<span class="number">-1</span>];m&lt;=s[l+<span class="number">1</span>][r];m++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=dp[l][m<span class="number">-1</span>]+dp[m][r]+sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(tmp&lt;=dp[l][r]) &#123;  <span class="comment">//保证s中保存的m是满足dp(i,j)=min&#123;dp(i,m-1),dp(m,j)&#125;+dp(i,j)(s(i,j-1)≤m≤s(i+1,j))的最大值</span></span><br><span class="line">                    dp[l][r]=tmp;</span><br><span class="line">                    s[l][r]=m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+n<span class="number">-1</span>&lt;=<span class="number">2</span>*n;i++) &#123;</span><br><span class="line">        ans=min(ans,dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>区间DP</tag>
        <tag>四边形不等式优化</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ1012最大数maxnumber 做题笔记</title>
    <url>/archives/1530.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1012" rel="external nofollow noopener noreferrer" target="_blank">http://www.lydsy.com/JudgeOnline/problem.php?id=1012</a></p>
<p>这题每次都只查看最后l位的最大值，因而<strong>位置靠后的数如果大于前面的数，则前面的数是没有用的，直接扔掉即可</strong>。这样维护了一个单调递减的栈，同时再维护一个同步的位置栈，查询时需要根据位置栈找到所需最大值的位置，输出对应的最大值即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200009</span>;</span><br><span class="line"><span class="keyword">int</span> q[N],pos[N];</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> m,d;</span><br><span class="line">	<span class="keyword">int</span> x,tmp,p;</span><br><span class="line">	<span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%*c"</span>,&amp;m,&amp;d);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c%d%*c"</span>,&amp;ch,&amp;x);</span><br><span class="line">		<span class="keyword">if</span> (ch==<span class="string">'A'</span>) &#123;</span><br><span class="line">			tmp=(x+last)%d;</span><br><span class="line">			<span class="keyword">while</span> (t&amp;&amp;tmp&gt;=q[t<span class="number">-1</span>]) t--;</span><br><span class="line">			pos[t]=tot++;</span><br><span class="line">			q[t++]=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p=lower_bound(pos,pos+t,tot-x)-pos;</span><br><span class="line">			last=q[p];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,last);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外这题可以用线段树来做，先开好M大小的线段树，每次加节点时在后面插即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> D=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> m,lc,rc;</span><br><span class="line">&#125;node [<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	node[now].m=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;r<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		node[now].lc=t;</span><br><span class="line">		build(t++,l,mid);</span><br><span class="line">		node[now].rc=t;</span><br><span class="line">		build(t++,mid,r);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		node[now].lc=node[now].rc=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span> <span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> lr,<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lr&lt;=l&amp;&amp;r&lt;=lr+<span class="number">1</span>) &#123;</span><br><span class="line">		node[now].m=max(node[now].m,delta);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (lr&lt;mid) change(node[now].lc,l,mid,lr,delta);</span><br><span class="line">	<span class="keyword">if</span> (mid&lt;lr+<span class="number">1</span>) change(node[now].rc,mid,r,lr,delta);</span><br><span class="line">	node[now].m=max(node[node[now].lc].m,node[node[now].rc].m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> lr,<span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lr&lt;=l&amp;&amp;r&lt;=rr) &#123;</span><br><span class="line">		<span class="keyword">return</span> node[now].m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (lr&lt;mid) ans=max(ans,query(node[now].lc,l,mid,lr,rr));</span><br><span class="line">	<span class="keyword">if</span> (mid&lt;rr) ans=max(ans,query(node[now].rc,mid,r,lr,rr));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m,tot=<span class="number">0</span>,x;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%*c"</span>,&amp;m,&amp;D);</span><br><span class="line">	<span class="keyword">int</span> root=t++;</span><br><span class="line">	build(root,<span class="number">0</span>,m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c%d%*c"</span>,&amp;ch,&amp;x);</span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">'A'</span>) &#123;</span><br><span class="line">            tmp=((<span class="keyword">long</span> <span class="keyword">long</span>)last+x)%D;</span><br><span class="line">            change(root,<span class="number">0</span>,m+<span class="number">1</span>,tot,tmp);</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,last=query(root,<span class="number">0</span>,m+<span class="number">1</span>,tot-x,tot));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>单调栈</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Andrew Ng序列模型 笔记</title>
    <url>/archives/898.html</url>
    <content><![CDATA[<h1 id="Andrew-Ng序列模型-笔记（更新中）"><a href="#Andrew-Ng序列模型-笔记（更新中）" class="headerlink" title="Andrew Ng序列模型 笔记（更新中）"></a>Andrew Ng序列模型 笔记（更新中）</h1><p>笔记课程来源：<a href="https://mooc.study.163.com/learn/2001280005" rel="external nofollow noopener noreferrer" target="_blank">https://mooc.study.163.com/learn/2001280005</a></p>
<h2 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h2><ol>
<li>语音识别</li>
<li>音乐生成</li>
<li>情感分类</li>
<li>DNA序列分析</li>
<li>机器翻译</li>
<li>视频活动识别</li>
<li>命名实体识别</li>
</ol>
<p><img src="/images/1. 循环序列模型.assets/image-20200802184812691.png" alt="image-20200802184812691"></p>
<a id="more"></a>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><p>对于每个例子，采用$x^{&lt;i>}$来表示例子的第$i$个单词，采用$y^{&lt;i>}$来表示第$i$个单词的标签，具体如下：</p>
<table>
<thead>
<tr>
<th>x</th>
<th>Harry</th>
<th>Potter</th>
<th>and</th>
<th>Hermione</th>
<th>Graner</th>
<th>invented</th>
<th>a</th>
<th>new</th>
<th>spell</th>
</tr>
</thead>
<tbody>
<tr>
<td>Element</td>
<td>$x^{&lt;1>}$</td>
<td>$x^{&lt;2>}$</td>
<td>$x^{&lt;3>}$</td>
<td>$x^{&lt;4>}$</td>
<td>$x^{&lt;5>}$</td>
<td>$x^{&lt;6>}$</td>
<td>$x^{&lt;7>}$</td>
<td>$x^{&lt;8>}$</td>
<td>$x^{&lt;9>}$</td>
</tr>
<tr>
<td>y</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>Label</td>
<td>$y^{&lt;1>}$</td>
<td>$y^{&lt;2>}$</td>
<td>$y^{&lt;3>}$</td>
<td>$y^{&lt;4>}$</td>
<td>$y^{&lt;5>}$</td>
<td>$y^{&lt;6>}$</td>
<td>$y^{&lt;7>}$</td>
<td>$y^{&lt;8>}$</td>
<td>$y^{&lt;9>}$</td>
</tr>
</tbody>
</table>
<p>采用$T_x$和$T_y$表示输入序列的元素数和输出序列的元素数，如上例中$T_x=9, T_y=9$。在上例中$T_x=T_y$，但要注意在有的序列模型中这是不成立的</p>
<p>对于不同实例的表示，用$x^{(i)}$（注意这里是圆括号，上面采用的是尖括号）表示第$i$个例子，这样对于第$i$个实例，输入的第$t$个元素表示为$x^{(i)&lt;t>}$，输出（标签）的第$t$个元素表示为$y^{(i)&lt;t>}$；输入的元素数为$T_x^{(i)}$，输出的元素数为$T_y^{(i)}$</p>
<h3 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h3><p>Andrew Ng在这里采用了one-hot方法进行讲解</p>
<h4 id="词典与单词"><a href="#词典与单词" class="headerlink" title="词典与单词"></a>词典与单词</h4><p><strong>词典</strong>为一个$n$维向量空间，每一维表示一个单词<br><strong>单词</strong>为一个$n$为向量，每个单词由$n-1$维的$0$和$1$维的$1$表示，这个$1$代表词典中对应位置的单词</p>
<p>词典有大小限制，通常在几万之间，词典中词的选择有很多方法，其中包括选择高频词（当然要去掉停用词）</p>
<p>实际问题中可能出现不在词典中的词，一种做法是采用一个特殊的标记（token）来表示这类单词（如UNK, Unknown Word）</p>
<h2 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><h3 id="一种简单的思路"><a href="#一种简单的思路" class="headerlink" title="一种简单的思路"></a>一种简单的思路</h3><p>对于序列问题，一种Naive的做法是直接采用一个标准的神经网络：</p>
<p><img src="/images/1. 循环序列模型.assets/image-20200802193236668.png" alt="image-20200802193236668"></p>
<p>但这个模型有两个主要问题：</p>
<ol>
<li>输入输出在不同的例子中有不同的长度 就算是每个句子有最长长度，采用了pad或zero pad方法进行填充，也仍不是好的表示方法</li>
<li>句子中的不同位置不能共享学到的特征（Don’t share features learned across different positions of text） 这会导致巨大的参数量（类似于全连接神经网络对比CNN，后者的一大特点是可以共享特征，减小了参数量，同时有助于泛化，比如在图片中一个学到的物体换一个位置还能识别出来）</li>
</ol>
<h3 id="循环神经网络（Recurrent-Neural-Network）"><a href="#循环神经网络（Recurrent-Neural-Network）" class="headerlink" title="循环神经网络（Recurrent Neural Network）"></a>循环神经网络（Recurrent Neural Network）</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="/images/1. 循环序列模型.assets/image-20200802194724987.png" alt="image-20200802194724987"></p>
<p>循环神经网络是分状态共享参数的，如上图是展开的循环神经网络，每个矩形代表不同时刻下的模型，模型从左向右扫描，每个状态读入一个符号输入$x^{&lt;i>}$和从上个状态传来的激活值$a^{&lt;i>}$，输出这个状态的预测值$\hat{y}^{&lt;1>}$，并传递一个激活值$a^{&lt;i+1>}$给下一个状态</p>
<p>对于循环网络的开头$a^{&lt;0>}$，需要自行选择一个值作为零时刻的伪激活值，如随机值或0</p>
<p><img src="/images/1. 循环序列模型.assets/image-20200802195415641.png" alt="image-20200802195415641"></p>
<p>RNN中有几套参数，输入端的$w_{ax}$，激活端的$w_{aa}$和输出端的$w_{ya}$。每个状态$i$不仅仅用到它前一个状态$i-1$的信息，还能用到它之前所有状态$i-1, i-2, \dots$的信息，这是因为信息是沿着激活值$\dots, a^{&lt;i-2>},a{i-1}$一路传过来的。但状态$i$<strong>不能用到它之后的状态$i+1, i+2, \dots$的信息</strong>，而这些信息有时候是很有用的，比如：</p>
<p>> He said, “Teddy Roosevelt was a great President”</p>
<p>在对Teddy Roosevelt做人名识别时，”was a great President”是能帮助判断的，而仅通过”He said”则很难判断Teddy是人名的一部分，如下面的例子：</p>
<p>> He said, “Teddy bear are on sale”</p>
<p>不能采用双向输入的问题可以采用双向循环神经网络（BRNN）来解决，在之后会提及</p>
<h4 id="Forward-Propagation"><a href="#Forward-Propagation" class="headerlink" title="Forward Propagation"></a>Forward Propagation</h4><p><img src="/images/1. 循环序列模型.assets/image-20200802201033326.png" alt="image-20200802201033326"></p>
<p>初始化零时刻的伪激活值为零向量$a^{&lt;0>}=\vec{0}$<br>接下来对于下个状态的$a$和$y$有：<br>$$<br>a^{&lt;1>}=g(W_{aa}a^{&lt;0>}+W_{ax}x^{&lt;1>}+b_a) \leftarrow \text{这里的激活函数}g\text{经常选择}tanh\text{或}ReLU\text{，相对来说}tanh\text{更常见些}<br>$$</p>
<p>$$<br>\hat{y}^{&lt;1>}=g_2(W_{ya}a^{&lt;1>}+b_y) \leftarrow \text{如果是二分类问题，那么激活函数}g\text{一般用}sigmoid\text{，如果是k分类问题，则可以用}softmax<br>$$</p>
<p>更通用的写法：</p>
<p>$$<br>a^{&lt;t>}=g(W_{aa}a^{&lt;t-1>}+W_{ax}x^{&lt;t>}+b_a)<br>$$</p>
<p>$$<br>\hat{y}^{&lt;t>}=g_2(W_{ya}a^{&lt;t>}+b_y)<br>$$</p>
<p>刚看到这里的时候我有个问题：<strong>$\hat{y}^{&lt;t>}$没有利用当前的输入$x^{&lt;t>}$的信息，而是只采用了之前状态传来的$a^{&lt;t>}$的信息，那么是不是第一个状态$\hat{y}^{&lt;1>}$的输出是与输入无关的？</strong></p>
<p>这个问题是不存在的，因为计算$\hat{y}^{&lt;t>}$所用到的$a^{&lt;t>}$就是当前轮迭代中由第一个公式算出来的，而这个公式用到了输入$x^{&lt;t>}$</p>
<h5 id="简化的公式"><a href="#简化的公式" class="headerlink" title="简化的公式"></a>简化的公式</h5><p>这里简化示例直接引用用Andrew Ng的slide：</p>
<p><img src="/images/1. 循环序列模型.assets/image-20200802204918980.png" alt="image-20200802204918980"></p>
<p>$W_{aa}$和$W_{ax}$被合并为$W_x$，$W_{ya}$被简化为$W_y$，$a^{t-1}$和$x^{t}$被vstack（垂直拼接）为一个向量。具体合并方法见图示</p>
<p>这样公式简化为：</p>
<p>$$<br>a^{&lt;t>}=g(W_a[a^{&lt;t-1>},x^{&lt;t>}]+b_a)<br>$$</p>
<p>$$<br>\hat{y}^{&lt;t>}=g_2(W_{y}a^{&lt;t>}+b_y)<br>$$</p>
<p>其中$W_a[a^{&lt;t-1>},x^{&lt;t>}]$对应：<br>$$<br>W_a[a^{&lt;t-1>},x^{&lt;t>}]=<br>\left[<br> \begin{matrix}<br>     \begin{array}{c:c}<br>        W_{aa} &amp; W_{ax}<br>    \end{array}<br>  \end{matrix}<br>\right]<br>\left[<br>  \begin{matrix}<br>    a^{&lt;t-1>} \\<br>    x^{&lt;t>}<br>  \end{matrix}<br>\right]<br>=W_{aa}a^{t-1}+W_{ax}x^{&lt;t>}<br>$$</p>
<h2 id="通过时间的反向传播"><a href="#通过时间的反向传播" class="headerlink" title="通过时间的反向传播"></a>通过时间的反向传播</h2><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><img src="/images/1. 循环序列模型.assets/image-20200802212042028.png" alt="image-20200802212042028"></p>
<p>$$<br>\mathcal{L}^{&lt;t>}(\hat{y}^{&lt;t>},y^{&lt;t>})=-y^{&lt;t>}\log\hat{y}^{&lt;t>}-(1-y^{&lt;t>})\log(1-\hat{y}^{&lt;t>})<br>$$</p>
<p>$$<br>\mathcal{L}(\hat{y},y)=\sum^{T_y}_{t=1}\mathcal{L}^{&lt;t>}(\hat{y}^{&lt;t>},y^{&lt;t>})<br>$$</p>
<p>每个状态的损失函数是一个交叉熵，这个RNN的损失函数是每个状态损失的和</p>
<p><img src="/images/1. 循环序列模型.assets/image-20200802213135277.png" alt="image-20200802213135277"></p>
<p>用反向的随机梯度下降法来更新参数，其中有一个信息的反向传递尤为重要，就是上面红圈标注的，这个反向传播算法有一个专门的名字<em>backpropagation through time</em></p>
<h2 id="不同类型的神经网络"><a href="#不同类型的神经网络" class="headerlink" title="不同类型的神经网络"></a>不同类型的神经网络</h2><p><img src="/images/1. 循环序列模型.assets/image-20200802184812691.png" alt="image-20200802184812691"></p>
<p>不用的序列模型输入和输出差异是很大的，其中不一定有$T_x=T_y$，比如音乐生成的输入为空集，情感分类的输入为序列而输出为一个分类等，机器翻译的输入语言和输出语言长度不一定相等</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="/images/1. 循环序列模型.assets/image-20200802214524237.png" alt="image-20200802214524237"></p>
<p>左图的RNN为常规的RNN，每个状态都有一个输入和输出，是<em>Many-to-many</em>的，右图的RNN为只有一个输出（这里的例子是针对情感分类任务），是<em>Many-to-one</em>的。当然其实还有<em>One-to-one</em>的，这种神经网络只有一个时间状态，就是传统意义上的神经网络</p>
<p><img src="/images/1. 循环序列模型.assets/image-20200802215430664.png" alt="image-20200802215430664"></p>
<p>上图中的左图为一个用于音乐生成的RNN，这是一个<em>One-to-many</em>的RNN，它的第一个输入为音乐的第一个音符♪或者音乐的类型，或者零向量（即表示空集），其后便只有输出没有输入</p>
<p>上图中的右图为一个用于机器翻译的RNN，它是一个<em>Many-to-many</em>的RNN，这个RNN先连续读入一段输入，再连续输出结果。这个RNN的前一段称为<strong>encoder</strong>，后一段称为<strong>decoder</strong></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>序列模型</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ1087 (互不侵犯King)[状压DP]</title>
    <url>/archives/33051.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1087" rel="external nofollow noopener noreferrer" target="_blank">https://www.lydsy.com/JudgeOnline/problem.php?id=1087</a></p>
<blockquote>
<p>状压dp经典题<br>f[i][j][k]保存第i行（包括第i行）之前放了j个国王，当前行用二进制表示后对应十进制数为k的方案数。count[k]表示k所对应的二进制中1的个数。<br>状态转移方程比较显然：f[i][j][k]=sum{f[i-1][j-count[k]][p]}；<br>其中k满足 (k&amp;(k&lt;&lt;1))==0<br>其中p满足 (p&amp;(p&lt;&lt;1))==0&amp;&amp;((p&lt;&lt;1)&amp;k)==0&amp;&amp;(p&amp;k)==0&amp;&amp;((p&gt;&gt;1)&amp;k)==0<br>引用自<a href="https://blog.csdn.net/sunshinezff/article/details/47662651" rel="external nofollow noopener noreferrer" target="_blank">sunshinezff</a></p>
</blockquote>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">ll dp[<span class="number">10</span>][<span class="number">513</span>][<span class="number">82</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">513</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">513</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=i,cc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp&amp;<span class="number">1</span>) cc++;</span><br><span class="line">            tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[i]=cc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n,K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">int</span> tot=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=K;k++) &#123; <span class="comment">//k starts from 0 instead of 1</span></span><br><span class="line">                <span class="keyword">if</span>(!(j&amp;(j&lt;&lt;<span class="number">1</span>)) &amp;&amp; cnt[j]&lt;=k) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;tot;l++)</span><br><span class="line">                        <span class="keyword">if</span>(!(j&amp;l) &amp;&amp; !(j&amp;(l&lt;&lt;<span class="number">1</span>)) &amp;&amp; !(j&amp;(l&gt;&gt;<span class="number">1</span>)) &amp;&amp; !(l&amp;(l&lt;&lt;<span class="number">1</span>)))</span><br><span class="line">                        dp[i][j][k]+=dp[i<span class="number">-1</span>][l][k-cnt[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line">        ans+=dp[n][i][K];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("%I64d",ans);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans); <span class="comment">// you cannot use %I64d in BZOJ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ1207 (打鼹鼠)[DP]</title>
    <url>/archives/9535.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1207" rel="external nofollow noopener noreferrer" target="_blank">http://www.lydsy.com/JudgeOnline/problem.php?id=1207</a></p>
<p>这题一开始考虑过用时间和坐标作为状态来着，不过没有必要，直接用地鼠的序号做状态就行了，状态转移时判断一下坐标距离是否满足条件即可。<br><!--more->
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> t[maxm], x[maxm], y[maxm];</span><br><span class="line"><span class="keyword">int</span> f[maxm];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, t+i, x+i, y+i);</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		f[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (t[i]-t[j] &gt;= <span class="built_in">std</span>::<span class="built_in">abs</span>(x[i]-x[j]) + <span class="built_in">std</span>::<span class="built_in">abs</span>(y[i]-y[j])) &#123;</span><br><span class="line">				f[i] = <span class="built_in">std</span>::max(f[i], f[j]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">std</span>::max(ans, f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
--></p>]]></content>
      <tags>
        <tag>acm</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ1562 (变换序列)[二分图匹配，匈牙利算法]</title>
    <url>/archives/52897.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1562" rel="external nofollow noopener noreferrer" target="_blank">https://www.lydsy.com/JudgeOnline/problem.php?id=1562</a></p>
<p>求出一个满足要求的T序列比较容易想，只需要从i向加上距离后对应的点连边，然后就是一个二分图匹配问题了。<br>麻烦的是要输出字典序最小的T，这里要注意两点：一是连边的时候要小的数在前，二是在跑匈牙利算法的时候一定要倒着搜。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10009</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> linker[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> used[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V[u].size();i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> v=V[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!used[v]) &#123;</span><br><span class="line">			used[v]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(linker[v]==<span class="number">-1</span> || dfs(linker[v])) &#123;</span><br><span class="line">				linker[v]=u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=n<span class="number">-1</span>;u&gt;=<span class="number">0</span>;u--) &#123; <span class="comment">//注意是倒序</span></span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="literal">false</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">		<span class="keyword">if</span>(dfs(u)) res++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	V[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> seq[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dis;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dis);</span><br><span class="line">		<span class="keyword">if</span>(dis&gt;n/<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"No Answer"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> a=i-dis;</span><br><span class="line">		<span class="keyword">while</span>(a&lt;<span class="number">0</span>) a+=n;</span><br><span class="line">		<span class="keyword">int</span> b=i+dis;</span><br><span class="line">		b%=n;</span><br><span class="line">		<span class="keyword">if</span>(a&gt;b) swap(a,b);</span><br><span class="line">		add(i,a+n);</span><br><span class="line">		<span class="keyword">if</span>(a!=b) add(i,b+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt=hungary();</span><br><span class="line">	<span class="keyword">if</span>(cnt&lt;n) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"No Answer"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;n*<span class="number">2</span>;i++) &#123;</span><br><span class="line">		seq[linker[i]]=i-n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(i&lt;n<span class="number">-1</span>?<span class="string">"%d "</span>:<span class="string">"%d"</span>,seq[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ2208 (连通数)[bitset, Floyd]</title>
    <url>/archives/43015.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2208" rel="external nofollow noopener noreferrer" target="_blank">https://www.lydsy.com/JudgeOnline/problem.php?id=2208</a></p>
<p>其实这题可以用Floyd…<br>用bitset跑Floyd传递闭包处理出每一对点之间的连通关系，然后$O(n^2)$枚举两个点之间是否连通计数即可。<br>感觉bitset常数还是比较小的。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2009</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; g[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">            g[i][i]=<span class="literal">true</span>;<span class="comment">//this is true when using floyd</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;s[j]!=<span class="string">'\0'</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'1'</span>) g[i][j]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[j][i]) g[j]|=g[i]; <span class="comment">// cant swap i and j</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            ans+=g[i].count();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>STL</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ2330 (糖果)[差分约束]</title>
    <url>/archives/49055.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2330" rel="external nofollow noopener noreferrer" target="_blank">https://www.lydsy.com/JudgeOnline/problem.php?id=2330</a></p>
<p>差分约束题，差分约束理论见<a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" rel="external nofollow noopener noreferrer" target="_blank">这篇博文</a></p>
<blockquote>
<p>如果给出的不等式有”&lt;=”也有”&gt;=”，又该如何解决呢？很明显，首先需要关注最后的问题是什么，如果需要求的是两个变量差的最大值，那么需要将所有不等式转变成”&lt;=”的形式，建图后求最短路；相反，如果需要求的是两个变量差的最小值，那么需要将所有不等式转化成”&gt;=”，建图后求最长路。<br>引用自<a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html</a></p>
</blockquote>
<p>这题还需要注意自环，因为是求最长路，某些写法的spfa可能不会让正自环无限入队，从而导致无法正确判断这类正环的情况。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100009</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; E[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line">ll d[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	V[a].push_back(b);</span><br><span class="line">	E[a].push_back(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) d[i]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">	vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	q.push(<span class="number">0</span>);</span><br><span class="line">	++cnt[<span class="number">0</span>];</span><br><span class="line">	d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> now=q.front(),v; q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V[now].size();i++) &#123;</span><br><span class="line">			v=V[now][i];</span><br><span class="line">			<span class="keyword">if</span>(d[now]+E[now][i]&gt;d[v]) &#123;</span><br><span class="line">				d[v]=d[now]+E[now][i];</span><br><span class="line">				<span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">					vis[v]=<span class="number">1</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">					++cnt[v];</span><br><span class="line">					<span class="keyword">if</span>(cnt[v] &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[now]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,a,b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) V[i].clear(),E[i].clear();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">1</span>) &#123;</span><br><span class="line">			add(a,b,<span class="number">0</span>);</span><br><span class="line">			add(b,a,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>) &#123;</span><br><span class="line">			add(a,b,<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(a==b) &#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>) &#123;</span><br><span class="line">			add(b,a,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>) &#123;</span><br><span class="line">			add(b,a,<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(a==b) &#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">5</span>) &#123;</span><br><span class="line">			add(a,b,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">bool</span> flag=spfa();</span><br><span class="line">	<span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		ans+=d[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ2565 (最长双回文串)[Manachar]</title>
    <url>/archives/17937.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2565" rel="external nofollow noopener noreferrer" target="_blank">https://www.lydsy.com/JudgeOnline/problem.php?id=2565</a></p>
<p>Manachar算法，另外维护一个l数组和一个r数组，分别代表某位置作为某回文串左边界或右边界时该回文串的最长回文半径。<br>求出l和r之后扫一遍所有的#位置，l[i]+r[i]-2的最大值即为答案。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">110009</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">char</span> Ma[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> Mp[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manachar</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">	Ma[l++]=<span class="string">'$'</span>;</span><br><span class="line">	Ma[l++]=<span class="string">'#'</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">		Ma[l++]=s[i];</span><br><span class="line">		Ma[l++]=<span class="string">'#'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Ma[l]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(Mp,<span class="number">0</span>,<span class="keyword">sizeof</span>(Mp));</span><br><span class="line">	<span class="keyword">int</span> mx=<span class="number">0</span>,id=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l;i++) &#123;</span><br><span class="line">		Mp[i]=mx&gt;i?min(Mp[<span class="number">2</span>*id-i],mx-i):<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(Ma[i+Mp[i]]==Ma[i-Mp[i]])Mp[i]++;</span><br><span class="line">		<span class="keyword">if</span>(i+Mp[i]&gt;mx) &#123;</span><br><span class="line">			mx=i+Mp[i];</span><br><span class="line">			id=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> r[MAXN*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)) &#123;</span><br><span class="line">		<span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">		Manachar(s,len);</span><br><span class="line">		<span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span>(l));</span><br><span class="line">		<span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span>(r));</span><br><span class="line">		<span class="keyword">int</span> len2=<span class="built_in">strlen</span>(Ma);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len2<span class="number">-1</span>;i++) &#123;</span><br><span class="line">			l[i-Mp[i]+<span class="number">1</span>]=Mp[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len2<span class="number">-1</span>;i++) &#123;</span><br><span class="line">			l[i]=max(l[i],l[i<span class="number">-1</span>]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=len2<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">			r[i+Mp[i]<span class="number">-1</span>]=Mp[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=len2<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">			r[i]=max(r[i],r[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;len2<span class="number">-1</span>;i+=<span class="number">2</span>) mx=max(l[i]+r[i],mx);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx<span class="number">-2</span>&lt;<span class="number">0</span>?<span class="number">0</span>:mx<span class="number">-2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Manachar</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ2734 (集合选数)[状压DP, 矩阵]</title>
    <url>/archives/6871.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1087" rel="external nofollow noopener noreferrer" target="_blank">https://www.lydsy.com/JudgeOnline/problem.php?id=1087</a></p>
<p>考虑到选取集合中的元素不能是乘2或乘3相邻，我们尝试构造一个矩阵：<br>$$<br>\begin{bmatrix}<br>    x &amp; 3x &amp; 9x &amp; \cdots \\<br>    2x &amp; 6x &amp; 18x &amp; \cdots \\<br>    4x &amp; 12x &amp; 36x &amp; \cdots \\<br>    \vdots &amp; \vdots &amp; \vdots &amp; \ddots \\<br>\end{bmatrix}<br>$$<br>这样只需要在矩阵中选取不相邻的元素就能满足题意了。<br>这个矩阵的长宽是log级的，因此问题转化成了类似<a href="https://www.mhlwsk.com/archives/33051.html">互不侵犯King</a>的问题。<br>$x$代入不是2或3倍数的数构造多个矩阵，结果根据乘法原理相乘就是答案了。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">1000000001</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">18</span>];</span><br><span class="line">ll dp[<span class="number">18</span>][<span class="number">2049</span>];</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="keyword">sizeof</span>(col));</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i*=<span class="number">2</span>) &#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i*<span class="number">3</span>;j&lt;=n;j*=<span class="number">3</span>) c++;</span><br><span class="line">		col[r]=<span class="number">1</span>&lt;&lt;c;</span><br><span class="line">	&#125;</span><br><span class="line">	col[<span class="number">0</span>]=<span class="number">1</span>; </span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col[i];j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!(j&amp;(j&lt;&lt;<span class="number">1</span>))) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;col[i<span class="number">-1</span>];k++) </span><br><span class="line">					<span class="keyword">if</span>(!(k&amp;(k&lt;&lt;<span class="number">1</span>)) &amp;&amp; !(j&amp;k)) </span><br><span class="line">						dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][k])%M;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;col[r];i++) </span><br><span class="line">		ans=(ans+dp[r][i])%M;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">2</span> &amp;&amp; i%<span class="number">3</span>) </span><br><span class="line">			ans=(ans*f(i))%M;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>BeautifulSoup库学习笔记</title>
    <url>/archives/52438.html</url>
    <content><![CDATA[<p>笔记主要参考：Python网络爬虫与信息提取</p>
<h1 id="bs4库的基本元素"><a href="#bs4库的基本元素" class="headerlink" title="bs4库的基本元素"></a>bs4库的基本元素</h1><table>
<thead>
<tr>
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tag</td>
<td>标签</td>
</tr>
<tr>
<td>Name</td>
<td>标签名 .name</td>
</tr>
<tr>
<td>Attributes</td>
<td>属性 .attrs 返回值为字典类型</td>
</tr>
<tr>
<td>NavigableString</td>
<td>字符串 .string</td>
</tr>
<tr>
<td>Comment</td>
<td>注释 .comment</td>
</tr>
</tbody>
</table>
<h1 id="标签树的遍历"><a href="#标签树的遍历" class="headerlink" title="标签树的遍历"></a>标签树的遍历</h1><h2 id="向上遍历"><a href="#向上遍历" class="headerlink" title="向上遍历"></a>向上遍历</h2><ul>
<li><code>.parent &lt; Tag &gt;</code></li>
<li><code>.parents &lt; Generator &gt;</code><h2 id="向下遍历"><a href="#向下遍历" class="headerlink" title="向下遍历"></a>向下遍历</h2></li>
<li><code>.contents &lt; list &gt;</code> 只会列出下一层孩子节点</li>
<li><code>.children &lt; list_Iterator &gt;</code>用于for循环遍历，<strong>只会遍历下一层孩子节点</strong></li>
<li><code>.descendants &lt; Generator &gt;</code>用于for循环遍历，<strong>会递归遍历子树所有孩子节点</strong><h2 id="平行遍历（遍历同一颗子树中的兄弟节点，兄弟节点可以是标签也可以是独立的字符串，包括换行符）"><a href="#平行遍历（遍历同一颗子树中的兄弟节点，兄弟节点可以是标签也可以是独立的字符串，包括换行符）" class="headerlink" title="平行遍历（遍历同一颗子树中的兄弟节点，兄弟节点可以是标签也可以是独立的字符串，包括换行符）"></a>平行遍历（遍历同一颗子树中的兄弟节点，兄弟节点可以是标签也可以是独立的字符串，包括换行符）</h2></li>
<li><code>.next_sibling &lt; Tag &gt;</code></li>
<li><code>.previous_sibling</code></li>
<li><code>.next_siblings &lt; Generator &gt;</code></li>
<li><code>.previous_siblings</code></li>
</ul>
<h1 id="信息的标记"><a href="#信息的标记" class="headerlink" title="信息的标记"></a>信息的标记</h1><ul>
<li>XML是一种标签标记语言<ul>
<li>标签 &lt; name &gt; … &lt; /name &gt; 或 &lt; name / &gt;</li>
<li>注释 &lt; !– Comments – &gt;</li>
</ul>
</li>
<li><p>JSON是一种用有类型的键值对表达信息的方式（如ss的配置文件）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"key" : "value"</span><br><span class="line">"key" : ["value1", "value2"]</span><br><span class="line">"key" : &#123; "subkey" : "subvalue"  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>YAML是一种用无类型键值对表达信息的形式（如hexo的_config.yml）</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key :</span> <span class="string">value</span></span><br><span class="line"><span class="attr">key :</span> <span class="comment">#comment</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value2</span></span><br><span class="line"><span class="attr">key:</span></span><br><span class="line"><span class="attr">subkey:</span> <span class="string">subvalue</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>各自特点</p>
<ul>
<li>XML Internet上的信息交互与传递（如html）</li>
<li>JSON 移动应用云端和节点的信息通信，无注释 （如ss的配置文件，它可以作为程序的一部分执行）</li>
<li>YAML 各类系统的配置文件，有注释易读（如hexo）</li>
</ul>
</li>
</ul>
<h1 id="信息的搜索与提取"><a href="#信息的搜索与提取" class="headerlink" title="信息的搜索与提取"></a>信息的搜索与提取</h1><ul>
<li><code>&lt;&gt;.get()</code> 获取某个Tag下某项属性的值</li>
<li><code>&lt;&gt;.find_all(name, attrs, recursive, string, \*\*kwargs)</code></li>
<li>name 标签名，如果要搜索多个名字可以用列表类型，如[‘a’, ‘b’]</li>
<li>attrs 属性值（可以是部分属性，<strong>注意是用字典类型表示</strong>）</li>
<li>recursive 是否递归搜索，默认为True</li>
<li>string 搜索NavigableString，可以配合正则表达式使用</li>
<li>**kwargs 允许像<code>id = &#39;link1&#39;</code>这样直接搜索属性</li>
<li>允许这样用：<code>&lt;&gt;.find_all(&#39;p&#39;, string = &#39;Python Course&#39;)</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;&gt;.find_all()等价于&lt;&gt;()</span><br><span class="line">&lt;&gt;.find()搜索且只返回一个结果</span><br><span class="line">&lt;&gt;.find_parents() &lt; list &gt;</span><br><span class="line">&lt;&gt;.find_parent() &lt; Tag &gt;</span><br><span class="line">&lt;&gt;.find_next_sibling()</span><br><span class="line">&lt;&gt;.find_next_siblings()</span><br><span class="line">&lt;&gt;.find_previous_sibling()</span><br><span class="line">&lt;&gt;.find_previous_siblings()</span><br><span class="line">&lt;&gt;.find_next() 搜索HTML文本中下个位置出现的结果</span><br><span class="line">&lt;&gt;.find_all_next()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++转Python学习笔记</title>
    <url>/archives/44330.html</url>
    <content><![CDATA[<p>果然Python和C/C++系的语法差别很大。。在学了C/C++之后再学Python，有种当初从Pascal转C++的既视感，相比之下C/C++转Java感觉就简单多了。<br>这里记录一下学习Python的笔记，其中标注了部分Python与C/C++明显差别的用法。<br>其中大部分Python语法解释来源于<a href="https://www.icourse163.org/learn/BIT-268001" rel="external nofollow noopener noreferrer" target="_blank">Python语言程序设计</a><br><a id="more"></a></p>
<h1 id="几个细节上的差别"><a href="#几个细节上的差别" class="headerlink" title="几个细节上的差别"></a>几个细节上的差别</h1><ul>
<li>单行注释以#开头，多行注释以’’’开头和结尾 </li>
<li>Python的变量必须要赋值，换言之，通过赋值创建变量</li>
<li>Python的变量名可以是中文 </li>
<li>Python变量名大小写敏感 </li>
<li>Python中有同步赋值 如交换： <code>x, y = y, x</code></li>
<li>引用库的两种方法</li>
</ul>
<table>
<thead>
<tr>
<th>库调用方式</th>
<th>函数调用方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>import foo</td>
<td>foo.test()</td>
</tr>
<tr>
<td>from foo import test / from foo import *</td>
<td>test()</td>
</tr>
</tbody>
</table>
<h1 id="常见语句"><a href="#常见语句" class="headerlink" title="常见语句"></a>常见语句</h1><h2 id="条件与循环语句"><a href="#条件与循环语句" class="headerlink" title="条件与循环语句"></a>条件与循环语句</h2><ul>
<li><p>if语句可以嵌套 <code>if &lt; expr &gt;: elif &lt; expr &gt;: elif &lt; expr &gt;: else:</code></p>
</li>
<li><p>循环控制语句 </p>
<ul>
<li>for循环 <code>for i in range(n):</code></li>
</ul>
</li>
<li>注意for可以和else:配对，else后的语句在for语句执行结束（没有被break打断）后执行 </li>
<li>有<code>break</code>, <code>continue</code>语句，用法同C</li>
<li>有些句子允许写到一行，如<code>if x &gt;= 0: break</code></li>
<li>Python有while循环但<strong>没有do-while循环</strong></li>
</ul>
<h2 id="错误处理语句"><a href="#错误处理语句" class="headerlink" title="错误处理语句"></a>错误处理语句</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>: </span><br><span class="line">	&lt; 语句 &gt; </span><br><span class="line">	<span class="keyword">except</span> &lt; 错误代码一 &gt;: </span><br><span class="line">		&lt; 处理异常<span class="number">1</span>语句 &gt; </span><br><span class="line">	<span class="keyword">except</span> &lt; 错误代码二 &gt;: </span><br><span class="line">		&lt; 处理异常<span class="number">2</span>语句 &gt; </span><br><span class="line">	<span class="keyword">except</span>: </span><br><span class="line">		&lt; 处理其它异常语句 &gt; </span><br><span class="line">	<span class="keyword">else</span>: </span><br><span class="line">		&lt; 无异常时执行的语句 &gt; </span><br><span class="line">	<span class="keyword">finally</span>: </span><br><span class="line">		&lt; 无论有没有异常都要最后执行的语句 &gt;</span><br></pre></td></tr></table></figure>
<h2 id="其它常见语句"><a href="#其它常见语句" class="headerlink" title="其它常见语句"></a>其它常见语句</h2><h3 id="max函数"><a href="#max函数" class="headerlink" title="max函数"></a>max函数</h3><ul>
<li>max函数可以从多个（不限于两个）值中找出最大值，也可以直接找出tuple中的最大元素 </li>
</ul>
<h3 id="占位语句"><a href="#占位语句" class="headerlink" title="占位语句"></a>占位语句</h3><ul>
<li><code>pass</code>不做任何任务，只是用来占地方打标记的，往往用于自上而下的程序设计，之后一般会在pass语句的位置补全应有代码 </li>
</ul>
<h3 id="with-as语句"><a href="#with-as语句" class="headerlink" title="with-as语句"></a>with-as语句</h3><p><strong><code>with [语句1] as [变量名]:</code></strong></p>
<ul>
<li>with-as语句块适用于对资源j进行访问的场合，能够确保不管过程是否出现异常都能自动调用清理工作，如<code>f.close()</code><br>用法举例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f: </span><br><span class="line">	f.write(r.content)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong><code>def &lt; 函数名 &gt;(函数参数1, 函数参数2):</code></strong></p>
<ul>
<li>Python中的函数不需要定义返回类型，却可以返回任何类型，也可以返回多个值（类型为元组，可以用同时赋值的方法赋值给多个变量 如<code>a, b = main(1, 2)</code>） </li>
<li>可以直接写<code>return</code>或者写<code>return None</code></li>
<li><strong>Python中没有引用</strong>，也就是函数参数只有值形参，但对于列表类型，传递的是列表的地址，<strong>在函数中尝试改变列表元素将会影响原列表</strong></li>
</ul>
<h1 id="常用的数据类型"><a href="#常用的数据类型" class="headerlink" title="常用的数据类型"></a>常用的数据类型</h1><h2 id="基础数据类型及运算符"><a href="#基础数据类型及运算符" class="headerlink" title="基础数据类型及运算符"></a>基础数据类型及运算符</h2><ul>
<li>Python中的整数表示法 <ul>
<li>十进制<code>999 -999</code> </li>
<li>二进制<code>0B101 0b101 –0b101</code></li>
<li>八进制<code>0O 0o</code> </li>
<li>十六进制<code>0x 0X</code> </li>
</ul>
</li>
<li>类型转换<code>int()</code> <code>float()</code> <code>complex()</code>复数 </li>
<li>判断类型<code>type()</code> </li>
<li>判断类型是否相等<code>isinstance(&lt; type1 &gt;, &lt; type2 &gt;)</code> </li>
<li>几个特殊的运算符 <code>x//y</code>整除（但是支持浮点数） <code>x%y</code>取模（同样支持浮点数） <code>x\*\*y</code>或<code>pow(x,y)</code>求方（支持浮点数） <code>abs(x)</code>（支持浮点数） <code>divmod(x,y)</code>即(<code>x//y</code>,<code>x%y</code>)（这是个tuple类型） </li>
<li>用==判断值是否相等，用 is 和 is not 判断是否为同一个对象（地址是否相同，注：Python中许多情况下值相同则地址相同），如<code>a = [] b = []</code>则<code>a == b</code>为True，而<code>a is b</code>为False </li>
<li>Python中没有++但是有+= </li>
<li>布尔表达式 and or not 优先级not &gt; and &gt; or </li>
<li><p>非零整数和浮点数都会被认为是True，零则会被认为是False，<strong>非空字符串会被认为是真，空字符串会被认为是假</strong>，可以这么用： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans = input(<span class="string">"Which flavor do you want? [vanilla]"</span>) </span><br><span class="line">flavor = ans <span class="keyword">or</span> <span class="string">'vanilla'</span></span><br></pre></td></tr></table></figure>
<p>  或者<code>ans = input(&quot;Which flavor do you want? [vanilla]&quot;) or &#39;&#39;</code></p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="表示与运算符"><a href="#表示与运算符" class="headerlink" title="表示与运算符"></a>表示与运算符</h3><ul>
<li>字符串以<strong>单引号或</strong>双引号表示 </li>
<li>假设字符串长度为L，则字符串最后一位的下标为L-1或-1，可以拓展为-n为倒数第n位 </li>
<li>字符串子串可以用s[a:b]来表示[a,b) 如<code>exam[0:-1]</code>， 0可以省略</li>
<li>字符串运算符 +合并字符串 *重复字符串  如3*“sudo”或”sudo”*3 就是<code>&quot;sudosudosudo&quot;</code></li>
</ul>
<h3 id="字符串外部函数"><a href="#字符串外部函数" class="headerlink" title="字符串外部函数"></a>字符串外部函数</h3><ul>
<li>计算字符串长度 <code>len()</code> </li>
<li>强转成字符串 <code>str()</code> </li>
<li>单个字符转ascii码 <code>ord()</code> </li>
<li>ascii码转单个字符 <code>chr()</code> </li>
</ul>
<h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><ul>
<li>遍历下标 <code>for i in range(len(lt)):</code>  注意：不要忘了<code>range()</code>，<strong>不能通过[]索引来改变单个字符</strong></li>
<li><code>for &lt; var &gt; in &lt; string &gt;:</code> <strong>注意：对&lt; var &gt;的操作不会影响到原字符串</strong></li>
</ul>
<h3 id="字符串类型成员函数"><a href="#字符串类型成员函数" class="headerlink" title="字符串类型成员函数"></a>字符串类型成员函数</h3><table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; string &gt;.upper()</td>
<td>转大写 </td>
</tr>
<tr>
<td>&lt; string &gt;.lower()</td>
<td>转小写 </td>
</tr>
<tr>
<td>&lt; string &gt;.capitalize()</td>
<td>首字母大写 </td>
</tr>
<tr>
<td>&lt; string &gt;.strip()</td>
<td>去掉字符串两边的空格<strong>或</strong>去掉两边的指定字符（或子串） </td>
</tr>
<tr>
<td>&lt; string &gt;.split()</td>
<td>根据给定子串分割字符串（类型为list，如果参数缺省则根据白空格进行分割） </td>
</tr>
<tr>
<td>&lt; string &gt;.isdigit()</td>
<td>判断是不是全是数字 </td>
</tr>
<tr>
<td>&lt; string &gt;.find()</td>
<td>返回给定子串出现的位置（子串第一个字母的位置）如果没找到返回-1 </td>
</tr>
<tr>
<td>&lt; string &gt;.replace(str1, str2, max)</td>
<td>字符串替换，把str1替换为str2，max为最多替换次数，可以省略 </td>
</tr>
<tr>
<td>&lt; string1 &gt;.join(&lt; string2 &gt;)</td>
<td>返回一个字符串，将string1作为string2每个字符的分隔符 </td>
</tr>
<tr>
<td>&lt; string &gt;.join(&lt; list &gt;)</td>
<td>将list合并为一个字符串，用&lt; string &gt;中的内容分隔list的不同元素 </td>
</tr>
</tbody>
</table>
<h2 id="元组类型-tuple"><a href="#元组类型-tuple" class="headerlink" title="元组类型(tuple)"></a>元组类型(tuple)</h2><ul>
<li>元组是包含多个元素的类型（元素类型可以不同），元素之间用逗号分隔 如 <code>t1 = 123, 456, &quot;hello&quot;</code></li>
<li>元组可以是空的 <code>t2 = ()</code> </li>
<li>元组包含一个元素 <code>t3 = 123,</code></li>
<li>元组外侧可以使用括号也可以不用 </li>
<li>元组的元素还可以是元组，此时作为元素的元组外侧一定有括号 </li>
<li>注意(123)表示整形而(123,)或123,表示元组 </li>
<li>tuple与tuple在某些情况是可以比较大小的，比较方式从左到右逐个元素比较 </li>
<li>可以通过索引的方式访问元组中的元素 如<code>t3[0]</code> </li>
<li>元组定义后既不能更改也不能删除 </li>
<li>可以像字符串那样索引区间 如<code>t[1:]</code> 索引第2到最后一个元素 </li>
<li>可以使用+（连接）和* （重复）进行运算 </li>
</ul>
<h2 id="列表类型-list"><a href="#列表类型-list" class="headerlink" title="列表类型(list)"></a>列表类型(list)</h2><ul>
<li>列表是有序的元素集合 <code>a = [0,1,2,3]</code></li>
<li>list与list在某些情况是可以比较大小的，比较方式从左到右逐个元素比较 </li>
<li>列表元素可以通过索引访问单个元a[0] </li>
<li>也可以取列表的一个子序列a[x,y]（注意：这时候取得的序列可以为空，可以只有一个元素，但不会是元素本身） </li>
<li>+连接两个序列 *重复序列 </li>
<li><code>len(&lt; seq &gt;)</code>序列中元素个数（这个函数也用来计算字符串长度） </li>
<li><code>for &lt; var &gt; in &lt; seq &gt;:</code> 枚举序列元素 <strong>注意：对&lt; var &gt;的操作不会影响到原序列</strong></li>
<li><code>&lt; expr &gt; in &lt; seq &gt;</code> 成员检查，判断&lt; expr &gt;是否在序列中，注意否定形式是<code>&lt; expr &gt; **not in** &lt; seq &gt;</code></li>
</ul>
<h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><table>
<thead>
<tr>
<th>成员函数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; list &gt;.append(x)</td>
<td>把元素x追加到列表的最后 </td>
</tr>
<tr>
<td>&lt; list &gt;.sort()</td>
<td>将列表元素排序 </td>
</tr>
<tr>
<td>&lt; list &gt;.reverse()</td>
<td>将列表元素反转 </td>
</tr>
<tr>
<td>&lt; list &gt;.index()</td>
<td>返回第一次出现元素x的索引值 </td>
</tr>
<tr>
<td>&lt; list &gt;.insert(i,x)</td>
<td>在i位置（的元素前）插入元素x </td>
</tr>
<tr>
<td>&lt; list &gt;.count(x)</td>
<td>返回元素x在列表中的数量 </td>
</tr>
<tr>
<td>&lt; list &gt;.remove(x)</td>
<td>删除列表中第一次出现的元素x </td>
</tr>
<tr>
<td>&lt; list &gt;.pop(i)</td>
<td><em>取出</em>列表中位置i的元素，并删除它 </td>
</tr>
</tbody>
</table>
<p>另：字符串可以通过&lt; string &gt;.split()函数拆分成列表 </p>
<h2 id="字典类型"><a href="#字典类型" class="headerlink" title="字典类型"></a>字典类型</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>字典类型类似于C++中的map </li>
<li>创建 <code>stu = {&quot;102-2012&quot;: &quot;John&quot;, &quot;103-2012&quot;: &quot;Peter&quot;}</code></li>
<li>为字典增加一项 <code>stu[&quot;202-2011&quot;] = &quot;Susan&quot;</code> </li>
<li>删除 <code>del students[&quot;102-2012&quot;]</code></li>
<li>可以通过索引的方式增加项和更改项 </li>
</ul>
<h3 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h3><ul>
<li>遍历字典的键key <ul>
<li><code>for key in dictionaryName.keys(): print(key)</code> </li>
</ul>
</li>
<li>遍历字典的值value <ul>
<li><code>for value in dictionaryName.values(): print(value)</code></li>
</ul>
</li>
<li>遍历字典的项（输出的item为tuple类型） <ul>
<li><code>for item in dictionaryName.items(): print(item)</code></li>
</ul>
</li>
<li>遍历字典的key-value <ul>
<li>输出的item, value分别为键和值对应的类型 <ul>
<li><code>for item, value in adic.items(): print(item, value)</code></li>
</ul>
</li>
<li>输出的(item, value)为tuple类型 <ul>
<li><code>for (item, value) in adic.items(): print((item, value))</code></li>
</ul>
</li>
</ul>
</li>
<li>判断一个键是否在字典中 in或者not in </li>
<li>字典的标准操作符 - &lt; &gt; &lt;= &gt;= == != != and or not </li>
<li>字典不支持拼接和重复操作 </li>
</ul>
<h3 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h3><table>
<thead>
<tr>
<th>成员函数及返回值类型</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>keys():list</td>
<td>返回一个包含字典所有key的列表（其实是&lt; dict_keys &gt;，可以用来遍历）</td>
</tr>
<tr>
<td>values():list</td>
<td>返回一个包含字典所有value的列表 （其实是&lt; dict_values &gt;）</td>
</tr>
<tr>
<td>items():list</td>
<td>返回一个包含所有项的列表（&lt; dict_items &gt; ）</td>
</tr>
<tr>
<td>clear():None</td>
<td>删除字典中所有的项目 </td>
</tr>
<tr>
<td>get(key, val):value</td>
<td>返回字典中key对应的值，如果找不到则返回val，val可以缺省，此时若找不到则返回值为None </td>
</tr>
<tr>
<td>pop(key):val</td>
<td>删除并返回字典中key对应的值 </td>
</tr>
<tr>
<td>update(&lt; dict &gt;):None</td>
<td>将两个字典合并 注意：如果&lt; dict &gt;中存在与原字典相同的键，则新键值会覆盖原键值 </td>
</tr>
</tbody>
</table>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><ul>
<li>class classname[(父类名)]:[成员函数] </li>
<li>__init__ 构造函数：初始化对象的各属性 </li>
<li>__del__ 析构函数：销毁对象 </li>
</ul>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="控制台输入输出"><a href="#控制台输入输出" class="headerlink" title="控制台输入输出"></a>控制台输入输出</h2><ul>
<li><code>input()</code>的返回值是str型，并且读不到回车 </li>
<li><code>eval()</code>可以把字符串转表达式来进行计算，经常用于处理<code>input()</code>返回的字符串</li>
<li>Python的<code>print</code>输出也可以直接用逗号分隔各个元素，输出时会自动在元素与元素之间加上空格，<strong>结尾自动加上回车</strong> 如<code>print(a, b, c)</code>，如果不想结尾自动加回车，则要这样写：<code>print(a, b, c, end = &#39;&#39;)</code></li>
</ul>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p><code>.format()</code>是字符串类型（这里的字符串是参数字符串）的一个成员函数，返回格式化处理后的字符串</p>
<h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><ul>
<li><strong><code>&lt; 模板字符串 &gt;.format(&lt; 逗号分割的参数 &gt;)</code></strong></li>
<li>&lt; 模板字符串 &gt;由槽（左右大括号{}）和普通字符组成，槽的用法类似于c中的printf </li>
<li>format中的参数从左到右标号0,1,2…槽中可以指定参数显示的位置 如{2}[0][1] </li>
<li>要显示大括号应该使用两个大括号  </li>
</ul>
<h3 id="槽中的格式控制信息"><a href="#槽中的格式控制信息" class="headerlink" title="槽中的格式控制信息"></a>槽中的格式控制信息</h3><p><strong><code>&lt; 参数序号 &gt;:&lt; 填充字符 &gt;&lt; 对齐方式 &gt;&lt; 场宽 &gt;&lt; 逗号, &gt;&lt; .精度 &gt;&lt; 类型 &gt;</code></strong><br>以上参数可以省略，但是不允许调换参数出现顺序 </p>
<ol>
<li>其中填充字符与场宽举例  “{:+&gt;20}” 其中+为填充字符，&gt;表示右对齐，&lt; 表示左对齐，^表示居中对齐 </li>
<li>加上&lt; 逗号, &gt;可以给十进制输出的整形和浮点型添加千位逗号 </li>
<li>&lt; .精度 &gt;和C中的类似 </li>
<li>&lt; 类型 &gt;可以是d, b(二进制整型), o, x, X(字母大写的十六进制整型), c(ascii码对应的字符), f, e, E(用大写E表示的浮点型), %(百分比) </li>
</ol>
<h3 id="Python格式化输出时中文对齐的问题"><a href="#Python格式化输出时中文对齐的问题" class="headerlink" title="Python格式化输出时中文对齐的问题"></a>Python格式化输出时中文对齐的问题</h3><p>一个中文字符宽度也被视作1，但场宽对齐补充空格时补充的是英文空格，因此中英文混输会导致对齐问题，一个解决方案是输出<strong>中文空格<code>chr(12288)</code></strong>，代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tplt = <span class="string">"&#123;0:&#123;3&#125;^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;"</span> </span><br><span class="line">print(tplt.format(<span class="string">"学校"</span>, <span class="string">"城市"</span>, <span class="string">"分数"</span>, chr(<span class="number">12288</span>)))</span><br></pre></td></tr></table></figure></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul>
<li>打开文件 <code>infile = open(&#39;test.txt&#39;, &#39;r&#39;)</code></li>
<li>打开模式： <ul>
<li>r只读 w只写 a附加到文件末尾 rb只读二进制文件 wb只写二进制文件 ab附加到二进制文件末尾 r+读写 </li>
<li>即使是二进制文件也可以直接读出来回车和tab（解码前），解码用<code>&lt; bytes &gt;.decode(&#39;utf-8&#39;)</code>，编码<code>&lt; str &gt;.encode(&#39;utf-8&#39;)</code> ，返回值为&lt; bytes &gt;类型 </li>
</ul>
</li>
<li>读取一行<code>infile.readline()</code> 注意：这个函数<strong>会把回车也读进返回的字符串，如果读到文件结尾则会返回空字符串</strong></li>
<li><code>infile.read()</code>读取整个文件 </li>
<li><code>infile.readlines()</code>返回值为整个文件内容的字符串，每项是以换行符为结尾的一行字符串 </li>
<li>甚至可以用for来遍历文件，一次读取一行（也会读入回车）：<code>for line in infile:</code></li>
<li>读取多行的一种做法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = infile.readline() </span><br><span class="line"><span class="keyword">while</span> line != <span class="string">''</span>: </span><br><span class="line">	<span class="keyword">for</span> xStr <span class="keyword">in</span> line.split(<span class="string">','</span>): </span><br><span class="line">		sum = sum + eval(xStr) </span><br><span class="line">		count = count + <span class="number">1</span> </span><br><span class="line">		print(eval(xStr), sum / count, sum) </span><br><span class="line">	line = infile.readline()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>outfile.write()</code> 把含有文本数据或二进制数据块的字符串写进文件中 </li>
<li><code>writelines()</code> 针对列表操作，接受一个字符串列表作为参数，将它们写入文件，并且行结束符不会被自动加入 </li>
</ul>
<h1 id="数学库与随机数库"><a href="#数学库与随机数库" class="headerlink" title="数学库与随机数库"></a>数学库与随机数库</h1><h2 id="数学库-math"><a href="#数学库-math" class="headerlink" title="数学库(math)"></a>数学库(math)</h2><ul>
<li>圆周率pi  15位小数 </li>
<li>自然常数e 15位小数 </li>
<li><code>ceil(x)</code> x向上取整 </li>
<li><code>floor(x)</code> 向下取整 </li>
<li><code>pow(x,y)</code>  </li>
<li><code>log(x)</code> 以e为底 </li>
<li><code>log10(x)</code> </li>
<li><code>sqrt(x)</code> </li>
<li><code>exp(x)</code> e的x次幂 </li>
<li><code>degrees(x)</code> 将弧度值转换成角度值 </li>
<li><code>radians(x)</code> 将角度值转换成弧度值 </li>
<li><code>sin(x)</code> x是弧度值 </li>
<li><code>cos(x)</code> x是弧度值 </li>
<li><code>asin(x)</code> arcsinx x∈[-1.0, 1.0] </li>
<li><code>acos(x)</code> arccosx x∈[-1.0, 1.0] </li>
<li><code>atan(x)</code> arctanx x∈<a href="好像是[-∞, +∞]">-1.0,1.0</a> </li>
</ul>
<h2 id="随机数库-random"><a href="#随机数库-random" class="headerlink" title="随机数库(random)"></a>随机数库(random)</h2><ul>
<li><code>seed(x)</code> 给随机数一个种子值，默认为系统时钟 </li>
<li><code>random()</code> 生成一个[0, 1.0]之间的随机小数 </li>
<li><code>uniform(a,b)</code> 生成一个a到b之间的随机小数 </li>
<li><code>randint(a,b)</code> 生成一个a到b之间的随机整数 </li>
<li><code>randrange(a,b,c)</code> 随机生成一个从a开始到b以c递增的数 </li>
<li><code>choice(&lt; list &gt;)</code> 从列表中随机返回一个元素 </li>
<li><code>shuffle(&lt; list &gt;)</code> 将列表中元素随机打乱 </li>
<li><code>sample(&lt; list &gt;,k)</code> 从指定列表随机获取k个元素 </li>
</ul>
<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ map学习笔记</title>
    <url>/archives/13754.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br>C++的map可以建立关键字到值的关系，关键字不可以重复，其元素是pair容器，first为关键字，second为值。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>map的迭代器支持++、–操作</p>
<h2 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h2><p>成员函数insert(std::pair&lt;T1,T2&gt;(key,value))<br>insert不能插入已有的元素<br>使用重载的[]插入</p>
<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p>count(key)返回元素的个数（map仅能返回0或1）<br>find(key)返回指向key的元素的迭代器，如果找不到返回指向end的迭代器<br>lower_bound(key)返回第一个大于等于key的元素的迭代器<br>upper_bound(key)返回第一个大于key的元素的迭代器</p>
<h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>at(key)取出键值为key的元素，可以用来修改value，会检查key的范围<br>使用重载的[]取值，可以用来修改value</p>
<h2 id="容量查询"><a href="#容量查询" class="headerlink" title="容量查询"></a>容量查询</h2><p>empty()检查是否为空<br>size()返回元素数量</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>erase(key)删除键值为key的元素</p>
<h2 id="输出键值"><a href="#输出键值" class="headerlink" title="输出键值"></a>输出键值</h2><p>对于某个具体元素,first输出键值，second输出值</p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ string学习笔记</title>
    <url>/archives/19441.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·</p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>使用+运算符即可</p>
<h2 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h2><p>substr(pos,n)返回pos后面n个字符组成的串<br>substr(pos)返回pos到结尾的子串</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>insert(pos,str)在pos的位置插入str<br>insert(pos,str,pos2,n)在pos的位置插入str的pos2位置后面n个字符</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>erase(pos,n)删除pos后面n个字符</p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>replace(pos,n,str)pos后面的n个字符被str替换<br>replace(pos,n,str,pos2,n2)pos后面的n个字符被str的n2位置后的n2个字符替换<br>replace(pos,n,str,n2)pos后面的n个字符被str的前n2个字符替换</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>find(str)查找str在字符串中的位置，如果出现了则返回出现的位置，否则返回结尾(std::string::npos)</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>compare(str)返回值和strcmp()类似<br>compare(pos,n,str,pos2,n2)pos位置后n个字符与str的pos2位置后n2个字符比较<br>compare(pos,n,str)pos位置后面n个字符与str比较</p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 100342 (Triatrip)[bitset]</title>
    <url>/archives/55288.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/gym/100342/attachments" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/gym/100342/attachments</a></p>
<p>题目大意：给定一张有向图，询问有多少个三元环。</p>
<blockquote>
<p>这道题数据范围只有1500,所以可以n^2，我们暴力枚举两个点，假设为A->B，然后我们预处理出有哪些点可以到A，B可以到哪些点，这样就可以得到俩集合，然后再交一下，再统计一下集合里面元素的个数就好了<br>引用自<a href="https://www.cnblogs.com/qscqesze/p/4708878.html" rel="external nofollow noopener noreferrer" target="_blank">qscqesze</a></p>
</blockquote>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1509</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; g[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"triatrip.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"triatrip.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;s[j]!=<span class="string">'\0'</span>;j++) </span><br><span class="line">			<span class="keyword">if</span>(s[j]==<span class="string">'+'</span>) g[i].<span class="built_in">set</span>(j);</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="built_in">bitset</span>&lt;maxn&gt; <span class="title">tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		tmp.reset();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(g[j].test(i)) tmp.<span class="built_in">set</span>(j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(g[i].test(j)) ans+=(tmp&amp;g[j]).count();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans/<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 101343J (Husam and the Broken Present 2)[状压DP]</title>
    <url>/archives/10840.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/gym/101343/problem/J" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/gym/101343/problem/J</a></p>
<blockquote>
<p>题意：构造一个序列包含所给的N个子序列(N≤15)，求构造序列的最短长度。<br>考虑状态压缩，有2^N种状态，设dp[i][j]表示状态为i，以第j个子序列结尾的最小长度；<br>状态转移：从以第j个子序列结尾的状态转移到以第k个子序列的状态：<br><strong>dp[i|(1 &lt;&lt; (k-1))][k] = min{dp[i][j]+a[k][0]-num[j][k]}</strong>   （其中，a[k][0]表示第k个子序列的长度，num[j][k]表示第j个子序列的后缀与第k个子序列的前缀重合部分的长度）<br>注意：<strong>先将被其他子序列包含的子序列删去……</strong><br>引用自<a href="http://www.cnblogs.com/GraceSkyer/p/8996659.html" rel="external nofollow noopener noreferrer" target="_blank">GraceSkyer</a></p>
</blockquote>
<p>感觉这题有包含的情况是个坑啊，另外需要注意的是两串相等的情况，可以把它们特判成两串不包含的情况。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">16</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">bool</span> cov[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> comm[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">32769</span>][<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=a[i][<span class="number">0</span>];j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j || a[j][<span class="number">0</span>]&gt;a[i][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+a[j][<span class="number">0</span>]<span class="number">-1</span>&lt;=a[i][<span class="number">0</span>];l++) &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=a[j][<span class="number">0</span>];k++)</span><br><span class="line">                    <span class="keyword">if</span>(a[i][l+k<span class="number">-1</span>]!=a[j][k]) &#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag &amp;&amp; !(a[i][<span class="number">0</span>]==a[j][<span class="number">0</span>] &amp;&amp; l==<span class="number">1</span>)) cov[j]=<span class="literal">true</span>; <span class="comment">//特判两串相等的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!cov[i]) pos[++tot]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) &#123; comm[i][i]=a[pos[i]][<span class="number">0</span>];<span class="keyword">continue</span>; &#125;</span><br><span class="line">            comm[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=min(a[pos[i]][<span class="number">0</span>],a[pos[j]][<span class="number">0</span>]);l++) &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=l;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[pos[i]][a[pos[i]][<span class="number">0</span>]-l+k]!=a[pos[j]][k]) &#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) comm[i][j]=l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mx=(<span class="number">1</span>&lt;&lt;tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mx;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=tot;j++)</span><br><span class="line">            dp[i][j]=inf;</span><br><span class="line">    <span class="comment">//dp[0][0]=0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)][j]=a[pos[j]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mx;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=tot;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==k) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i|(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k]=min(dp[i|(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k],dp[i][j]+a[pos[k]][<span class="number">0</span>]-comm[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        ans=min(ans,dp[mx<span class="number">-1</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 101808K (Another Shortest Path Problem)[LCA]</title>
    <url>/archives/24579.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/gym/101808/problem/K" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/gym/101808/problem/K</a></p>
<p>这题第一眼看上去是树上最短路，但麻烦的是它有n条边不是树。这张图仅有一个环，我们尝试讨论特殊情况把它转化为树上最短路来做。<br>我们忽略环强行建树，设环上的两个点为X和Y，两点之间的边权为Z，任何两个点经过数根的路径的距离为f(a,b)，那么a和b之间的最短路一定等于<strong>min{f(a,b),f(a,X)+f(b,X),f(a,Y)+f(b,Y),f(a,X)+f(b,Y)+Z,f(a,Y)+f(b,x)+Z}</strong></p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEG=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w,next;</span><br><span class="line">&#125;edge[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],tot;</span><br><span class="line"><span class="keyword">int</span> X,Y,Z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].w=w;</span><br><span class="line">    edge[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[maxn][DEG];</span><br><span class="line">ll dis[maxn];</span><br><span class="line"><span class="keyword">int</span> deg[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    X=Y=Z=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    deg[root]=<span class="number">0</span>;</span><br><span class="line">    fa[root][<span class="number">0</span>]=root;</span><br><span class="line">    dis[root]=<span class="number">0</span>;</span><br><span class="line">    que.push(root);</span><br><span class="line">    vis[root]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;DEG;i++) &#123;</span><br><span class="line">            fa[tmp][i]=fa[fa[tmp][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[tmp];i!=<span class="number">-1</span>;i=edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(v==fa[tmp][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!X) &#123;</span><br><span class="line">                    X=tmp;</span><br><span class="line">                    Y=v;</span><br><span class="line">                    Z=edge[i].w;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deg[v]=deg[tmp]+<span class="number">1</span>;</span><br><span class="line">            fa[v][<span class="number">0</span>]=tmp;</span><br><span class="line">            dis[v]=dis[tmp]+edge[i].w;</span><br><span class="line">            que.push(v);</span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deg[u]&gt;deg[v]) swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> hu=deg[u],hv=deg[v];</span><br><span class="line">    <span class="keyword">int</span> tu=u,tv=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> det=hv-hu,i=<span class="number">0</span>;det;det&gt;&gt;=<span class="number">1</span>,i++)</span><br><span class="line">        <span class="keyword">if</span>(det&amp;<span class="number">1</span>)</span><br><span class="line">            tv=fa[tv][i];</span><br><span class="line">    <span class="keyword">if</span>(tu==tv) <span class="keyword">return</span> tu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=DEG<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[tu][i]==fa[tv][i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tu=fa[tu][i];</span><br><span class="line">        tv=fa[tv][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[tu][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[x]<span class="number">-2</span>*dis[LCA(x,y)]+dis[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ll ans=f(x,y);</span><br><span class="line">    ans=min(ans,f(x,X)+f(y,X));</span><br><span class="line">    ans=min(ans,f(x,Y)+f(y,Y));</span><br><span class="line">    ans=min(ans,f(x,X)+f(y,Y)+Z);</span><br><span class="line">    ans=min(ans,f(x,Y)+f(y,X)+Z);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            addedge(u,v,w);</span><br><span class="line">            addedge(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line">        BFS(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,solve(u,v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 201A (Clear Symmetry)做题笔记</title>
    <url>/archives/21560.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong> <a href="https://cn.vjudge.net/problem/CodeForces-201A" rel="external nofollow noopener noreferrer" target="_blank">https://cn.vjudge.net/problem/CodeForces-201A</a></p>
<p>这题是找规律题，但又有点奇怪，一开始尝试按照题目要求那样枚举x找n变化的规律，但是找不到。。后来才知道这题是枚举n找x的变化规律，<strong>可以证明除了x=3的情况，只要方阵的sharpness&gt;=x，对应的n就一定满足条件</strong>（证明见下），因而只要找到能使矩阵的最大sharpness&gt;=x的最小的n就行了。<br><a id="more"></a></p>
<p>在纸上画图，能得出来n为奇数的情况优于n为偶数的情况（n为奇数时n对应矩阵的最大sharpness大于n-1对应矩阵的最大sharpness），所以只考虑n为奇数的情况，此时容易根据图推出最大sharpness的公式为(n//2)^2 * ((n//2)+1)^2</p>
<p><strong>下面证明找sharpness&gt;=x的最小n的正确性</strong>（x=3除外）：<br>证明：除了x=3的情况，逐组去掉所有的四个一组的1，有可能把sharpness控制在abs(sharpness-x)&lt;4的范围（如果不能，那么去掉所有四个一组的1），继续逐组去掉两个一组的1，一定能把sharpness控制在abs(sharpness-x)&lt;2的范围，此时如果sharpness!=1，那么去掉矩阵中心的1就行了）</p>
<p>最后贴上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,tmp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">	<span class="keyword">if</span> (x==<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"5"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;;i+=<span class="number">2</span>) &#123;</span><br><span class="line">		tmp=i&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (tmp*tmp+(tmp+<span class="number">1</span>)*(tmp+<span class="number">1</span>)&gt;=x) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 274B (Zero Tree)[树型DP]</title>
    <url>/archives/9385.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/274/B" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/274/B</a></p>
<p>题目大意：给定一颗以1为根结点的树，每个结点有一个权值，每次选择包含根结点的子树（注意：这里的子树与一般意义的子树定义不同，这里的子树是只要包含根结点的连通树就行，不一定非要包含所有孩子结点）并把这棵子树上的所有结点权值加一或减一，问至少多少次操作能让这棵树权值为零。</p>
<p>这题题意理解了半天。。</p>
<p>可以看到一个结点的孩子结点一定比它先处理完成（否则即使处理完了这个结点，在处理这个结点的孩子结点时，这个结点仍然会受到影响）。这满足无后效性原则，可以考虑树型DP。对于每个结点维护一个up值代表它至少需要被加一多少次，和一个down值代表它至少需要被减一多少次。每次状态转移时分两步：第一步up[u]=max{up[v]}, down[u]=max{down[v]}，第二步合并up[u], down[v], c[u]并将当前结点需要改变的值统计如up[u]或down[u]中。最终的结果就是up[1]+down[1]。<br>状态转移第一步的原理：每次修改孩子结点，一定是按照需要修改次数最多的叶子结点来，因为那些需要修改次数较少的节点的修改过程可以并入前者的修改过程中。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100009</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,next;</span><br><span class="line">&#125;ed[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ne=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> root=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ed[ne].v=v;ed[ne].next=head[u];head[u]=ne++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ne=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line">ll up[maxn],down[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    up[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],v;i!=<span class="number">-1</span>;i=ed[i].next) &#123;</span><br><span class="line">        v=ed[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        flag=<span class="literal">true</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        up[u]=max(up[u],up[v]);</span><br><span class="line">        down[u]=max(down[u],down[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        ll tmp=up[u]-down[u]+c[u];</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">0</span>) down[u]+=tmp;</span><br><span class="line">        <span class="keyword">else</span> up[u]+=-tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[u]&gt;<span class="number">0</span>) down[u]=c[u];</span><br><span class="line">        <span class="keyword">else</span> up[u]=-c[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v); add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,c+i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>,up[<span class="number">1</span>]+down[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>树型DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 287B (Pipeline)[二分，贪心]</title>
    <url>/archives/3317.html</url>
    <content><![CDATA[<p>题目链接：<a href="http://codeforces.com/problemset/problem/287/B" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/287/B</a></p>
<p>稍加分析，题目可以转换成这样一个问题：给定1, 2, 3, …, k-1, 问它们的部分和是否能凑出n-1，如果能最少要用多少个数。<br>一种贪心的思想是寻找一个i，使得i, i+1, …, k-1的和大于等于n-1,在这个前提下要求i最大。此时有i+1, i+2, …, k-1的和小于n-1。回想要用最少的数凑出n-1，此时i+1, i+2, …, k-1是一定要选的，对应n-1减去它们的和后所余下的差r一定小于i+1（否则不满足i最大的要求），此时从1, 2, …, i中调出一个数补上即可。<br>此时对应的所需要的分流器为i+1到k所有分流器和1到i中的某一个分流器。<br>另外需要注意的是n=1的情况，由于二分没有判断结果是否合理，因此需要特判。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">	ll sum=(mid+k<span class="number">-1</span>)*(k-mid)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> (sum&gt;=n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) &#123;<span class="built_in">printf</span>(<span class="string">"0"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	ll l=<span class="number">1</span>,r=k<span class="number">-1</span>,mid;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">		mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((l+k<span class="number">-1</span>)*(k-l)/<span class="number">2</span> &gt;= n<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%I64d"</span>,k-l);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 343A (Rational Resistance)[模拟]</title>
    <url>/archives/46159.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/343/A" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/343/A</a><br><strong>参考博客：</strong><a href="http://blog.csdn.net/baidu_19306071/article/details/48027589" rel="external nofollow noopener noreferrer" target="_blank">TofuNotHere</a></p>
<p>本来以为这题是超级麻烦的搜索的，结果这题真是在考物理啊。。</p>
<p>以下引用自TofuNotHere的博客：</p>
<blockquote>
<p>对于电阻来说将k个电阻串联和并联关系完全反转的话，阻值的变化特性是变为原阻值的倒数，因而我们可以利用这一特性不停的将并联关系转化为串联关系，而A/B可化为假分数形式n+a/B，期中整数部分由n个电阻串联，分数部分由一个并联电阻组组成，将并联化为串联关系，即将分数部分倒过来，不断反复，累加得到答案</p>
</blockquote>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a,b;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		ans+=a/b;</span><br><span class="line">		a%=b;</span><br><span class="line">		<span class="built_in">std</span>::swap(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 371C (Hamburgers) 做题笔记</title>
    <url>/archives/32661.html</url>
    <content><![CDATA[<p>题目链接：<a href="http://codeforces.com/problemset/problem/371/C" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/371/C</a></p>
<p>这题一开始用的贪心，但WA掉了。<br>正解是二分一个答案，查看能否用现有的钱买到相应的食材。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200</span>];</span><br><span class="line">LL ca, cb, cc;</span><br><span class="line">LL na, nb, nc;</span><br><span class="line">LL pa, pb, pc;</span><br><span class="line">LL r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">	LL need = <span class="number">0</span>;</span><br><span class="line">	LL cnta = x * ca - na;</span><br><span class="line">	<span class="keyword">if</span>(ca &gt; <span class="number">0</span> &amp;&amp; cnta &gt; <span class="number">0</span>) need += cnta * pa;</span><br><span class="line">	LL cntb = x * cb - nb;</span><br><span class="line">	<span class="keyword">if</span>(cb &gt; <span class="number">0</span> &amp;&amp; cntb &gt; <span class="number">0</span>) need += cntb * pb;</span><br><span class="line">	LL cntc = x * cc - nc;</span><br><span class="line">	<span class="keyword">if</span>(cc &gt; <span class="number">0</span> &amp;&amp; cntc &gt; <span class="number">0</span>) need += cntc * pc;</span><br><span class="line">	<span class="keyword">if</span>(need &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%*c"</span>, s);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; na &gt;&gt; nb &gt;&gt; nc;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; pa &gt;&gt; pb &gt;&gt; pc;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; r;</span><br><span class="line">	ca = cb = cc = <span class="number">0L</span>L;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span>(s[i]) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'B'</span>: ca++;	<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'S'</span>: cb++; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'C'</span>: cc++; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL l = <span class="number">0</span>, r = <span class="number">1100000000009L</span>L;</span><br><span class="line">	<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">		LL mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) l = mid;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; r;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 377A (Maze)[BFS]</title>
    <url>/archives/15612.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/377/A" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/377/A</a></p>
<p>这题需要逆向思维。考虑直接怎么往上放墙的策略非常麻烦。此时我们换个策略，尝试把所有的空缺都放上墙，并从这些新墙中连续拆掉一部分，那么剩下的新墙就是我们需要放的了。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,k,w=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> M[maxn][maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qy;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!qx.empty()) qx.pop();</span><br><span class="line">	<span class="keyword">while</span>(!qy.empty()) qy.pop();</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n &amp;&amp; flag;i++) </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m &amp;&amp; flag;j++) </span><br><span class="line">			<span class="keyword">if</span>(M[i][j]==<span class="string">'X'</span>) &#123;</span><br><span class="line">				M[i][j]=<span class="string">'.'</span>;</span><br><span class="line">				cnt++;</span><br><span class="line">				<span class="keyword">if</span>(cnt==n*m-w-k) <span class="keyword">return</span> ;</span><br><span class="line">				qx.push(i);</span><br><span class="line">				qy.push(j);</span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">while</span>(!qx.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> nx=qx.front(); qx.pop();</span><br><span class="line">		<span class="keyword">int</span> ny=qy.front(); qy.pop();</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			x=nx+dx[i];</span><br><span class="line">			y=ny+dy[i];</span><br><span class="line">			<span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; y&lt;=m &amp;&amp; M[x][y]==<span class="string">'X'</span>) &#123;</span><br><span class="line">				M[x][y]=<span class="string">'.'</span>;</span><br><span class="line">				cnt++;</span><br><span class="line">				qx.push(x);</span><br><span class="line">				qy.push(y);</span><br><span class="line">				<span class="keyword">if</span>(cnt==n*m-w-k) <span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%*c"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;M[i][j]);</span><br><span class="line">			<span class="keyword">if</span>(M[i][j]==<span class="string">'#'</span>) w++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(M[i][j]==<span class="string">'.'</span>) M[i][j]=<span class="string">'X'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;n) <span class="built_in">scanf</span>(<span class="string">"%*c"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c"</span>,M[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 460C (Present)[二分，贪心，线段树]</title>
    <url>/archives/56996.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/460/C" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/460/C</a></p>
<p>二分一个高度，检查时考虑这样一种贪心策略：扫描数组，如果遇到高度小于二分值的就把它和它后面连续w个数加上a[i]-mid，如果能让所有的数大于mid，则二分值是满足条件的。</p>
<p>这题直接暴力会超时，线段树会卡常数，建树时必须是O(n)的复杂度，我尝试一开始建立一颗线段树并把它保存起来，每次重新建树时直接memcpy，卡过了这道题。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100009</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,w;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">510000</span>;</span><br><span class="line"><span class="keyword">int</span> sumv[maxm];</span><br><span class="line"><span class="keyword">int</span> addv[maxm];</span><br><span class="line"><span class="keyword">int</span> sumvt[maxm];</span><br><span class="line"><span class="keyword">int</span> addvt[maxm];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lc=o*<span class="number">2</span>, rc=o*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    sumv[o]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&gt;L) &#123;</span><br><span class="line">        sumv[o]=sumv[lc]+sumv[rc];</span><br><span class="line">    &#125;</span><br><span class="line">    sumv[o]+=addv[o]*(R-L+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> y1,y2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lc=o*<span class="number">2</span>,rc=o*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y1&lt;=L &amp;&amp; y2&gt;=R) &#123;</span><br><span class="line">        addv[o]+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> M=L+(R-L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(y1&lt;=M) update(lc,L,M);</span><br><span class="line">        <span class="keyword">if</span>(y2&gt;M) update(rc,M+<span class="number">1</span>,R);</span><br><span class="line">    &#125;</span><br><span class="line">    maintain(o,L,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y1&lt;=L &amp;&amp; y2&gt;=R) &#123;</span><br><span class="line">        _sum+=sumv[o]+add*(R-L+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> M=L+(R-L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(y1&lt;=M) query(o*<span class="number">2</span>,L,M,add+addv[o]);</span><br><span class="line">        <span class="keyword">if</span>(y2&gt;M) query(o*<span class="number">2</span>+<span class="number">1</span>,M+<span class="number">1</span>,R,add+addv[o]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(sumv,sumvt,<span class="keyword">sizeof</span>(sumvt));</span><br><span class="line">    <span class="built_in">memcpy</span>(addv,addvt,<span class="keyword">sizeof</span>(addvt));</span><br><span class="line">    <span class="keyword">int</span> left = m;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> d,now;</span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; i&lt;=n) &#123;</span><br><span class="line">        _sum=<span class="number">0</span>;</span><br><span class="line">        y1=y2=i;</span><br><span class="line">        query(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">        now=_sum;</span><br><span class="line">        <span class="keyword">if</span>(now&lt;mid) &#123;</span><br><span class="line">            d=mid-now;</span><br><span class="line">            left-=d;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            y1=i,y2=min(n,i+w<span class="number">-1</span>);</span><br><span class="line">            v=d;</span><br><span class="line">            update(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    <span class="built_in">memset</span>(sumv,<span class="number">0</span>,<span class="keyword">sizeof</span>(sumv));</span><br><span class="line">    <span class="built_in">memset</span>(addv,<span class="number">0</span>,<span class="keyword">sizeof</span>(addv));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        y1=y2=i;</span><br><span class="line">        v=a[i];</span><br><span class="line">        update(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(sumvt,sumv,<span class="keyword">sizeof</span>(sumv));</span><br><span class="line">    <span class="built_in">memcpy</span>(addvt,addv,<span class="keyword">sizeof</span>(addv));</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">1001000000</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>线段数</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 540D (Bad Luck Island)[概率DP]</title>
    <url>/archives/42973.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/540/D" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/540/D</a></p>
<p>概率DP，<code>dp[i][j][k]</code>表示还剩i个石头，j个剪刀，k个布的概率。</p>
<p>以石头减少为例，<code>dp[i][j][k]</code>转移到<code>dp[i-1][j][k]</code>的概率为<code>i*k/(i*j+j*k+i*k)</code><br>这样就有<code>dp[i-1][j][k]+=dp[i][j][k]*(1.0*i*k)/(i*j+j*k+i*k)</code></p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">109</span>;</span><br><span class="line"><span class="keyword">double</span> dp[maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r,s,p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;r,&amp;s,&amp;p);</span><br><span class="line">    dp[r][s][p]=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=s;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=p;k&gt;=<span class="number">1</span>;k--) &#123;</span><br><span class="line">        dp[i<span class="number">-1</span>][j][k]+=dp[i][j][k]*(<span class="number">1.0</span>*i*k)/(i*j+j*k+i*k);</span><br><span class="line">        dp[i][j<span class="number">-1</span>][k]+=dp[i][j][k]*(<span class="number">1.0</span>*i*j)/(i*j+j*k+i*k);</span><br><span class="line">        dp[i][j][k<span class="number">-1</span>]+=dp[i][j][k]*(<span class="number">1.0</span>*j*k)/(i*j+j*k+i*k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans1=<span class="number">0.0</span>,ans2=<span class="number">0.0</span>,ans3=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j++) &#123;</span><br><span class="line">            ans1 += dp[i][j][<span class="number">0</span>];</span><br><span class="line">            ans2 += dp[<span class="number">0</span>][i][j];</span><br><span class="line">            ans3 += dp[j][<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10f %.10f %.10f"</span>,ans1,ans2,ans3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>概率DP</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 578C (Weakness and Poorness)[三分]</title>
    <url>/archives/45786.html</url>
    <content><![CDATA[<p>题目链接：<a href="http://codeforces.com/problemset/problem/578/C" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/578/C</a></p>
<p>可以看出weakness-x是一个单峰函数，可以使用三分。<br>然后就是求区间最大子段和。简化问题这里假设只求正最大子段和，dp[i-1]转移到b[i]时，不论b[i]是正是负，若dp[i-1]是正则一定会对它产生“正面影响”，此时dp[i]=dp[i-1]+b[i]；若dp[i-1]是负则一定会对b[i]产生“负面影响”，此时应该扔掉dp[i-1]，dp[i]=b[i]。<br>题目要求求出正负最大子段和，这里只需要对b[i]求一遍正最大子段和，再把b[i]取反，再求一遍最大子段和即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS=<span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">double</span> b[maxn];</span><br><span class="line"><span class="keyword">double</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		b[i]=a[i]-mid;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>) dp[i]=dp[i<span class="number">-1</span>]+b[i];</span><br><span class="line">		<span class="keyword">else</span> dp[i]=b[i];</span><br><span class="line">		ans=max(ans,<span class="built_in">fabs</span>(dp[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		b[i]=mid-a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>) dp[i]=dp[i<span class="number">-1</span>]+b[i];</span><br><span class="line">		<span class="keyword">else</span> dp[i]=b[i];</span><br><span class="line">		ans=max(ans,<span class="built_in">fabs</span>(dp[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> l=<span class="number">-10001</span>,r=<span class="number">10001</span>;</span><br><span class="line">	<span class="keyword">double</span> m,mm,ma,mma;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;<span class="comment">//(fabs(r-l)&gt;=1e-10) &#123;</span></span><br><span class="line">		m=(<span class="number">2</span>*l+r)/<span class="number">3</span>;</span><br><span class="line">		mm=(l+<span class="number">2</span>*r)/<span class="number">3</span>;</span><br><span class="line">		ma=f(m);</span><br><span class="line">		mma=f(mm);</span><br><span class="line">		<span class="keyword">if</span>(ma&lt;mma) r=mm;</span><br><span class="line">		<span class="keyword">else</span> l=m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.15lf"</span>,f(l));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 591B (K - Rebranding)做题笔记</title>
    <url>/archives/56479.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="https://cn.vjudge.net/problem/CodeForces-591B" rel="external nofollow noopener noreferrer" target="_blank">https://cn.vjudge.net/problem/CodeForces-591B</a></p>
<p>模拟题</p>
<p>这题如果直接去字符串里面修改的话会超时，所以这里借鉴了字符串指针排序的思路，首先建立一个26*200 000的int数组，记录26个字母所在字符串中的位置，然后建立一个指针数组（索引）指向这个int数组的第一维，交换两个字母时，直接交换对应指针数组元素的值就行了。<br><a id="more"></a></p>
<p>贴上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200009</span>];</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">26</span>][<span class="number">200009</span>];</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> *pt[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch=getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isalpha</span>(ch)) ch=getchar();</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len,m;</span><br><span class="line">	<span class="keyword">char</span> c,c1,c2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) p[i]=pos[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) pt[i]=t+i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%*c"</span>,&amp;len,&amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c);</span><br><span class="line">		pos[c-<span class="string">'a'</span>][t[c-<span class="string">'a'</span>]++]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">		c1=get();</span><br><span class="line">		c2=get();</span><br><span class="line">		swap(p[c1-<span class="string">'a'</span>],p[c2-<span class="string">'a'</span>]);</span><br><span class="line">		swap(pt[c1-<span class="string">'a'</span>],pt[c2-<span class="string">'a'</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(*pt[i]);j++) </span><br><span class="line">			str[p[i][j]]=i+<span class="string">'a'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	str[len]=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>模拟</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 603C (Lieges of Legendre)[公平组合博弈，SG函数]</title>
    <url>/archives/15576.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/603/C" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/603/C</a></p>
<p>这题是公平组合博弈。对于给定的每堆奶牛，有两种操作，一是减少一只奶牛，二是将奶牛减半并变成k堆。其实第二种操作就相当于游戏分成了许多子游戏，子游戏的SG异或和仍然对应游戏的SG值。<br>这题最关键的思路是要想到k分奇偶讨论，然后打表找一下规律。</p>
<blockquote>
<p>如果k是偶数</p>
</blockquote>
<blockquote>
<p>当选择2时，有k个n个石子的小堆，状态的sg函数显然为f(n) xor自身 k次=0。<br>此时我们可以计算得出f(0..4)={0,1,2,0,1}，并且可证明对于n&gt;=2，有f(2n-1)=0，f(2n)=1，化简得f(n)=1-(n%2)，或f(n)=n&amp;1^1。<br>对于f(2n-1)，我们只能移动到2n-2个石子的状态（游戏1），又f(2n-2)=1&gt;0，所以f(2n-1)=mex{1}=0。<br>对于f(2n)，可以移动到2n-1的状态（游戏1），或者游戏2，游戏1和2的sg函数值都为0，所以f(2n)=mex{0}=1。</p>
</blockquote>
<blockquote>
<p>如果k是奇数</p>
</blockquote>
<blockquote>
<p>此时对于2n个石子的石堆，状态的sg函数为f(n)xor自身k次=f(n)。推导出f(0..5)={0,1,0,1,2,0}。可证明对于n&gt;=2，f(2n)&gt;0，f(2n+1)=0。<br>对于f(2n+1)，我们只能移动到2n，有f(2n)&gt;0，所以f(2n+1)=0。<br>对于f(2n)，可以移动到2n-1，f(2n-1)=0，所以f(2n)&gt;0。且f(2n)=mex{f(2n-1),f(n)}=mex{0,f(n)}，递归计算即可。<br>引用自<a href="https://blog.csdn.net/riba2534/article/details/78483562" rel="external nofollow noopener noreferrer" target="_blank">huanghongxun的博客</a></p>
</blockquote>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> tabe[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> tabo[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">5</span>) <span class="keyword">return</span> tabe[x];</span><br><span class="line">	<span class="keyword">return</span> x&amp;<span class="number">1</span>^<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsgo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">6</span>) <span class="keyword">return</span> tabo[x];</span><br><span class="line">	<span class="keyword">if</span>(x&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> getsgo(x/<span class="number">2</span>)==<span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k,x;</span><br><span class="line">	<span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">if</span>(k&amp;<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">			tmp^=getsgo(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">			tmp^=getsge(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(tmp?<span class="string">"Kevin"</span>:<span class="string">"Nicky"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>博弈论</tag>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 687B (Remainders Game)[中国剩余定理]</title>
    <url>/archives/52188.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/687/B" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/687/B</a></p>
<p>这题是中国剩余定理解的性质。令M=lcm(c1,c2,…,cn)，则对x mod ci=ri用中国剩余定理求得的解在模M意义下是同余的，也即求得的解加上p*M可以得到通解。因而判断M%k==0是否成立，如果成立则x mod k的值是唯一的。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000009</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL tmp=<span class="number">1</span>;</span><br><span class="line">    LL lcm=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;tmp);</span><br><span class="line">        LL d=gcd(lcm,tmp);</span><br><span class="line">        lcm=lcm*tmp/d;</span><br><span class="line">        lcm%=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(lcm==<span class="number">0</span>?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 768E(Game of Stones)[公平组合博弈，打表]</title>
    <url>/archives/19536.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/768/E" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/768/E</a></p>
<blockquote>
<p>仍然枚举前几个sg[x]，找规律<br>sg[0] = 0、sg[1] = 1;<br>sg[2] = mex{sg[0], sg[1]’} = mex{0,0} = 1;<br>——      这里的sg[1]’表示已经取了一个石子还剩一个石子的状态，很显然不能取！sg[1]’==0<br>sg[3] = mex{sg[0], sg[1]’, sg[2]’} = mex{0,1,1} = 2;<br>——      同上，很好证明sg[2]’==1，sg[1]’==1，不过注意这里的sg[1]’表示已经取了两个石子还剩一个石子的状态，很显然是可以取的，这和上面的sg[1]’不一样，这里sg[1]’==1<br>sg[4] = mex{sg[0], sg[1]’, sg[2]’, sg[3]’} = mex{0,1,1,mex{0,sg[1]’}} = 2<br>——      很显然这里的sg[1]’表示已经取过一个石子也取过两个石子还剩一个石子的状态，很显然不能取，sg[1]’==0<br>……<br>最后可得出sg[x] = {0,1,1,2,2,2,3,3,3,3,4,4,4,4,4,5,5,5,5,5,5……}中秩为x的元素<br>引用自<a href="https://blog.csdn.net/Jaihk662/article/details/56484066" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/Jaihk662/article/details/56484066</a></p>
</blockquote>
<p>这里复习了下每个结点的SG值是只由它的后继决定的。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> sg[<span class="number">70</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">62</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">62</span>&amp;&amp;i&lt;=<span class="number">62</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=j&amp;&amp;i&lt;=<span class="number">62</span>;k++)</span><br><span class="line">            sg[i++]=j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>,x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        tmp^=sg[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(tmp?<span class="string">"NO"</span>:<span class="string">"YES"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>博弈论</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 798D (Mike and distribution)做题笔记</title>
    <url>/archives/62846.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/798/D" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/798/D</a></p>
<p>一开始想写个这样的贪心：大家同时开始做，多余的人向前走，做完的人向前补，不过这个贪心好像不太对。。</p>
<p>后来知道这题是二分答案，思路换了一下，既然在二分答案的条件下，每个人时间是给定的，就无所谓谁先做了，<strong>一个一个派出去</strong>，看看能不能在给定时间搬完就行了。<br><a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> box[<span class="number">100009</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">100009</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> tail;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t=time;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(tmp,box,<span class="keyword">sizeof</span>(box));</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">		t=time;</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (;j&lt;n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">				t-=j+<span class="number">1</span>;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> t--;</span><br><span class="line">			<span class="keyword">if</span> (t&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (t&lt;=tmp[j]) &#123;</span><br><span class="line">				tmp[j]-=t;</span><br><span class="line">				t=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (j==tail&amp;&amp;tmp[tail]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				t-=tmp[j];</span><br><span class="line">				tmp[j]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (j==tail&amp;&amp;tmp[tail]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>,r=<span class="number">110000000000000L</span>L;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> mid=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;box[i]);</span><br><span class="line">		<span class="keyword">if</span> (box[i]) tail=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (check(mid)) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 934E (Colourful Prospect)[计算几何，欧拉定理]</title>
    <url>/archives/37698.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/934/E" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/934/E</a></p>
<p>题目大意：给定平面内n个圆，问这些圆把平面分成了多少个区域。<br>这题是欧拉定理，但和欧拉定理一般式(V+F-E=2)不太一样..</p>
<blockquote>
<p>求圆拆分平面有多少个区域怎么能离得开平面图的欧拉公式呢？<br>一般平面图欧拉公式：<strong>f=e−v+c+1</strong><br>其中 e 代表边的数量，v 代表点的数量，c 代表连通块的数量，f 代表平面区域的个数<br>我们把圆弧看作边，交点看作顶点，于是很容易便可以算出 e,v,c 啦~<br>对于 e ，它<strong>相当于每个圆上交点的数量和（因为这些交点把圆拆分成了这么多的弧）</strong><br>对于 v ，枚举求出交点去重即可<br>对于 c ，我们已经有了无向图的边，那连通块的数量可以直接 dfs/bfs 或者并查集算出来啦~<br>然后套用公式就是结果了，注意精度问题。<br>引用自<a href="https://blog.csdn.net/qq_28954601/article/details/79329961" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_28954601/article/details/79329961</a></p>
</blockquote>
<p>注意圆的欧拉公式中各值的定义也不太一样，E是不会算上单独的圆边的。具体确定方法见上面引用。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y) &#123;</span><br><span class="line">        x=_x;</span><br><span class="line">        y=_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hypot(x-p.x,y-p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hypot(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">trunc</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> l=len();</span><br><span class="line">        <span class="keyword">if</span>(!sgn(l)) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        r/=l;</span><br><span class="line">        <span class="keyword">return</span> Point(x*r,y*r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x)==<span class="number">0</span> &amp;&amp; sgn(y-b.y)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x)==<span class="number">0</span> ? sgn(y-b.y)&lt;<span class="number">0</span>:x&lt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x-b.x,y-b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> +(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x+b.x,y+b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.y-y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.x+y*b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotleft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(-y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotright</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(y,-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">circle</span> &#123;</span></span><br><span class="line">    Point p;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    circle() &#123; &#125;</span><br><span class="line">    circle(Point _p,<span class="keyword">double</span> _r) &#123;</span><br><span class="line">        p=_p;</span><br><span class="line">        r=_r;</span><br><span class="line">    &#125;</span><br><span class="line">    circle(<span class="keyword">double</span> x,<span class="keyword">double</span> y,<span class="keyword">double</span> _r) &#123;</span><br><span class="line">        p=Point(x,y);</span><br><span class="line">        r=_r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relationcircle</span><span class="params">(circle v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d=p.distance(v.p);</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-r-v.r)&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-r-v.r)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">double</span> l=<span class="built_in">fabs</span>(r-v.r);</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-r-v.r)&lt;<span class="number">0</span> &amp;&amp; sgn(d-l)&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-l)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-l)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pointcrosscircle</span><span class="params">(circle v,Point&amp; p1,Point&amp; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rel=relationcircle(v);</span><br><span class="line">        <span class="keyword">if</span>(rel==<span class="number">1</span> || rel==<span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> d=p.distance(v.p);</span><br><span class="line">        <span class="keyword">double</span> l=(d*d+r*r-v.r*v.r)/(<span class="number">2</span>*d);</span><br><span class="line">        <span class="keyword">double</span> h=<span class="built_in">sqrt</span>(r*r-l*l);</span><br><span class="line">        Point tmp=p+(v.p-p).trunc(l);</span><br><span class="line">        p1=tmp+((v.p-p).rotleft().trunc(h));</span><br><span class="line">        p2=tmp+((v.p-p).rotright().trunc(h));</span><br><span class="line">        <span class="keyword">if</span>(rel==<span class="number">2</span> || rel==<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;cir[<span class="number">4</span>];</span><br><span class="line">Point nodes[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> V=<span class="number">0</span>,E=<span class="number">0</span>,C=<span class="number">0</span>;</span><br><span class="line">Point ver[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">innodes</span><span class="params">(Point x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">        <span class="keyword">if</span>(nodes[i]==x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inver</span><span class="params">(Point x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">        <span class="keyword">if</span>(ver[i]==x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=getf(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1=getf(x),f2=getf(y);</span><br><span class="line">    <span class="keyword">if</span>(f1!=f2) fa[f1]=f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x,y,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;r);</span><br><span class="line">        cir[i]=circle(x,y,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cir[<span class="number">1</span>].relationcircle(cir[<span class="number">2</span>])==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"4"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) fa[i]=i;</span><br><span class="line">    Point a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) &#123;</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> opt=cir[i].pointcrosscircle(cir[j],a,b);</span><br><span class="line">            <span class="keyword">if</span>(opt==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!innodes(a)) nodes[V++]=a;</span><br><span class="line">                <span class="keyword">if</span>(!inver(a)) ver[t++]=a;</span><br><span class="line">                merge(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!innodes(a)) nodes[V++]=a;</span><br><span class="line">                <span class="keyword">if</span>(!inver(a)) ver[t++]=a;</span><br><span class="line">                <span class="keyword">if</span>(!innodes(b)) nodes[V++]=b;</span><br><span class="line">                <span class="keyword">if</span>(!inver(b)) ver[t++]=b;</span><br><span class="line">                merge(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        E+=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[getf(i)]) &#123;</span><br><span class="line">            vis[getf(i)]=<span class="literal">true</span>;</span><br><span class="line">            C++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,E-V+C+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言快速排序实现方案（面向ACM、NOIP）</title>
    <url>/archives/59389.html</url>
    <content><![CDATA[<p>我是C++选手，但学校要求用C考试，所以来总结一下C下快速排序的实现方案。<br>NOIP考试时，C++下有sort，pascal下有可用的示例文件，C就比较尴尬了。<br>这里用手写和使用qsort的方式实现快排。<br><a id="more"></a></p>
<h2 id="手写代码实现"><a href="#手写代码实现" class="headerlink" title="手写代码实现"></a>手写代码实现</h2><p>快排的代码实现需要格外注意i与j的边界情况。回想以往用pascal参加NOIP的经历，保证正确性起见，遂把pascal目录下的/demo/text/qsort.pp翻译成c贴上。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">100009</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,x,t;</span><br><span class="line">	i=l,j=r;</span><br><span class="line">	x=a[(l+r)/<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">while</span> (i&lt;=j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (a[i]&lt;x) i++;</span><br><span class="line">		<span class="keyword">while</span> (x&lt;a[j]) j--;</span><br><span class="line">		<span class="keyword">if</span> (i&lt;=j) &#123;</span><br><span class="line">			t=a[i];</span><br><span class="line">			a[i]=a[j];</span><br><span class="line">			a[j]=t;</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;j) sort(a,l,j);</span><br><span class="line">	<span class="keyword">if</span> (i&lt;r) sort(a,i,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	sort(a,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便祭上pascal代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">procedure <span class="title">sort</span><span class="params">(l,r: longint)</span></span>;</span><br><span class="line">  var</span><br><span class="line">     i,j,x,y: longint;</span><br><span class="line">  begin</span><br><span class="line">     i:=l;</span><br><span class="line">     j:=r;</span><br><span class="line">     x:=a[(l+r) div <span class="number">2</span>];</span><br><span class="line">     repeat</span><br><span class="line">       <span class="keyword">while</span> a[i]&lt;x <span class="keyword">do</span></span><br><span class="line">        inc(i);</span><br><span class="line">       <span class="keyword">while</span> x&lt;a[j] <span class="keyword">do</span></span><br><span class="line">        dec(j);</span><br><span class="line">       <span class="function"><span class="keyword">if</span> <span class="title">not</span><span class="params">(i&gt;j)</span> then</span></span><br><span class="line"><span class="function">         begin</span></span><br><span class="line"><span class="function">            y:</span>=a[i];</span><br><span class="line">            a[i]:=a[j];</span><br><span class="line">            a[j]:=y;</span><br><span class="line">            inc(i);</span><br><span class="line">            j:=j<span class="number">-1</span>;</span><br><span class="line">         end;</span><br><span class="line">     until i&gt;j;</span><br><span class="line">     <span class="keyword">if</span> l&lt;j then</span><br><span class="line">       sort(l,j);</span><br><span class="line">     <span class="keyword">if</span> i&lt;r then</span><br><span class="line">       sort(i,r);</span><br><span class="line">  end;</span><br></pre></td></tr></table></figure>
<h2 id="使用stdlib-h的qsort函数"><a href="#使用stdlib-h的qsort函数" class="headerlink" title="使用stdlib.h的qsort函数"></a>使用stdlib.h的qsort函数</h2><p>其实在实际测试（gcc 4.7.2）中发现不引用stdlib.h也可以使用qsort。<br>相比于C++的algorithm中的sort函数，qsort使用起来要麻烦一些，但速度相对会快那么一点。<br>在stdlib.h中qsort的声明为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">int</span> nelem, <span class="keyword">unsigned</span> <span class="keyword">int</span> width, <span class="keyword">int</span> ( * pfCompare)( <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>void *base</code>为需要排序的数据的起始地址<br><code>int nelem</code>需要排序的元素的个数<br><code>unsigned int width</code>为每个元素的大小<br><code>int ( * pfCompare)( const void *, const void *)</code>这个是指向比较函数的指针</p>
<p>相比于C++中的sort，多了元素个数、元素大小和必须加上的比较函数</p>
<p><strong>需要说明几点：</strong></p>
<p>1、<code>void *base</code>通常用数组名就可以（数组名相当于数组第一个元素的地址，即<code>a&lt;==&gt;&amp;a[0]</code>，同理<code>a+1&lt;==&gt;&amp;a[1]</code>）<br>2、<code>int ( * pfCompare)( const void *, const void *)</code>这是个函数指针，下面会提到<br>3、void *是一个特殊的指针，下面会提到<br>4、比较函数的返回值必须是int</p>
<p><strong>函数指针</strong></p>
<p>先区分两个概念：<strong>函数指针</strong>与<strong>指针函数</strong><br><strong>函数指针是指向函数的指针</strong>，指针函数是返回值为指针的函数，这里只简单提一下函数指针。</p>
<p>类似数组名为数组第一个元素的地址，函数名为函数的地址。<br>函数指针指向函数地址，如<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*f) (<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p>
<p>现在定义一个函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    &lt;foo&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果给f赋值<code>f=foo</code>，<br>那么<code>foo(1,2);&lt;==&gt;(*f)(1,2);&lt;==&gt;f(1,2);</code></p>
<p><strong>void*指针</strong></p>
<p>void<em>是一种特殊的指针，它没有类型，<strong>可以被赋值任何类型的地址</strong>。<br>但要注意调用这种类型时<strong>必须加强制类型转换</strong>，而且void</em>类型不能参与指针运算（GNU中是允许的，而ANSI C不允许）<br>一个例子<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">void</span>* p=&amp;a;</span><br><span class="line"><span class="keyword">int</span>* x;</span><br><span class="line">x=(<span class="keyword">int</span>*)p;</span><br></pre></td></tr></table></figure></p>
<p><strong>比较函数</strong></p>
<p>比较函数的返回值为int，和C++中的比较函数不太一样（C++中如果是用结构体的话直接重载&lt;就可以实现排序了），这里假设需要比较的两个元素为<em>a和</em>b</p>
<p>若 <em>a &lt; </em>b 则返回值应该小于0<br>若 <em>a == </em>b 则返回值应该等于0<br>若 <em>a &gt; </em>b 则返回值应该大于0</p>
<p>有些类似于strcmp的返回值</p>
<p>理解了这些，就不难看懂qsort的调用了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">100009</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *((<span class="keyword">int</span>*)a)-*((<span class="keyword">int</span>*)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	qsort(a+<span class="number">1</span>,n,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),compare);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compare是一个函数地址，在qsort引用时不用加括号</p>
<p>qsort还可以给结构体排序，示例如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">100009</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">&#125;data[<span class="number">100009</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">x</span>=(<span class="title">struct</span> <span class="title">Data</span>*)<span class="title">a</span>,*<span class="title">y</span>=(<span class="title">struct</span> <span class="title">Data</span>*)<span class="title">b</span>;</span></span><br><span class="line">	<span class="keyword">return</span> (*x).a-(*y).a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data[i].a);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data[i].b);</span><br><span class="line">	qsort(data+<span class="number">1</span>,n,<span class="keyword">sizeof</span>(struct Data),compare);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,data[i].a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,data[i].b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>NOIP</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1009 (FatMouse&#39; Trade)[贪心] 做题笔记</title>
    <url>/archives/5240.html</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1009" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1009</a></p>
<p>贪心，按照每个时间区间的结束时间排序，从小到大贪心找出每一个不重叠的区间即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Show</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Show&amp; y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t &lt; y.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;show[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;show[i].s, &amp;show[i].t);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(show, show + n);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(show[i].s &gt;= show[p].t) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                p = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1051 (Wooden Sticks)[贪心，LIS]</title>
    <url>/archives/24777.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1051" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1051</a></p>
<p>贪心策略，按照l为第一关键字，w为第二关键字排序，在排序后的w数组中寻找不下降子序列的个数即可（因为此时l数组单调不下降一定满足题目条件）。<br>有一个结论：单调不下降（不上升）子序列的数目等于最长单调下降（上升）子序列的长度，用树状数组求解LIS即可。<br>LIS问题用树状数组求解，树状数组直接维护前i-1个序列元素的LIS的最大值，树状数组的下标对应序列元素的高度（这样可以直接查询高度大于(等于)或小于(等于)个高度的LIS的最大值），序列下标较小的元素先进树状数组，保证了树状数组里查询到的结果一定是前i-1个元素而非之后的元素的。<br>看到这题的n为5000，感觉n^2肯定会炸，就写了一个LIS，结果发现其实交一个暴力的话只需要15ms，心情复杂.jpg</p>
<a id="more"></a>
<p>LIS树状数组做法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl=<span class="number">10009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mw=<span class="number">10001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">W</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> W&amp; y) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(a!=y.a) <span class="keyword">return</span> a&lt;y.a;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> b&lt;y.b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;w[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> t[maxl];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;maxl) &#123;</span><br><span class="line">		t[x]=max(t[x],val);</span><br><span class="line">		x+=lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">-2147483648</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) &#123;</span><br><span class="line">		ans=max(ans,t[x]);</span><br><span class="line">		x-=lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">		<span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="keyword">sizeof</span>(t));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;w[i].a,&amp;w[i].b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">		sort(w+<span class="number">1</span>,w+n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			f[i]=query(mw-(w[i].b+<span class="number">1</span>))+<span class="number">1</span>;</span><br><span class="line">			mx=max(mx,f[i]);</span><br><span class="line">			add(mw-(w[i].b),f[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>暴力做法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5009</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">W</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> W&amp; y) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(a!=y.a) <span class="keyword">return</span> a&lt;y.a;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> b&lt;y.b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;w[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;w[i].a,&amp;w[i].b);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(w+<span class="number">1</span>,w+n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>,x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">				vis[i]=<span class="number">1</span>;</span><br><span class="line">				cnt++;</span><br><span class="line">				x=w[i].b;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">					<span class="keyword">if</span>(w[j].b&gt;=x &amp;&amp; !vis[j]) x=w[j].b,vis[j]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1068 (Girls and Boys)[二分图匹配，匈牙利算法]</title>
    <url>/archives/20184.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1068" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1068</a></p>
<p>这题是求二分图最大点独立集，二分图最大点独立集=n-最大匹配。<br>要注意的是这题没有区分两种颜色的结点，因此算出的最大匹配要除2。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1009</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V[MAXN];</span><br><span class="line"><span class="keyword">int</span> linker[MAXN];</span><br><span class="line"><span class="keyword">bool</span> used[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V[u].size();i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> v=V[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!used[v]) &#123;</span><br><span class="line">			used[v]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(linker[v]==<span class="number">-1</span> || dfs(linker[v])) &#123;</span><br><span class="line">				linker[v]=u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="literal">false</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">		<span class="keyword">if</span>(dfs(u)) res++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	V[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v,cnt;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) V[i].clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d: (%d)"</span>,&amp;u,&amp;cnt);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;j++) &#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">				add(u,v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans=n-hungary()/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1263 (水果)做题笔记</title>
    <url>/archives/44200.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1263" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1263</a></p>
<p>这题可以使用二维的map做出来，注意迭代器的使用。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,cnt;</span><br><span class="line">	<span class="keyword">char</span> fruit[<span class="number">90</span>],prov[<span class="number">90</span>];</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; tab;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt;::iterator it1;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it2;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">		tab.clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s%s%d"</span>,fruit,prov,&amp;cnt);</span><br><span class="line">			tab[prov][fruit]+=cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (it1=tab.begin();it1!=tab.end();it1++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,it1-&gt;first.c_str());</span><br><span class="line">			<span class="keyword">for</span> (it2=it1-&gt;second.begin();it2!=it1-&gt;second.end();it2++) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"   |----%s(%d)\n"</span>,it2-&gt;first.c_str(),it2-&gt;second);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1391 (Number Steps)[map]</title>
    <url>/archives/3166.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1391" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1391</a><br>根据仔细分析题意后可以找出n和坐标x, y有如下关系：</p>
<table>
<thead>
<tr>
<th style="text-align:center">n%4</th>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">n/2</td>
<td style="text-align:center">n/2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">n/2+1</td>
<td style="text-align:center">n/2+1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">n/2+1</td>
<td style="text-align:center">n/2-1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">n/2+2</td>
<td style="text-align:center">n/2</td>
</tr>
</tbody>
</table>
<p>枚举n求出对应的x, y并用二维的map建立索引就可以了。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T, x, y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxc; i += <span class="number">4</span>) </span><br><span class="line">		m[(i&gt;&gt;<span class="number">1</span>)][(i&gt;&gt;<span class="number">1</span>)] = i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxc; i += <span class="number">4</span>) </span><br><span class="line">		m[(i&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>][(i&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxc; i += <span class="number">4</span>) </span><br><span class="line">		m[(i&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>][(i&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>] = i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= maxc; i += <span class="number">4</span>) </span><br><span class="line">		m[(i&gt;&gt;<span class="number">1</span>)+<span class="number">2</span>][(i&gt;&gt;<span class="number">1</span>)] = i + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="keyword">if</span> (m[x][y]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m[x][y] - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No Number\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>STL</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1285 (确定比赛名次)[拓扑排序]</title>
    <url>/archives/60742.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1285</a><br>题目给定战胜关系，求每队的排名，看起来与<a href="http://poj.org/problem?id=3660" rel="external nofollow noopener noreferrer" target="_blank">POJ3660</a>很像，但前者是求出每队的排名（可能不唯一），后者是判断每一队的排名是否唯一。<br>这题可以用拓扑排序做，但要特别注意输出的次序是从小到大的，这里把拓扑排序的队列修改为优先队列，就能按顺序输出了。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ne = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rank[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V[maxn];</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">int</span> ind[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u, v;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) V[i].clear();</span><br><span class="line">		ne = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">		<span class="built_in">memset</span>(ind, <span class="number">0</span>, <span class="keyword">sizeof</span>(ind));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">			V[u].push_back(v);</span><br><span class="line">			ind[v]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (!ind[i]) &#123;</span><br><span class="line">				q.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> now = q.top();</span><br><span class="line">			q.pop();</span><br><span class="line">			rank[ne++] = now;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V[now].size(); i++) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = V[now][i];</span><br><span class="line">				<span class="keyword">if</span> (!--ind[v]) &#123;</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ne; i++)</span><br><span class="line">			i != ne - <span class="number">1</span> ? <span class="built_in">printf</span>(<span class="string">"%d "</span>, rank[i]) : <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rank[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>STL</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1576 (A/B)[乘法逆元，拓展欧几里得]</title>
    <url>/archives/50696.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1576" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1576</a></p>
<p>求出B的乘法逆元，用A乘该逆元再对9973取模即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll&amp; d, ll&amp; x, ll&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b) &#123; d=a; x=<span class="number">1</span>; y=<span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; exgcd(b,a%b,d,y,x); y-=x*(a/b); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll n)</span> </span>&#123;</span><br><span class="line">	ll d,x,y;</span><br><span class="line">	exgcd(a,n,d,x,y);</span><br><span class="line">	<span class="keyword">return</span> d==<span class="number">1</span> ? (x+n)%n : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll A,B;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;A,&amp;B);</span><br><span class="line">		<span class="keyword">if</span>(A==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans=(A*inv(B,<span class="number">9973</span>))%<span class="number">9973</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>乘法逆元</tag>
        <tag>拓展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1705 (Count the grid)[计算几何，皮克公式]</title>
    <url>/archives/18862.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1705" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1705</a></p>
<p>题目大意：有一个在格纸上的三角形，给定三个顶点的坐标，求在三角形内部的格点数。</p>
<p>皮克定理：对于一个所有顶点都为整点的简单多边形，其面积为S，内部格点数为n，边上格点数为s， 则有：<strong>S = n + s/2 – 1</strong></p>
<p>这题求边上格点数时可以发现如果边不是水平或竖直的，那么边上的格点数为GCD(a,b)+1，a和b分别为边的水平和竖直方向上的长度。<br>求面积时要用叉积，直接套海伦公式会因为浮点数误差无法通过。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y) &#123;</span><br><span class="line">        x=_x;</span><br><span class="line">        y=_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.y-y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x-b.x,y-b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.x+y*b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getns</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x1==x2) <span class="keyword">return</span> <span class="built_in">abs</span>(y2-y1)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(y1==y2) <span class="keyword">return</span> <span class="built_in">abs</span>(x2-x1)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> gcd(<span class="built_in">abs</span>(x2-x1),<span class="built_in">abs</span>(y2-y1))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1,y1,x2,y2,x3,y3;</span><br><span class="line">	<span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> S;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3)) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x1==y1 &amp;&amp; y1==x2 &amp;&amp; x2==y2 &amp;&amp; y2==x3 &amp;&amp; x3==y3 &amp;&amp; y3==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		s=<span class="number">0</span>;</span><br><span class="line">		s+=getns(x1,y1,x2,y2);</span><br><span class="line">		s+=getns(x1,y1,x3,y3);</span><br><span class="line">		s+=getns(x2,y2,x3,y3);</span><br><span class="line">		s-=<span class="number">3</span>;</span><br><span class="line">		S=<span class="built_in">abs</span>(Point(x1-x2,y1-y2)^Point(x3-x2,y3-y2));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(S-s+<span class="number">2</span>)/<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1848 (Fibonacci again and again)[公平组合博弈，SG函数]</title>
    <url>/archives/62187.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1848" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1848</a></p>
<p>尼姆游戏变型，每次每堆石子只能取走斐波那契数个石子。<br>打一个SG表，SG值为0的为P局势，SG值为1的为N局势。判断三堆石子的SG值异或和即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> fibo[<span class="number">17</span>];</span><br><span class="line"><span class="keyword">int</span> sg[<span class="number">1009</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">17</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fibo[<span class="number">0</span>]=<span class="number">1</span>;fibo[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">16</span>;i++) fibo[i]=fibo[i<span class="number">-1</span>]+fibo[i<span class="number">-2</span>];</span><br><span class="line">    sg[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">16</span>;j++) vis[j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">16</span> &amp;&amp; i-fibo[j]&gt;=<span class="number">0</span>;j++) vis[sg[i-fibo[j]]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;;j++) <span class="keyword">if</span>(!vis[j]) &#123;</span><br><span class="line">            sg[i]=j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,sg1,sg2,sg3;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span> &amp;&amp; b==<span class="number">0</span> &amp;&amp; c==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        sg1=sg[a];</span><br><span class="line">        sg2=sg[b];</span><br><span class="line">        sg3=sg[c];</span><br><span class="line">        <span class="keyword">if</span>(sg1^sg2^sg3) <span class="built_in">puts</span>(<span class="string">"Fibo"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Nacci"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>博弈论</tag>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1894 (String Compare)做题笔记</title>
    <url>/archives/6646.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1894" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1894</a><br>预处理把字符串排序一下，这样从前面往后面比的时候如果遇到不匹配的情况直接跳过就行了。<br>另外使用string的compare函数可以很方便的做出来（速度也不慢）。<br>据说使用字典树会超时。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T,n,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> word[<span class="number">50001</span>];</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; word[i];</span><br><span class="line">		&#125;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::sort(word,word+n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (word[i].size()&gt;=word[j].size()) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (word[i].compare(<span class="number">0</span>,word[i].size(),word[j],<span class="number">0</span>,word[i].size())==<span class="number">0</span>) </span><br><span class="line">					cnt++;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt&gt;<span class="number">11519</span>) cnt%=<span class="number">11519</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2147 (kiki&#39;s game)[博弈论，打表]</title>
    <url>/archives/55228.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2147" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2147</a></p>
<p>这题可以用打表的方式找出规律。令矩阵左下角为P局势递推，所有能到达P局势的为N局势，所有到达不了P局势只能到N局势的为P局势，就可以发现偶数列全是先手必胜，奇数列的偶数行为先手必胜。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(m&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>((n&amp;<span class="number">1</span>)?<span class="string">"What a pity!"</span>:<span class="string">"Wonderful!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Wonderful!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2177 取（2堆）石子游戏[威佐夫博弈]</title>
    <url>/archives/31549.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2177" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2177</a></p>
<p>这题是需要输出第一步策略的威佐夫博弈，首先打表求出范围内所有奇异局势(<code>ak=k*(1+sqrt(5))/2), bk=ak+k</code>)，然后二分判断给定局势是否为奇异局势，如果不是，那么根据bk=ak+k的性质，可以令m-n=k并算出这个k对应的ak和bk，这就是m和n同时减去一个数对应的局势。然后分别模拟n减去一个值或m减去一个值的情况，并在表中查找对应的局势即可（需要注意m减去一个值后可能会小于n）。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn+<span class="number">9</span>],b[maxn+<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span> sa[<span class="number">10</span>],sb[<span class="number">10</span>],t=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">        <span class="keyword">if</span>(sa[i]==n &amp;&amp; sb[i]==m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++) &#123;</span><br><span class="line">        a[i]=i*(<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>;</span><br><span class="line">        b[i]=a[i]+i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n,m,p;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m) swap(n,m);</span><br><span class="line">        p=lower_bound(a,a+maxn+<span class="number">1</span>,n)-a;</span><br><span class="line">        <span class="keyword">if</span>(a[p]==n&amp;&amp;b[p]==m) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">            t=<span class="number">0</span>;</span><br><span class="line">            sa[t]=(m-n)*(<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>;</span><br><span class="line">            sb[t++]=sa[<span class="number">0</span>]+(m-n);</span><br><span class="line">            p=lower_bound(b,b+maxn+<span class="number">1</span>,m)-b;</span><br><span class="line">            <span class="keyword">if</span>(!(p&gt;=maxn+<span class="number">1</span> || b[p]!=m) &amp;&amp; n&gt;a[p] &amp;&amp;check(a[p],b[p]))</span><br><span class="line">                sa[t]=a[p],sb[t++]=b[p];</span><br><span class="line">            p=lower_bound(a,a+maxn+<span class="number">1</span>,n)-a;</span><br><span class="line">            <span class="keyword">if</span>(!(p&gt;=maxn+<span class="number">1</span> || a[p]!=n) &amp;&amp; m&gt;b[p] &amp;&amp;check(a[p],b[p]))</span><br><span class="line">                sa[t]=a[p],sb[t++]=b[p];</span><br><span class="line">            p=lower_bound(b,b+maxn+<span class="number">1</span>,n)-b;</span><br><span class="line">            <span class="keyword">if</span>(!(p&gt;=maxn+<span class="number">1</span> || b[p]!=n) &amp;&amp; a[p]&lt;m &amp;&amp;check(a[p],b[p]))</span><br><span class="line">                sa[t]=a[p],sb[t++]=b[p];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,sa[i],sb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2188 (选拔志愿者)[巴什博奕]</title>
    <url>/archives/27187.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2188" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2188</a><br>这题是巴什博奕裸题。<br>若规则为最后取光的人赢，则n%(m+1)==0时先手必败。<br>若规则为最后取光的人输，则(n-1)%(m+1)==0时先手必败。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> T = in.nextInt();</span><br><span class="line">		<span class="keyword">while</span> ((T--)!=<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> n = in.nextInt(), m = in.nextInt();</span><br><span class="line">			<span class="keyword">if</span> (n%(m+<span class="number">1</span>) == <span class="number">0</span>) System.out.println(<span class="string">"Rabbit"</span>);</span><br><span class="line">			<span class="keyword">else</span> System.out.println(<span class="string">"Grass"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2243 (考研路茫茫——单词情结)[AC自动机，矩阵乘法]</title>
    <url>/archives/16318.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2243" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2243</a></p>
<p>题目大意：给定n个模板串，问有多少个长度不超过L的含至少一个模板串的字符串。<br>首先考虑问题的相反问题，求有多少个不含任何模板串的字符串，并只考虑长度正好为$l$的字符串的数量，这个问题的解题方法见<a href="https://www.mhlwsk.com/archives/55506.html">POJ2778(DNA Sequence)</a>。<br>现在我们已经能计算长度为$l$的字符串的数量，但问题要求的是长度不超过$L$的字符串数量，答案对应的矩阵为 $A^1+A^2+…+A^L$ 。<br>令 $S_n=A^1+A^2+…+A^n$，则$S_n=S_{n-1}A+A$<br>$$<br>\left[ \begin{matrix} S_n &amp; A \end{matrix} \right] = \left[ \begin{matrix} S_{n-1} &amp; A \end{matrix} \right] \left[ \begin{matrix} A &amp; 0 \\ E &amp; E \end{matrix} \right] = \left[ \begin{matrix} 0 &amp; A \end{matrix} \right] {\left[ \begin{matrix} A &amp; 0 \\ E &amp; E \end{matrix} \right]}^n<br>$$<br>这样就能用矩阵快速幂求出不含任何模板串的答案对应的矩阵了。接下来要用总方案数减去这个答案。<br>使用同样的方法求出$T_n=26^1+26^2+…+26^n$，并用$T_n$减去上述答案即可。<br>$$<br>\left[ \begin{matrix} T_n &amp; 26 \end{matrix} \right] = \left[ \begin{matrix} T_{n-1} &amp; 26 \end{matrix} \right] \left[ \begin{matrix} 26 &amp; 0 \\ 1 &amp; 1 \end{matrix} \right] = \left[ \begin{matrix} 0 &amp; 26 \end{matrix} \right] {\left[ \begin{matrix} 26 &amp; 0 \\ 1 &amp; 1 \end{matrix} \right]}^n<br>$$</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">bool</span> danger[maxn];</span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	sz=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(danger,<span class="number">0</span>,<span class="keyword">sizeof</span>(danger));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-<span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u=<span class="number">0</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> c=idx(s[i]);</span><br><span class="line">		<span class="keyword">if</span>(!ch[u][c]) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">			danger[sz]=<span class="literal">false</span>;</span><br><span class="line">			ch[u][c]=sz++;</span><br><span class="line">		&#125;</span><br><span class="line">		u=ch[u][c];</span><br><span class="line">	&#125;</span><br><span class="line">	danger[u]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u=ch[<span class="number">0</span>][c];</span><br><span class="line">		<span class="keyword">if</span>(u) &#123; f[u]=<span class="number">0</span>;q.push(u); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> r=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u=ch[r][c];</span><br><span class="line">			<span class="keyword">if</span>(!u) &#123; ch[r][c]=ch[f[r]][c];<span class="keyword">continue</span>; &#125;</span><br><span class="line">			q.push(u);</span><br><span class="line">			<span class="keyword">int</span> v=f[r];</span><br><span class="line">			<span class="keyword">while</span>(v &amp;&amp; !ch[v][c]) v=f[v];</span><br><span class="line">			f[u]=ch[v][c];</span><br><span class="line">			danger[u]|=danger[ch[v][c]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ull mat[maxn*<span class="number">2</span>][maxn*<span class="number">2</span>];</span><br><span class="line">ull A[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(A));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) <span class="keyword">if</span>(!danger[i]) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u=ch[i][j];</span><br><span class="line">			<span class="keyword">if</span>(!danger[u]) A[i][u]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span>(mat));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++) &#123;</span><br><span class="line">            mat[i][j]=A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">        mat[i+sz][i]=mat[i+sz][i+sz]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ull ans[maxn*<span class="number">2</span>][maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	ull tmp[maxn*<span class="number">2</span>][maxn*<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz*<span class="number">2</span>;i++)</span><br><span class="line">		ans[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz*<span class="number">2</span>;i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz*<span class="number">2</span>;j++)</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sz*<span class="number">2</span>;k++)</span><br><span class="line">						tmp[i][j]=((ans[i][k]*mat[k][j])+tmp[i][j]);</span><br><span class="line">			<span class="built_in">memcpy</span>(ans,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz*<span class="number">2</span>;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz*<span class="number">2</span>;j++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sz*<span class="number">2</span>;k++)</span><br><span class="line">					tmp[i][j]=((mat[i][k]*mat[k][j])+tmp[i][j]);</span><br><span class="line">		<span class="built_in">memcpy</span>(mat,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ull tot[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">ull mat2[<span class="number">2</span>][<span class="number">2</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">26</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow_mod_sum</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	ull tmp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">	mat2[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">26</span>;</span><br><span class="line">	mat2[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	mat2[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	mat2[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(tot,<span class="number">0</span>,<span class="keyword">sizeof</span>(tot));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">		tot[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">						tmp[i][j]=((tot[i][k]*mat2[k][j])+tmp[i][j]);</span><br><span class="line">			<span class="built_in">memcpy</span>(tot,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">					tmp[i][j]=((mat2[i][k]*mat2[k][j])+tmp[i][j]);</span><br><span class="line">		<span class="built_in">memcpy</span>(mat2,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>];</span><br><span class="line">ull seq[maxn][maxn*<span class="number">2</span>];</span><br><span class="line">ull ans2[maxn][maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l)) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">            insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        getFail();</span><br><span class="line">        build();</span><br><span class="line">        pow_mod(l);</span><br><span class="line">        <span class="built_in">memset</span>(seq,<span class="number">0</span>,<span class="keyword">sizeof</span>(seq));</span><br><span class="line">        <span class="built_in">memset</span>(ans2,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans2));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++) &#123;</span><br><span class="line">                seq[i][j+sz]=A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*sz;j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>*sz;k++) &#123;</span><br><span class="line">                    ans2[i][j]=seq[i][k]*ans[k][j]+ans2[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ull a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            a=(ans2[<span class="number">0</span>][i]+a);</span><br><span class="line">        &#125;</span><br><span class="line">        pow_mod_sum(l);</span><br><span class="line">        ull sum=tot[<span class="number">1</span>][<span class="number">0</span>]*<span class="number">26</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64u\n"</span>,sum-a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2457 (DNA repair)[AC自动机，动态规划]</title>
    <url>/archives/36543.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2457" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2457</a></p>
<p>题目大意：给定n个模板串，再给一个待匹配串，问至少修改待匹配串的几个字符能使得它不包含任何一个模板串</p>
<p>可以想到一个满足条件的串一定能在trie图上沿边一直走却遇不到任何一个单词节点（或者能通过后缀链接跳转到单词节点的点），而这个trie图事实上构成了一个状态转移图，我们把它应用到DP的状态转移上。<br>令dp[i][j]表示处理到第i个字符且停留在trie图上第j个状态时的最小修改次数，则状态转移方程为<strong>dp[i+1][ch[j][c]]=min(dp[i][ch[j][c]],dp[i][j]+(idx(s[i])!=c))</strong></p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> f[maxn];</span><br><span class="line">    <span class="keyword">bool</span> danger[maxn];</span><br><span class="line">    <span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sz=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(danger,<span class="number">0</span>,<span class="keyword">sizeof</span>(danger));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'T'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][c]) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">                danger[sz]=<span class="number">0</span>;</span><br><span class="line">                ch[u][c]=sz++;</span><br><span class="line">            &#125;</span><br><span class="line">            u=ch[u][c];</span><br><span class="line">        &#125;</span><br><span class="line">        danger[u]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=ch[<span class="number">0</span>][c];</span><br><span class="line">            <span class="keyword">if</span>(u) &#123; f[u]=<span class="number">0</span>;q.push(u); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u=ch[r][c];</span><br><span class="line">                <span class="keyword">if</span>(!u) &#123; ch[r][c]=ch[f[r]][c];<span class="keyword">continue</span>; &#125;</span><br><span class="line">                q.push(u);</span><br><span class="line">                <span class="keyword">int</span> v=f[r];</span><br><span class="line">                <span class="keyword">while</span>(v &amp;&amp; !ch[v][c]) v=f[v];</span><br><span class="line">                f[u]=ch[v][c];</span><br><span class="line">                danger[u]|=danger[ch[v][c]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++) &#123;</span><br><span class="line">                dp[i][j]=inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;=inf) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(danger[ch[j][k]]) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[i+<span class="number">1</span>][ch[j][k]]=min(dp[i+<span class="number">1</span>][ch[j][k]],dp[i][j]+(idx(s[i])!=k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            ans=min(ans,dp[n][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==inf) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1009</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> cas=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        tr.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">            tr.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        tr.getFail();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,++cas,tr.getans(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2594 (Simpsons’ Hidden Talents)[KMP]</title>
    <url>/archives/63457.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2594" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2594</a></p>
<p>一开始一直在纠结怎样从B串向A串构造fail指针，但其实不用这么麻烦，只需要把B串接到A串后面，对新串构造fail指针，然后在新串中找出满足长度小于两串长度的的最长前缀即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50009</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s1[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s2[MAXN];</span><br><span class="line"><span class="keyword">int</span> l1,l2;</span><br><span class="line"><span class="keyword">int</span> f[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">(<span class="keyword">char</span> *P,<span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m=<span class="built_in">strlen</span>(P);</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> j=f[i];</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;P[i]!=P[j]) j=f[j];</span><br><span class="line">		f[i+<span class="number">1</span>]=P[i]==P[j]?j+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s1,s2)) &#123;</span><br><span class="line">		l1=<span class="built_in">strlen</span>(s1);</span><br><span class="line">		l2=<span class="built_in">strlen</span>(s2);</span><br><span class="line">		<span class="built_in">strcpy</span>(s1+l1,s2);</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">		getfail(s1,f);</span><br><span class="line">		<span class="keyword">int</span> p=f[<span class="built_in">strlen</span>(s1)];</span><br><span class="line">		<span class="keyword">while</span>(p&gt;l1||p&gt;l2) p=f[p];</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,s1[i]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" %d\n"</span>,p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2837 (Calculation)[指数循环节，欧拉函数]</title>
    <url>/archives/53309.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2837" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2837</a></p>
<p>指数循环节对应公式：<strong>a^(b%phi(p)+phi(p))≡a^b (mod p)  (b&gt;=phi(p))</strong><br>递归求解每个n即可，需要注意的是公式对应条件b&gt;=phi(p)，如果不满足条件，则不能套公式（即不用多加一个phi(p)），这里在pow_pow里特殊处理了。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">euler_phi</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	ll m=(ll)<span class="built_in">sqrt</span>(n+<span class="number">0.5</span>);</span><br><span class="line">	ll ans=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++) <span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">		ans=ans/i * (i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans=ans/n*(n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll x,ll y,ll m)</span> </span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=m) flag=<span class="literal">true</span>;</span><br><span class="line">	x%=m;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ans*x&gt;=m) flag=<span class="literal">true</span>;</span><br><span class="line">			ans=(ans*x)%m;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((y&gt;&gt;<span class="number">1</span>) &amp;&amp; (x*x&gt;=m)) flag=<span class="literal">true</span>; </span><br><span class="line">		x=(x*x)%m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag) <span class="keyword">return</span> ans+m;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">10</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;=m) <span class="keyword">return</span> n%m+m;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	ll phi=euler_phi(m);</span><br><span class="line">	ll tmp=f(n/<span class="number">10</span>,phi);</span><br><span class="line">	ll ans=pow_mod(n%<span class="number">10</span>,tmp,m);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f(n,m)%m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2844 (Coins)[背包]</title>
    <url>/archives/55316.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2844" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2844</a><br>这题可以转化为多重背包问题，套用二进制优化即可，可以参考《背包九讲》。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f[maxm];</span><br><span class="line"><span class="keyword">int</span> a[maxn], c[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, c + i);</span><br><span class="line">		f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(c[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> w = <span class="built_in">std</span>::min(k, c[i]) * a[i];</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= w; j--) </span><br><span class="line">					f[j] |= f[j-w];</span><br><span class="line">				c[i] -= k; </span><br><span class="line">				k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">			<span class="keyword">if</span> (f[i]) ans++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3065 (病毒侵袭持续中)[AC自动机]</title>
    <url>/archives/21237.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3065" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3065</a></p>
<p>这题是AC自动机模板题，统计每个模板串在文本串中的出现次数。下面贴上模板。</p>
<p>需要注意的是找到一个单词时，可以是直接找到了这个单词的单词节点，也可以是通过这个节点经由后缀链接跳转到了其它单词节点。因为有类似这种情况：10是1010的后缀，但如果匹配到1010显然也应该匹配一次10，这时应该通过后缀链接跳转过去修改10对应的匹配数。<br>注：后缀链接指向当前节点能通过fail指针跳转到的上一个单词节点的标号。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50009</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> f[maxn];</span><br><span class="line">    <span class="keyword">int</span> last[maxn];</span><br><span class="line">    <span class="keyword">int</span> val[maxn];</span><br><span class="line">    ll num[maxn];</span><br><span class="line">    <span class="keyword">int</span> index[<span class="number">1009</span>];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        sz=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));</span><br><span class="line">        <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span>(val));</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(index,<span class="number">0</span>,<span class="keyword">sizeof</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c-<span class="string">'A'</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][c]) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">                val[sz]=<span class="number">0</span>;</span><br><span class="line">                ch[u][c]=sz++;</span><br><span class="line">            &#125;</span><br><span class="line">            u=ch[u][c];</span><br><span class="line">        &#125;</span><br><span class="line">        val[u]+=<span class="number">1</span>;</span><br><span class="line">        index[v]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(T);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=idx(T[i]);</span><br><span class="line">            <span class="keyword">if</span>(c&lt;<span class="number">0</span> || c&gt;=<span class="number">26</span>) &#123;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; !ch[j][c]) j=f[j];</span><br><span class="line">            j=ch[j][c];</span><br><span class="line">            <span class="keyword">if</span>(val[j]) num[j]++;</span><br><span class="line">            <span class="keyword">int</span> k=j;</span><br><span class="line">            <span class="keyword">while</span>(last[k]) &#123; <span class="comment">//通过后缀链接修改还能匹配到的单词节点</span></span><br><span class="line">                k=last[k];</span><br><span class="line">                num[k]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=ch[<span class="number">0</span>][c];</span><br><span class="line">            <span class="keyword">if</span>(u) &#123; f[u]=<span class="number">0</span>;q.push(u);last[u]=<span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u=ch[r][c];</span><br><span class="line">                <span class="keyword">if</span>(!u) <span class="keyword">continue</span>;</span><br><span class="line">                q.push(u);</span><br><span class="line">                <span class="keyword">int</span> v=f[r];</span><br><span class="line">                <span class="keyword">while</span>(v &amp;&amp; !ch[v][c]) v=f[v];</span><br><span class="line">                f[u]=ch[v][c];</span><br><span class="line">                last[u]=val[f[u]] ? f[u] : last[f[u]]; <span class="comment">//预处理后缀链接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1009</span>][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">2000009</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        tr.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</span><br><span class="line">            tr.insert(s[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        tr.getFail();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">        tr.find(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr.num[tr.index[i]]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s: %I64d\n"</span>,s[i],tr.num[tr.index[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3068 (最长回文)[Manachar]</title>
    <url>/archives/60486.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3068" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3068</a></p>
<p>求最长回文子串，Manachar算法模板题，这里贴出Manachar算法模板。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">110009</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">char</span> Ma[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> Mp[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manachar</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">	Ma[l++]=<span class="string">'$'</span>;</span><br><span class="line">	Ma[l++]=<span class="string">'#'</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">		Ma[l++]=s[i];</span><br><span class="line">		Ma[l++]=<span class="string">'#'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Ma[l]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(Mp,<span class="number">0</span>,<span class="keyword">sizeof</span>(Mp));</span><br><span class="line">	<span class="keyword">int</span> mx=<span class="number">0</span>,id=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l;i++) &#123;</span><br><span class="line">		Mp[i]=mx&gt;i?min(Mp[<span class="number">2</span>*id-i],mx-i):<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(Ma[i+Mp[i]]==Ma[i-Mp[i]])Mp[i]++;</span><br><span class="line">		<span class="keyword">if</span>(i+Mp[i]&gt;mx) &#123;</span><br><span class="line">			mx=i+Mp[i];</span><br><span class="line">			id=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)) &#123;</span><br><span class="line">		<span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">		Manachar(s,len);</span><br><span class="line">		<span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;Ma[i]!=<span class="string">'\0'</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Mp[i]&gt;mx) &#123;</span><br><span class="line">				mx=Mp[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mx<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Manachar</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3415 (Max Sum of Max-K-sub-sequence)[前缀和，单调队列]</title>
    <url>/archives/335.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3415" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3415</a></p>
<p>这题乍一看是区间最大子段和加上了长度的限制。<br>维护一个前缀和b[n]，枚举i，对于当前i，显然最优解是b[i]-min(b[l])，其中i-k&lt;= l &lt;=i-1。<br>此时只需要能快速找出b[l]即可。<br>考虑每次只需要找到满足位置要求（l的要求）的之前一段到当前位置的最小值，我们可以用单调队列来维护这个最小值。<br>这里维护一个单增的单调队列，每次取最小值时从队首找到第一个符合位置要求的值即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100009</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> b[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> q[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> p[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(q));</span><br><span class="line">		<span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">		l=r=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i),a[i+n]=a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) b[i]=b[i<span class="number">-1</span>]+a[i];</span><br><span class="line">		<span class="keyword">int</span> mx=<span class="number">-2147483648</span>;</span><br><span class="line">		<span class="keyword">int</span> mxl=<span class="number">0</span>,mxr=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; b[i<span class="number">-1</span>]&lt;q[r<span class="number">-1</span>]) r--;</span><br><span class="line">			q[r]=b[i<span class="number">-1</span>];</span><br><span class="line">			p[r++]=i<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r &amp;&amp; p[l]&lt;i-k) l++;</span><br><span class="line">			<span class="keyword">if</span>(b[i]-q[l]&gt;mx) &#123;</span><br><span class="line">				mx=b[i]-q[l];</span><br><span class="line">				mxl=p[l]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(mxl&gt;n) mxl-=n;</span><br><span class="line">				mxr=i;</span><br><span class="line">				<span class="keyword">if</span>(mxr&gt;n) mxr-=n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,mx,mxl,mxr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3516 (树的构造)[区间DP，四边形不等式优化]</title>
    <url>/archives/57270.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3516" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3516</a></p>
<p>这题是区间DP，类比于线性石子合并。<br>每次合并的w函数为<code>dp[l][k-1]+dp[k][r]+node[k].x-node[l].x+node[k-1].y-node[r].y;</code><br>需要运用四边形不等式优化。<br>可以类比<a href="https://www.mhlwsk.com/archives/49567.html">线性石子合并</a>的做法。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn][maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">N</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">                dp[i][j] = i==j ? <span class="number">0</span> : inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>]=node[i+<span class="number">1</span>].x-node[i].x+node[i].y-node[i+<span class="number">1</span>].y;</span><br><span class="line">            s[i][i+<span class="number">1</span>]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=s[l][r<span class="number">-1</span>];k&lt;=s[l+<span class="number">1</span>][r];k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp=dp[l][k<span class="number">-1</span>]+dp[k][r]+node[k].x-node[l].x+node[k<span class="number">-1</span>].y-node[r].y;</span><br><span class="line">                    <span class="keyword">if</span>(tmp&lt;=dp[l][r]) &#123;</span><br><span class="line">                        dp[l][r]=tmp;</span><br><span class="line">                        s[l][r]=k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>区间DP</tag>
        <tag>四边形不等式优化</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3729 (I&#39;m Telling the Truth)[二分图匹配，匈牙利算法]</title>
    <url>/archives/46587.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3729" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3729</a></p>
<p>这题比较直观的想法是从学生向区间中的每一个名次连边，形成一张二分图，问题转化为求二分图最大匹配。<br>比较麻烦的是需要输出字典序最大的情况，这里需要注意的是匈牙利算法枚举时要倒着搜。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">101000</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V[MAXN];</span><br><span class="line"><span class="keyword">int</span> linker[MAXN];</span><br><span class="line"><span class="keyword">bool</span> used[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V[u].size();i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> v=V[u][i];</span><br><span class="line">		<span class="keyword">if</span>(!used[v]) &#123;</span><br><span class="line">			used[v]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(linker[v]==<span class="number">-1</span> || dfs(linker[v])) &#123;</span><br><span class="line">				linker[v]=u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=n;u&gt;=<span class="number">1</span>;u--) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="literal">false</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">		<span class="keyword">if</span>(dfs(u)) res++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	V[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> seq[MAXN],t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">int</span> mxr=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		t=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++) V[i].clear();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		mxr=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			mxr=max(mxr,b);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=a;j&lt;=b;j++) add(i,j+n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans=hungary();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n+mxr;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(linker[i]!=<span class="number">-1</span>) seq[t++]=linker[i];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(seq,seq+t);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++) <span class="built_in">printf</span>(i&lt;t<span class="number">-1</span>?<span class="string">"%d "</span>:<span class="string">"%d"</span>,seq[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3746 (Cyclic Nacklace)[KMP]</title>
    <url>/archives/374.html</url>
    <content><![CDATA[<p><strong>题目背景：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3746" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3746</a></p>
<p>一道经典KMP题目。<br>出几组数据推导，可以得出一个结论，循环节长度等于len-fail[len]，另外可以观察出字符添加在开头和结尾是等价的，因此就可以减去循环节得出要加的长度了。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100009</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">(<span class="keyword">char</span> *P,<span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m=<span class="built_in">strlen</span>(P);</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> j=f[i];</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;P[i]!=P[j]) j=f[j];</span><br><span class="line">		f[i+<span class="number">1</span>]=P[i]==P[j]?j+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">		getfail(s,f);</span><br><span class="line">		<span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">int</span> l=f[len];</span><br><span class="line">		<span class="keyword">int</span> cyl=len-l;</span><br><span class="line">		<span class="keyword">int</span> ans=cyl-(len%cyl);</span><br><span class="line">		<span class="keyword">if</span>(len/cyl&gt;<span class="number">1</span>) ans%=cyl;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3974 (Assign the task)[DFS序，线段树]</title>
    <url>/archives/55249.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3974" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3974</a></p>
<p>乍一看是要维护一颗树节点的颜色，每次要修改一整颗子树的颜色。但如果把这棵树的DFS序（这里用的先序遍历）写出来，就可以发现每次维护的颜色都是一段连续DFS序上的，用线段树维护即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">50009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIX=<span class="number">1000000009</span>;</span><br><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V[MAXN];</span><br><span class="line"><span class="keyword">int</span> ff=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l[MAXN];</span><br><span class="line"><span class="keyword">int</span> r[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> col,nc;</span><br><span class="line">	<span class="keyword">int</span> lc,rc;</span><br><span class="line">&#125;v[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	v[now].col=<span class="number">-1</span>;</span><br><span class="line">	v[now].nc=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		v[now].lc=t;</span><br><span class="line">		build(t++,l,mid);</span><br><span class="line">		v[now].rc=t;</span><br><span class="line">		build(t++,mid,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		v[now].lc=v[now].rc=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> mid,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v[now].nc==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">	v[v[now].lc].nc=v[now].nc;</span><br><span class="line">	v[v[now].rc].nc=v[now].nc;</span><br><span class="line">	v[v[now].lc].col=v[now].nc;</span><br><span class="line">	v[v[now].rc].col=v[now].nc;</span><br><span class="line">	v[now].nc=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> lr,<span class="keyword">int</span> rr,<span class="keyword">int</span> nc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lr&lt;=l&amp;&amp;r&lt;=rr) &#123;</span><br><span class="line">		v[now].nc=nc;</span><br><span class="line">		v[now].col=nc;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v[now].nc!=<span class="number">-1</span>) update(now,l,mid,r);</span><br><span class="line">	<span class="keyword">if</span>(lr&lt;mid) change(v[now].lc,l,mid,lr,rr,nc);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;rr) change(v[now].rc,mid,r,lr,rr,nc);</span><br><span class="line">	<span class="keyword">if</span>(v[v[now].lc].col==MIX || v[v[now].rc].col==MIX) v[now].col=MIX;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(v[v[now].lc].col==v[v[now].rc].col) v[now].col=v[v[now].lc].col;</span><br><span class="line">	<span class="keyword">else</span> v[now].col=MIX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _ans=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> lr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(v[now].col!=MIX) &#123;</span><br><span class="line">		_ans=v[now].col;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v[now].nc!=<span class="number">-1</span>) update(now,l,mid,r);</span><br><span class="line">	<span class="keyword">if</span>(lr&lt;mid) query(v[now].lc,l,mid,lr);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;lr+<span class="number">1</span>) query(v[now].rc,mid,r,lr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	l[x]=++cnt;</span><br><span class="line">	r[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V[x].size();i++) &#123;</span><br><span class="line">		dfs(V[x][i]);</span><br><span class="line">		r[x]=max(r[x],r[V[x][i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(r[x]==<span class="number">0</span>) r[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>;c&lt;=T;c++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,c);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="keyword">sizeof</span>(fa));</span><br><span class="line">		<span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span>(l));</span><br><span class="line">		<span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span>(r));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) V[i].clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">			fa[x]=y;</span><br><span class="line">			V[y].push_back(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(fa[i]==<span class="number">0</span>) &#123;</span><br><span class="line">				ff=i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(ff);</span><br><span class="line">		t=<span class="number">2</span>;</span><br><span class="line">		build(root,<span class="number">0</span>,cnt+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">			<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'C'</span>) &#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">				_ans=<span class="number">-1</span>;</span><br><span class="line">				query(root,<span class="number">0</span>,cnt+<span class="number">1</span>,l[x]);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,_ans);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'T'</span>) &#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">				change(root,<span class="number">0</span>,cnt+<span class="number">1</span>,l[x],r[x]+<span class="number">1</span>,y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3836 (Equivalent Sets)[强连通]</title>
    <url>/archives/12984.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3836" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3836</a></p>
<p>题目大意：给定一些命题，以及一部分命题的推导关系，问还需要至少添加几个推导关系能让所有的命题可以互相证明。</p>
<blockquote>
<p>首先找出强连通分量，然后把每个强连通分量缩成一个点，得到一个DAG。接下来，设有a个结点（这里的结点对应于原图的一个强连通分量）的入度为0,b个结点的出度为0,则max{a,b}就是答案。注意特殊情况：当原图已经强连通时，答案是0而不是1。<br><em>引用自刘汝佳《算法竞赛入门经典 训练指南》</em></p>
</blockquote>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">50010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],tot;</span><br><span class="line"><span class="keyword">int</span> Low[MAXN],DFN[MAXN],Stack[MAXN],Belong[MAXN];</span><br><span class="line"><span class="keyword">int</span> Index,top;</span><br><span class="line"><span class="keyword">int</span> scc;</span><br><span class="line"><span class="keyword">bool</span> Instack[MAXN];</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[tot].to=v;edge[tot].next=head[u];head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Low[u]=DFN[u]=++Index;</span><br><span class="line">    Stack[top++]=u;</span><br><span class="line">    Instack[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next) &#123;</span><br><span class="line">        v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!DFN[v]) &#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            <span class="keyword">if</span>(Low[u]&gt;Low[v]) Low[u]=Low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Instack[v] &amp;&amp; Low[u]&gt;DFN[v]) &#123;</span><br><span class="line">            Low[u]=DFN[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Low[u]==DFN[u]) &#123;</span><br><span class="line">        scc++;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v=Stack[--top];</span><br><span class="line">            Instack[v]=<span class="literal">false</span>;</span><br><span class="line">            Belong[v]=scc;</span><br><span class="line">            num[scc]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(v!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(DFN,<span class="number">0</span>,<span class="keyword">sizeof</span>(DFN));</span><br><span class="line">    <span class="built_in">memset</span>(Instack,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Instack));</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="built_in">memset</span>(Belong,<span class="number">0</span>,<span class="keyword">sizeof</span>(Belong));</span><br><span class="line">    Index=scc=top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!DFN[i])</span><br><span class="line">            Tarjan(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> in0[MAXN];</span><br><span class="line"><span class="keyword">bool</span> out0[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            addedge(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        solve(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) in0[i]=out0[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];j!=<span class="number">-1</span>;j=edge[j].next) &#123;</span><br><span class="line">                <span class="keyword">int</span> v=edge[j].to;</span><br><span class="line">                <span class="keyword">if</span>(Belong[i]!=Belong[v]) in0[Belong[v]]=out0[Belong[i]]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(in0[i]) a++;</span><br><span class="line">            <span class="keyword">if</span>(out0[i]) b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(scc==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU4280 (Island Transport)[网络流]</title>
    <url>/archives/41255.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4280" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=4280</a></p>
<p>这题是一道比较裸的网络流题，需要注意的是每条航线是双向的，连边时需要加上反向边。<br>另外这题非常卡时间，我用dinic超时了，换成了ISAP。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>,MAXN=<span class="number">100010</span>,MAXM=<span class="number">400009</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,cap,flow;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line"><span class="keyword">int</span> gap[MAXN],dep[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> rw=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    edge[tot].to=v;edge[tot].cap=w;edge[tot].flow=<span class="number">0</span>;</span><br><span class="line">    edge[tot].next=head[u];head[u]=tot++;</span><br><span class="line">    edge[tot].to=u;edge[tot].cap=rw;edge[tot].flow=<span class="number">0</span>;</span><br><span class="line">    edge[tot].next=head[v];head[v]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Q[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="keyword">sizeof</span>(gap));</span><br><span class="line">    gap[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">    dep[end]=<span class="number">0</span>;</span><br><span class="line">    Q[rear++]=end;</span><br><span class="line">    <span class="keyword">while</span>(front!=rear) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=Q[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v]!=<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Q[rear++]=v;</span><br><span class="line">            dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> S[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sap</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    BFS(start,end);</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u=start;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dep[start]&lt;N) &#123;</span><br><span class="line">        <span class="keyword">if</span>(u==end) &#123;</span><br><span class="line">            <span class="keyword">int</span> Min=INF;</span><br><span class="line">            <span class="keyword">int</span> inser;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;top;i++)</span><br><span class="line">            <span class="keyword">if</span>(Min&gt;edge[S[i]].cap-edge[S[i]].flow) &#123;</span><br><span class="line">                Min=edge[S[i]].cap-edge[S[i]].flow;</span><br><span class="line">                inser=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;top;i++) &#123;</span><br><span class="line">                edge[S[i]].flow+=Min;</span><br><span class="line">                edge[S[i]^<span class="number">1</span>].flow-=Min;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=Min;</span><br><span class="line">            top=inser;</span><br><span class="line">            u=edge[S[top]^<span class="number">1</span>].to;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i!=<span class="number">-1</span>;i=edge[i].next) &#123;</span><br><span class="line">            v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap-edge[i].flow &amp;&amp; dep[v]+<span class="number">1</span>==dep[u]) &#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                cur[u]=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            S[top++]=cur[u];</span><br><span class="line">            u=v;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Min=N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].cap-edge[i].flow &amp;&amp; dep[edge[i].to]&lt;Min) &#123;</span><br><span class="line">                Min=dep[edge[i].to];</span><br><span class="line">                cur[u]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap[dep[u]]--;</span><br><span class="line">        <span class="keyword">if</span>(!gap[dep[u]]) <span class="keyword">return</span> ans;</span><br><span class="line">        dep[u]=Min+<span class="number">1</span>;</span><br><span class="line">        gap[dep[u]]++;</span><br><span class="line">        <span class="keyword">if</span>(u!=start) u=edge[S[--top]^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> mnx,mxx;</span><br><span class="line">    <span class="keyword">int</span> u,v,cap;</span><br><span class="line">    <span class="keyword">int</span> s,t,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        init();</span><br><span class="line">        mnx=INF;mxx=-INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;mnx) &#123;</span><br><span class="line">                mnx=x;</span><br><span class="line">                s=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;mxx) &#123;</span><br><span class="line">                mxx=x;</span><br><span class="line">                t=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;cap);</span><br><span class="line">            addedge(u,v,cap);</span><br><span class="line">            addedge(v,u,cap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxflow=sap(s,t,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxflow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU4704 (Sum)[费马小定理]</title>
    <url>/archives/17120.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4704" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=4704</a></p>
<p>求解S(k)，把N分成k个数之和，问有多少种方案，这个问题等价于n个皮球分成k堆有多少种方案，套用高中学的隔板法得到公式为C(n-1, k-1)。<br>此时S(1) + S(2) + … + S(n) = C(n-1, 0) + C(n-1, 1) + … + C(n-1, n-1) = 2^(n-1)。套用费马小定理求解即可。</p>
<p><strong>费马小定理：a^(n-1)≡1 (mod n), n为质数。<br>推论：x^y≡x^(y%(n-1)) (mod n)，n为质数。</strong><br><a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100009</span>];</span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=x;y;y&gt;&gt;=<span class="number">1</span>,i=(i*i)%M) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=(ans*i)%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)) &#123;</span><br><span class="line">		ll y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i]!=<span class="string">'\0'</span>;i++) &#123;</span><br><span class="line">			y=(y*<span class="number">10</span>%(M<span class="number">-1</span>) + s[i]-<span class="string">'0'</span>)%(M<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,pow_mod(<span class="number">2</span>,y<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU5130 (Signal Interference)[计算几何，圆交多边形]</title>
    <url>/archives/54869.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5130" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=5130</a></p>
<p>首先考虑下干扰的关系，设A(x1,y1),B(x2,y2),P(x,y)，可以列出式子：<br>sqrt((x-x2)^2 + (y-y2)^2) = k * sqrt((x-x1)^2 + (y-y1)^2)<br>化简后可以得到一个圆的方程，然后就转化为圆交多边形模板题了</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp=<span class="number">509</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y) &#123;</span><br><span class="line">        x=_x;</span><br><span class="line">        y=_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hypot(x-p.x,y-p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hypot(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">len2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x*x+y*y;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function">Point <span class="title">trunc</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> l=len();</span><br><span class="line">        <span class="keyword">if</span>(!sgn(l)) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        r/=l;</span><br><span class="line">        <span class="keyword">return</span> Point(x*r,y*r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x)==<span class="number">0</span> &amp;&amp; sgn(y-b.y)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x)==<span class="number">0</span> ? sgn(y-b.y)&lt;<span class="number">0</span>:x&lt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x-b.x,y-b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> +(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x+b.x,y+b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.y-y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.x+y*b.y;</span><br><span class="line">    &#125;</span><br><span class="line">	Point <span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="keyword">double</span>&amp; k) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x*k,y*k);</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> /(<span class="keyword">const</span> <span class="keyword">double</span>&amp; k) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x/k,y/k);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotleft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(-y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotright</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(y,-x);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">rad</span><span class="params">(Point a,Point b)</span> </span>&#123;</span><br><span class="line">		Point p=*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">atan2</span>(<span class="built_in">fabs</span>((a-p)^(b-p)),(a-p)*(b-p)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">	Point s,e;</span><br><span class="line">	Line() &#123;&#125;</span><br><span class="line">	Line(Point _s,Point _e) &#123;</span><br><span class="line">		s=_s;</span><br><span class="line">		e=_e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> ==(Line v) &#123;</span><br><span class="line">		<span class="keyword">return</span> (s==v.s)&amp;&amp;(e==v.e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s.distance(e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">dispointtoline</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">fabs</span>((p-s)^(e-s)) / length();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Point <span class="title">lineprog</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s+(((e-s)*((e-s)*(p-s)))/((e-s).len2()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">circle</span> &#123;</span></span><br><span class="line">    Point p;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    circle() &#123; &#125;</span><br><span class="line">    circle(Point _p,<span class="keyword">double</span> _r) &#123;</span><br><span class="line">        p=_p;</span><br><span class="line">        r=_r;</span><br><span class="line">    &#125;</span><br><span class="line">    circle(<span class="keyword">double</span> x,<span class="keyword">double</span> y,<span class="keyword">double</span> _r) &#123;</span><br><span class="line">        p=Point(x,y);</span><br><span class="line">        r=_r;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">(Point b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> dst=b.distance(p);</span><br><span class="line">		<span class="keyword">if</span>(sgn(dst-r)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sgn(dst-r)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relationcircle</span><span class="params">(circle v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d=p.distance(v.p);</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-r-v.r)&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-r-v.r)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">double</span> l=<span class="built_in">fabs</span>(r-v.r);</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-r-v.r)&lt;<span class="number">0</span> &amp;&amp; sgn(d-l)&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-l)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sgn(d-l)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pointcrosscircle</span><span class="params">(circle v,Point&amp; p1,Point&amp; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rel=relationcircle(v);</span><br><span class="line">        <span class="keyword">if</span>(rel==<span class="number">1</span> || rel==<span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> d=p.distance(v.p);</span><br><span class="line">        <span class="keyword">double</span> l=(d*d+r*r-v.r*v.r)/(<span class="number">2</span>*d);</span><br><span class="line">        <span class="keyword">double</span> h=<span class="built_in">sqrt</span>(r*r-l*l);</span><br><span class="line">        Point tmp=p+(v.p-p).trunc(l);</span><br><span class="line">        p1=tmp+((v.p-p).rotleft().trunc(h));</span><br><span class="line">        p2=tmp+((v.p-p).rotright().trunc(h));</span><br><span class="line">        <span class="keyword">if</span>(rel==<span class="number">2</span> || rel==<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">relationline</span><span class="params">(Line v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> dst=v.dispointtoline(p);</span><br><span class="line">		<span class="keyword">if</span>(sgn(dst-r)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sgn(dst-r)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pointcrossline</span><span class="params">(Line v,Point &amp;p1,Point &amp;p2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(*<span class="keyword">this</span>).relationline(v)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		Point a=v.lineprog(p);</span><br><span class="line">		<span class="keyword">double</span> d=v.dispointtoline(p);</span><br><span class="line">		d=<span class="built_in">sqrt</span>(r*r-d*d);</span><br><span class="line">		<span class="keyword">if</span>(sgn(d)==<span class="number">0</span>) &#123;</span><br><span class="line">			p1=a;</span><br><span class="line">			p2=a;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p1=a+(v.e-v.s).trunc(d);</span><br><span class="line">		p2=a-(v.e-v.s).trunc(d);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">areatriangle</span><span class="params">(Point a,Point b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(sgn((p-a)^(p-b))==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">		Point q[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		q[len++]=a;</span><br><span class="line">		<span class="function">Line <span class="title">l</span><span class="params">(a,b)</span></span>;</span><br><span class="line">		Point p1,p2;</span><br><span class="line">		<span class="keyword">if</span>(pointcrossline(l,q[<span class="number">1</span>],q[<span class="number">2</span>])==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(sgn((a-q[<span class="number">1</span>])*(b-q[<span class="number">1</span>]))&lt;<span class="number">0</span>) q[len++]=q[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(sgn((a-q[<span class="number">2</span>])*(b-q[<span class="number">2</span>]))&lt;<span class="number">0</span>) q[len++]=q[<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		q[len++]=b;</span><br><span class="line">		<span class="keyword">if</span>(len==<span class="number">4</span> &amp;&amp; sgn((q[<span class="number">0</span>]-q[<span class="number">1</span>])*(q[<span class="number">2</span>]-q[<span class="number">1</span>]))&gt;<span class="number">0</span>) swap(q[<span class="number">1</span>],q[<span class="number">2</span>]);</span><br><span class="line">		<span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(relation(q[i])==<span class="number">0</span> || relation(q[i+<span class="number">1</span>])==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">double</span> arg=p.rad(q[i],q[i+<span class="number">1</span>]);</span><br><span class="line">				res+=r*r*arg/<span class="number">2.0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				res+=<span class="built_in">fabs</span>((q[i]-p)^(q[i+<span class="number">1</span>]-p))/<span class="number">2.0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">polygon</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	Point p[maxp];</span><br><span class="line">	Line l[maxp];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Point q)</span> </span>&#123;</span><br><span class="line">		p[n++]=q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">areacircle</span><span class="params">(circle c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> j=(i+<span class="number">1</span>)%n;</span><br><span class="line">			<span class="keyword">if</span>(sgn((p[j]-c.p)^(p[i]-c.p))&gt;=<span class="number">0</span>)</span><br><span class="line">				ans+=c.areatriangle(p[i],p[j]);</span><br><span class="line">			<span class="keyword">else</span> ans-=c.areatriangle(p[i],p[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">fabs</span>(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;poly;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cas=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">double</span> x,y,r,k;</span><br><span class="line">	<span class="keyword">double</span> x1,y1,x2,y2;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>,&amp;n,&amp;k)) &#123;</span><br><span class="line">		poly.n=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x,&amp;y);</span><br><span class="line">			poly.add(Point(x,y));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x1,&amp;y1);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x2,&amp;y2);</span><br><span class="line">		x=(x2-k*k*x1)/(<span class="number">1</span>-k*k);</span><br><span class="line">		y=(y2-k*k*y1)/(<span class="number">1</span>-k*k);</span><br><span class="line">		r=k*<span class="built_in">sqrt</span>(sqr(x1-x2)+sqr(y1-y2))/(<span class="number">1</span>-k*k);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %.10f\n"</span>,++cas,poly.areacircle(circle(x,y,r)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU5726 (GCD)[RMQ，ST算法，二分]</title>
    <url>/archives/27306.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5726" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=5726</a></p>
<p>第一问很好做，一个数与它自己的GCD仍是自己，所以区间GCD可以直接用ST表维护。<br>第二问就比较麻烦了。要做出第二问需要用到几个性质：</p>
<ul>
<li>GCD具有区间单调性（若a&lt;=c&lt;=d&lt;=b，那么GCD(a,b)&lt;=GCD(c,d)）</li>
<li>一个数的因子不超过log(n)个</li>
</ul>
<p>第一个性质使得二分区间边界成为可能，而有了第二个性质我们就可以枚举每一个左边界，并在这个左边界的前提下尽量向右「扩展」，找到GCD相同的最大的右边界，并把这个GCD下的区间数用map维护；接下来更改GCD（这里GCD是减小了）并继续向右拓展右边界，直到拓展到区间尽头，然后枚举下一个左边界并重复上述步骤。可以证明对于每个左边界，GCD相同的右边界有最多log(n)个（第二个性质）。这样整个初始化过程时间复杂度为O(n * log(n))</p>
<p>这样就统计完了每个GCD对应的区间数。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100009</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="comment">//int mm[maxn];</span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initRMQ</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mm[0]=-1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="comment">//mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1];</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">        dp[i][j]=gcd(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int k=mm[y-x+1];</span></span><br><span class="line">    <span class="keyword">int</span> k=(<span class="keyword">int</span>)(<span class="built_in">log</span>(y-x+<span class="number">1.0</span>)/<span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">    <span class="keyword">return</span> gcd(dp[x][k],dp[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bis</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> d,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=ll,r=rr,mid;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(rmq(i,mid)&gt;=d) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d=rmq(l,r);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt=M[d];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %lld\n"</span>,d,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cas=<span class="number">1</span>;cas&lt;=T;cas++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">        initRMQ(n,a);</span><br><span class="line">        M.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j,tmp;i&lt;=n;i++) &#123;</span><br><span class="line">            j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=n) &#123;</span><br><span class="line">                d=rmq(i,j);</span><br><span class="line">                tmp=bis(j,n,d,i);</span><br><span class="line">                <span class="keyword">if</span>(M[d]==<span class="number">0</span>) M[d]=tmp-j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> M[d]+=tmp-j+<span class="number">1</span>;</span><br><span class="line">                j=tmp+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,cas);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">            solve(l,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6185 (Covering)[递推，矩阵快速幂]</title>
    <url>/archives/38118.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6185" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=6185</a></p>
<p>这题比赛时猜到是矩阵快速幂了，但推公式推了好久没有推出来，比赛结束后看到有一个题解，对于填满n列的情况，只关心第n+1列露出的形状，这些形状可以分为6类，而新的一列一定是从第n+1列的这6种形状转移到第n+2列的这6种形状。这样就可以对这6种形状写出转移矩阵了。</p>
<p><em>题解链接：</em><a href="https://blog.csdn.net/a664607530/article/details/77619554" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/a664607530/article/details/77619554</a></p>
<blockquote>
<p>情况a为第n行刚好填满且没有突出到第(n + 1)行，即为所求答案，由图不难推出：<br>a[n] = a[n - 1] + b[n - 1] + c[n - 1] + dx[n - 1] + dy[n - 1]<br>b[n] = a[n - 1]<br>c[n] = a[n - 1] + e[n - 1]<br>dx[n] = a[n - 1] + dy[n - 1]<br>dy[n] = a[n - 1] + dx[n - 1]<br>e[n] = c[n - 1]<br>令d[n] = dx[n] + dy[n]<br>则 a[n] = a[n - 1] + b[n - 1] + c[n - 1] + d[n - 1]<br>b[n] = a[n - 1]<br>c[n] = a[n - 1] + e[n - 1]<br>d[n] = a[n - 1] * 2 + d[n - 1]<br>e[n] = c[n - 1]</p>
<p>根据这个构造出矩阵即可</p>
</blockquote>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>  M = <span class="number">1000000007L</span>L;</span><br><span class="line"><span class="keyword">const</span> ll matt[][<span class="number">6</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ll seqt[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> ll matat[][<span class="number">6</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ll mat[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">ll mata[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">ll seq[<span class="number">6</span>];</span><br><span class="line">ll ans[<span class="number">6</span>];</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow_mod</span><span class="params">(ll y)</span> </span>&#123;</span><br><span class="line">	ll tmp[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">while</span>(y) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">5</span>;k++)</span><br><span class="line">						tmp[i][j] = (tmp[i][j] + (mata[i][k]*mat[k][j])%M)%M;</span><br><span class="line">			<span class="built_in">memcpy</span>(mata,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">		&#125;</span><br><span class="line">		y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">5</span>;k++)</span><br><span class="line">					tmp[i][j] = (tmp[i][j] + (mat[i][k]*mat[k][j])%M)%M;</span><br><span class="line">		<span class="built_in">memcpy</span>(mat,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;n)) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(mat,matt,<span class="keyword">sizeof</span>(matt));</span><br><span class="line">		<span class="built_in">memcpy</span>(seq,seqt,<span class="keyword">sizeof</span>(seqt));</span><br><span class="line">		<span class="built_in">memcpy</span>(mata,matat,<span class="keyword">sizeof</span>(matat));</span><br><span class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pow_mod(n<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">				ans[j] = (ans[j] + (seq[i]*mata[i][j])%M)%M;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,ans[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU5984 (Pocky)[期望，微积分]</title>
    <url>/archives/28935.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5984" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=5984</a></p>
<p>题解链接：<a href="https://blog.csdn.net/toy_block/article/details/53433240" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/toy_block/article/details/53433240</a><br>第一次做连续概率的题，这里要设一个函数f(x)，代表距离右边界距离为x的点的切割次数期望为f。<br>当x &lt; d时，显然f(x)为0；当x &gt; d时，f(x)=1+x到d这一段的平均期望。注意边界条件f(d)=1。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="keyword">double</span> L,d;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;L,&amp;d) &amp;&amp; T--) &#123;</span><br><span class="line">		<span class="keyword">if</span>(L-d&lt;eps) <span class="built_in">printf</span>(<span class="string">"0.000000\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>,<span class="built_in">log</span>(L/d)+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6188 (Duizi and Shunzi)[贪心]</title>
    <url>/archives/64241.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6188" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=6188</a></p>
<p>一个对子只消耗两张牌，相对于顺子更加「实惠」。考虑这样一个贪心策略：先把每种牌能换成对子就换成对子，此时每种牌一定只有一张或零张。对于一种牌i，如果i有一张，且i+1也有一张，那么只要i+2初始时有牌就把i，i+1，i+2换成一个顺子，这样做最多是一个对子换顺子，而且可能会在i+2的位置多留出一张牌。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">		<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[a[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[i]=b[i]/<span class="number">2</span>,b[i]%=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++) </span><br><span class="line">			<span class="keyword">if</span>(b[i] &amp;&amp; b[i+<span class="number">1</span>] &amp;&amp; (b[i+<span class="number">2</span>]||cnt[i+<span class="number">2</span>])) &#123;</span><br><span class="line">				c++;</span><br><span class="line">				b[i]--;</span><br><span class="line">				b[i+<span class="number">1</span>]--;</span><br><span class="line">				<span class="keyword">if</span>(b[i+<span class="number">2</span>]) b[i+<span class="number">2</span>]--;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					cnt[i+<span class="number">2</span>]--;</span><br><span class="line">					b[i+<span class="number">2</span>]++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">int</span> ans=c;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=cnt[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6214 (Smallest Minimum Cut)[网络流，最小割边数最小]</title>
    <url>/archives/58855.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6214" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=6214</a></p>
<p>题目要求求出最小割的最少割边数。<br>可以理解为双关键字网络流，把每条边容量变成<code>cap*(E+1)+1</code>，E为边集大小（当然E+1也可以是任一个大于边集+1的数），跑一遍最大流。<br>最小割即为<code>maxflow/(E+1)</code><br>最小割边数为<code>maxflow%(E+1)</code> （可以这样理解，一条边是割边当且仅当它被取满，此时这条边容量中新加入的那个1也会被取走）</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">209</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],head[N],e[M],next2[M],ver[M];</span><br><span class="line"><span class="keyword">int</span> s,t,m,n,tot=<span class="number">1</span>,maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    ver[++tot]=v;e[tot]=w;next2[tot]=head[u];head[u]=tot;</span><br><span class="line">    ver[++tot]=u;e[tot]=<span class="number">0</span>;next2[tot]=head[v];head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    q.push(s);</span><br><span class="line">    d[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=next2[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i] &amp;&amp; !d[ver[i]]) &#123;</span><br><span class="line">                q.push(ver[i]);</span><br><span class="line">                d[ver[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(ver[i]==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rest=f;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i&amp;&amp;rest;i=next2[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] &amp;&amp; d[ver[i]]==d[x]+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> now=dinic(ver[i],min(e[i],rest));</span><br><span class="line">            <span class="keyword">if</span>(!now) d[ver[i]]=<span class="number">0</span>;</span><br><span class="line">            e[i]-=now;</span><br><span class="line">            e[i^<span class="number">1</span>]+=now;</span><br><span class="line">            rest-=now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f-rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        tot=<span class="number">1</span>;</span><br><span class="line">        maxflow=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w*(m+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(bfs())</span><br><span class="line">            <span class="keyword">while</span>(tmp=dinic(s,inf)) maxflow+=tmp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxflow%(m+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6216 (A Cubic number and A Cubic Number)做题笔记</title>
    <url>/archives/39955.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6216" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=6216</a></p>
<p>这题考察的是数学思维。</p>
<p>一开始想用打表暴力枚举出所有（满足a^3-(a-1)^3&lt;=2*10^12）的a^3，然后枚举b^3并判断b^3+p是否在枚举出的a^3中，但因为要开816498的long long数组内存吃不消，所以只能作罢。<br><a id="more"></a></p>
<p>其实这题是立方差公式: a^3-b^3=(a-b)*(a^2+a*b+b^2) 并且<strong>因为p为质数，所以a-b只能是1</strong>。此时带入a=b+1，可以得到p=3*b^2+3*b+1，枚举b就能得到答案了。</p>
<p>贴上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tmp,x;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=<span class="number">816497</span>;i++) &#123;</span><br><span class="line">			tmp=<span class="number">3</span>*i*i+<span class="number">3</span>*i+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (tmp==x) &#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (tmp&gt;x) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>HihoCoder1139 [二分]</title>
    <url>/archives/16929.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="https://hihocoder.com/problemset/problem/1139" rel="external nofollow noopener noreferrer" target="_blank">https://hihocoder.com/problemset/problem/1139</a><br>二分索敌值，用BFS遍历，判断能不能在规定步数内走到终点即可。注意不能用DFS（可能是因为路径非最短）。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,cap,next;</span><br><span class="line">&#125;edge[maxm*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,ne=<span class="number">0</span>,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edge[ne].v=v;edge[ne].cap=cap;edge[ne].next=head[u];head[u]=ne++;</span><br><span class="line">    edge[ne].v=u;edge[ne].cap=cap;edge[ne].next=head[v];head[v]=ne++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	q.push(s);</span><br><span class="line">	d.push(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front(), dep = d.front(); </span><br><span class="line">		q.pop(); d.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">			<span class="keyword">if</span> (!vis[v] &amp;&amp; edge[i].cap &lt;= mid &amp;&amp; dep+<span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">				<span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				vis[v] = <span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">				d.push(dep+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> bfs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u, v, cap;</span><br><span class="line">	<span class="keyword">int</span> maxw = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;t);</span><br><span class="line">	s = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;cap);</span><br><span class="line">		maxw = <span class="built_in">std</span>::max(maxw, cap);</span><br><span class="line">		insert(u, v, cap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = maxw;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (check()) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>二分</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6325 (Interstellar Travel)[凸包，字典序]</title>
    <url>/archives/33864.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6325" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=6325</a></p>
<p>注意观察每次移动的花费xi <em> yj - xj </em> yi，这是一个叉积。题目希望花费的负值最大，也就是所有的叉积和尽可能小。贪心考虑，我们需要让移动路线尽可能「上凸」，这样可以向顺时针转动的角度也会尽可能的大。于是维护一个上凸包即可。注意字典序的处理方式，拓展凸包时，如果在一个方向上遇到字典序较大的点，则不要弹出栈里的当前点。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200009</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y,<span class="keyword">int</span> _index=<span class="number">0</span>) &#123;</span><br><span class="line">        x=_x;</span><br><span class="line">        y=_y;</span><br><span class="line">        index=_index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hypot(x-p.x,y-p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hypot(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">trunc</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> l=len();</span><br><span class="line">        <span class="keyword">if</span>(!sgn(l)) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        r/=l;</span><br><span class="line">        <span class="keyword">return</span> Point(x*r,y*r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x)==<span class="number">0</span> &amp;&amp; sgn(y-b.y)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    bool operator &lt;(Point b) const &#123;</span></span><br><span class="line"><span class="comment">//        return sgn(x-b.x)==0 ? sgn(y-b.y)&lt;0:x&lt;b.x;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x-b.x,y-b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> +(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x+b.x,y+b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.y-y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.x+y*b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotleft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(-y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotright</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Point(y,-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">polygon</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Point p[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Point q)</span> </span>&#123;</span><br><span class="line">        p[n++]=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">        Point p;</span><br><span class="line">        cmp(<span class="keyword">const</span> Point&amp; p0) &#123; p=p0; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> Point&amp; aa,<span class="keyword">const</span> Point&amp; bb)</span> </span>&#123;</span><br><span class="line">            Point a=aa,b=bb;</span><br><span class="line">            <span class="keyword">int</span> d=sgn((a-p)^(b-p));</span><br><span class="line">            <span class="keyword">if</span>(d==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> sgn(a.distance(p)-b.distance(p)) &lt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> d &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">norm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Point mi=p[<span class="number">0</span>];</span><br><span class="line">        sort(p,p+n,cmp(mi));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(i==n<span class="number">-1</span>?<span class="string">"%d"</span>:<span class="string">"%d "</span>,p[i].index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Graham</span><span class="params">(polygon &amp;convex)</span> </span>&#123;</span><br><span class="line">        norm();</span><br><span class="line">        <span class="keyword">int</span> &amp;top=convex.n;</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">            top=<span class="number">1</span>;</span><br><span class="line">            convex.p[<span class="number">0</span>]=p[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) &#123;</span><br><span class="line">            top=<span class="number">2</span>;</span><br><span class="line">            convex.p[<span class="number">0</span>]=p[<span class="number">0</span>];</span><br><span class="line">            convex.p[<span class="number">1</span>]=p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(convex.p[<span class="number">0</span>]==convex.p[<span class="number">1</span>]) top--;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        convex.p[<span class="number">0</span>]=p[<span class="number">0</span>];</span><br><span class="line">        convex.p[<span class="number">1</span>]=p[<span class="number">1</span>];</span><br><span class="line">        top=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(top&gt;<span class="number">1</span> &amp;&amp; sgn((convex.p[top<span class="number">-1</span>]-convex.p[top<span class="number">-2</span>])</span><br><span class="line">                ^(p[i]-convex.p[top<span class="number">-2</span>]))&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(sgn((convex.p[top<span class="number">-1</span>]-convex.p[top<span class="number">-2</span>])^(p[i]-convex.p[top<span class="number">-2</span>]))==<span class="number">0</span></span><br><span class="line">                       &amp;&amp; convex.p[top<span class="number">-1</span>].index&lt;p[i].index) <span class="keyword">break</span>;</span><br><span class="line">                    top--;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(convex.p[top<span class="number">-1</span>]==p[i]))</span><br><span class="line">                convex.p[top++]=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(convex.n==<span class="number">2</span> &amp;&amp; (convex.p[<span class="number">0</span>]==convex.p[<span class="number">1</span>])) convex.n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;poly,con;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        poly.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            poly.add(Point(x,y,i));</span><br><span class="line">        &#125;</span><br><span class="line">        con.init();</span><br><span class="line">        poly.Graham(con);</span><br><span class="line">        con.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>HihoCoder1325 (Splay)[STL]</title>
    <url>/archives/65247.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://hihocoder.com/problemset/problem/1329" rel="external nofollow noopener noreferrer" target="_blank">https://hihocoder.com/problemset/problem/1329</a></p>
<p>Splay模板题，这里记录用set的<code>lower_bound</code>、<code>upper_bound</code>和<code>erase</code>的区间删除功能实现的做法。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">		<span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'I'</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">			s.insert(k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'Q'</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">			<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">			it=s.upper_bound(k);</span><br><span class="line">			it--;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(*it));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'D'</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it1;</span><br><span class="line">			<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it2;</span><br><span class="line">			it1=s.lower_bound(a);</span><br><span class="line">			it2=s.upper_bound(b);</span><br><span class="line">			s.erase(it1,it2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ1370 (Bi-shoe and Phi-shoe)[欧拉函数]</title>
    <url>/archives/30100.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="https://vjudge.net/problem/27078/origin" rel="external nofollow noopener noreferrer" target="_blank">https://vjudge.net/problem/27078/origin</a></p>
<p>Bamboo Pole-vault is a massively popular sport in Xzhiland. And Master Phi-shoe is a very popular coach for his success. He needs some bamboos for his students, so he asked his assistant Bi-Shoe to go to the market and buy them. Plenty of Bamboos of all possible integer lengths (yes!) are available in the market. According to Xzhila tradition,</p>
<p>Score of a bamboo = Φ (bamboo’s length)</p>
<p>(Xzhilans are really fond of number theory). For your information, Φ (n) = numbers less than n which are relatively prime (having no common divisor other than 1) to n. So, score of a bamboo of length 9 is 6 as 1, 2, 4, 5, 7, 8 are relatively prime to 9.</p>
<p>The assistant Bi-shoe has to buy one bamboo for each student. As a twist, each pole-vault student of Phi-shoe has a lucky number. Bi-shoe wants to buy bamboos such that each of them gets a bamboo with a score greater than or equal to his/her lucky number. Bi-shoe wants to minimize the total amount of money spent for buying the bamboos. One unit of bamboo costs 1 Xukha. Help him.</p>
<a id="more"></a>
<p><strong>Input</strong></p>
<p>Input starts with an integer T (≤ 100), denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer n (1 ≤ n ≤ 10000) denoting the number of students of Phi-shoe. The next line contains n space separated integers denoting the lucky numbers for the students. Each lucky number will lie in the range [1, 106].</p>
<p><strong>Output</strong></p>
<p>For each case, print the case number and the minimum possible money spent for buying the bamboos. See the samples for details.</p>
<p><strong>Sample Input</strong></p>
<p>3<br>5<br>1 2 3 4 5<br>6<br>10 11 12 13 14 15<br>2<br>1 1</p>
<p><strong>Sample Output</strong></p>
<p>Case 1: 22 Xukha<br>Case 2: 88 Xukha<br>Case 3: 4 Xukha</p>
<p>这题是欧拉函数，先生成phi表，然后暴力枚举，注意phi表是不单调的，所以枚举的时候需要把输入排个序。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1100009</span>;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *phi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) phi[i]=<span class="number">0</span>;</span><br><span class="line">	phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="keyword">if</span> (!phi[i])</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;=n;j+=i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!phi[j]) phi[j]=j;</span><br><span class="line">			phi[j]=phi[j]/i*(i<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T,n;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	phi_table(N<span class="number">-1</span>,phi);</span><br><span class="line">	<span class="comment">//phi[1]=0;</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> z=<span class="number">1</span>;z&lt;=T;z++) &#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		<span class="built_in">std</span>::sort(a,a+n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">2</span>;i&lt;n;) &#123;</span><br><span class="line">			<span class="keyword">if</span> (phi[j]&gt;=a[i]) &#123;</span><br><span class="line">				ans+=j;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld Xukha\n"</span>,z,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2015跳石头 做题笔记</title>
    <url>/archives/58936.html</url>
    <content><![CDATA[<p>这题是二分+贪心，关键在于贪心策略，移走石头即合并线段，从左向右扫描一个坐标区间，如果长度合适（大于等于二分的答案）就移动左端点，不合适就固定左端点同时进行一次合并（计数器加一），如果合并次数在m以内就认为存在一个方案。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50009</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="keyword">int</span> L, m, n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i] - left &lt; mid) cnt++;</span><br><span class="line">        <span class="keyword">else</span> left = d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;L, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, d + i);</span><br><span class="line">    &#125;</span><br><span class="line">    d[n + <span class="number">1</span>] = L;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = L;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1088 (滑雪)做题笔记</title>
    <url>/archives/35486.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·</p>
<p>这题是记忆化搜索。<br>因为高度的缘故所有走过的路一定不会再走一次，可以判断从每个点所能走的最远距离和已走路程是无关的，因而对于每一个点可以递归查询垓点可以走到的最远距离，在回溯前记录当前点能走到的最远距离即可。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> mdis[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (mdis[x][y]) <span class="keyword">return</span> mdis[x][y];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x+dx[i]&gt;=<span class="number">0</span>&amp;&amp;x+dx[i]&lt;n&amp;&amp;y+dy[i]&gt;=<span class="number">0</span>&amp;&amp;y+dy[i]&lt;m</span><br><span class="line">				&amp;&amp;<span class="built_in">map</span>[x][y]&gt;<span class="built_in">map</span>[x+dx[i]][y+dy[i]]) &#123;</span><br><span class="line">			ans=<span class="built_in">std</span>::max(ans,dfs(x+dx[i],y+dy[i]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mdis[x][y]=ans+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> mdis[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) </span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">			x=dfs(i,j);</span><br><span class="line">			ans=<span class="built_in">std</span>::max(x,ans);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1061 (青蛙的约会)做题笔记</title>
    <url>/archives/11370.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=1061" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1061</a><br>这题是拓展欧几里得算法。</p>
<h2 id="裴蜀等式"><a href="#裴蜀等式" class="headerlink" title="裴蜀等式"></a>裴蜀等式</h2><blockquote>
<p>任何整数a、b和m，关于未知数x和y的线性丢番圆方程（称为裴蜀等式）：<br><strong>ax+by=m</strong><br>有整数解时当且仅当m是a和b的最大公约数d的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数<br>——引用自维基百科</p>
</blockquote>
<blockquote>
<p>若方程ax+by=m的一组整数解为(x0,y0),则它的任意整数解都可以写成(x0+kb’,y0-ka’)，其中a’=a/gcd(a,b)，b’=b/gcd(a,b)，k取任意整数</p>
</blockquote>
<h2 id="模线线性方程组"><a href="#模线线性方程组" class="headerlink" title="模线线性方程组"></a>模线线性方程组</h2><blockquote>
<p>ax≡b(mod n)<br>ax=b+ny<br>ax-ny=b 进而转化为裴蜀等式<br>补充：当b等于1时模线性方程组的解是a关于模n的逆，a关于模n的逆存在当且仅当a和n互质，此时方程有唯一解</p>
</blockquote>
<h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>根据题意可以写出等式(x+km)%L=(y+kn)%L<br>而这样的式子有一个性质a%L=b%L ==&gt; (a+c)%L=(b+c)%L<br>因而可以得出(k(m-n))%L=(y-x)%L<br>k(m-n)≡y-x(mod L) 接下来就可以用解模线性方程组的方法来做了<br>需要注意m-n必须是非负的</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">LL x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;d,LL &amp;x,LL &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123; d=a;x=<span class="number">1</span>;y=<span class="number">0</span>; &#125; <span class="keyword">else</span></span><br><span class="line">	&#123; exgcd(b,a%b,d,y,x);y-=x*(a/b); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">linear_equation</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	exgcd(a,b,d,x,y);</span><br><span class="line">	<span class="keyword">if</span> (c%d) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	x*=c/d;</span><br><span class="line">	y*=c/d;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m,n,a,b,L;</span><br><span class="line">	<span class="keyword">bool</span> opt;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;m,&amp;n,&amp;L);</span><br><span class="line">	<span class="keyword">if</span> (m&lt;n) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(m,n);</span><br><span class="line">		<span class="built_in">std</span>::swap(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	opt=linear_equation(m-n,L,b-a);</span><br><span class="line">	<span class="keyword">if</span> (opt) &#123;</span><br><span class="line">		<span class="keyword">while</span> (x&gt;<span class="number">0</span>) x-=L/d;</span><br><span class="line">		<span class="keyword">while</span> (x&lt;<span class="number">0</span>) x+=L/d;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld"</span>,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>数论</tag>
        <tag>拓展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1127 (Jack Straws)[计算几何，Floyd]</title>
    <url>/archives/27618.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接</strong><a href="http://poj.org/problem?id=1127" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1127</a></p>
<p>题目涉及两个问题：1、判断两个线段是否直接相交（跨立的规范相交或一直线端点在另一直线上的非规范相交） 2、判断两个线段是否能够间接相交</p>
<p>解决第一个问题可以n^2的两两比较一遍，套用计算几何的相交模板即可，第二个问题可以用Floyd传递闭包来解决。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1e20</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">	Point() &#123;&#125;</span><br><span class="line">	Point(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y) &#123;</span><br><span class="line">		x = _x;</span><br><span class="line">		y = _y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x * b.y - y * b.x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x*b.x + y*b.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">	Point s, e;</span><br><span class="line">	Line() &#123;&#125;</span><br><span class="line">	Line(Point _s, Point _e) &#123;</span><br><span class="line">		s = _s;</span><br><span class="line">		e = _e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		s.input();</span><br><span class="line">		e.input();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">segcrossseg</span><span class="params">(Line v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> d1 = sgn((e-s) ^ (v.s-s));</span><br><span class="line">		<span class="keyword">int</span> d2 = sgn((e-s) ^ (v.e-s));</span><br><span class="line">		<span class="keyword">int</span> d3 = sgn((v.e-v.s) ^ (s-v.s));</span><br><span class="line">		<span class="keyword">int</span> d4 = sgn((v.e-v.s) ^ (e-v.s));</span><br><span class="line">		<span class="keyword">if</span> ((d1^d2) == <span class="number">-2</span> &amp;&amp; (d3^d4) == <span class="number">-2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> (d1==<span class="number">0</span> &amp;&amp; sgn((v.s-s)*(v.s-e))&lt;=<span class="number">0</span>) ||</span><br><span class="line">				(d2==<span class="number">0</span> &amp;&amp; sgn((v.e-s)*(v.e-e))&lt;=<span class="number">0</span>) ||</span><br><span class="line">				(d3==<span class="number">0</span> &amp;&amp; sgn((s-v.s)*(s-v.e))&lt;=<span class="number">0</span>) ||</span><br><span class="line">				(d4==<span class="number">0</span> &amp;&amp; sgn((e-v.s)*(e-v.e))&lt;=<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> map_size = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">int</span> m[map_size][map_size];</span><br><span class="line">Line lines[map_size];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">if</span> (m[i][j] &gt; m[i][k] + m[k][j])</span><br><span class="line">					m[i][j] = m[i][k] + m[k][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map_size; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map_size; j++)</span><br><span class="line">				m[i][j] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			lines[i].input();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">if</span> (lines[i].segcrossseg(lines[j]) &gt; <span class="number">0</span>)</span><br><span class="line">					m[i][j] = <span class="number">0</span>;</span><br><span class="line">		floyd();</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b)==<span class="number">2</span> &amp;&amp; !(a==<span class="number">0</span> &amp;&amp; b==<span class="number">0</span>)) &#123;</span><br><span class="line">			m[a][b] == <span class="number">0</span> ? <span class="built_in">printf</span>(<span class="string">"CONNECTED\n"</span>) : <span class="built_in">printf</span>(<span class="string">"NOT CONNECTED\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>Floyd</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1131 (Octal Fractions) [进制转换]</title>
    <url>/archives/30851.html</url>
    <content><![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=1131" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1131</a></p>
<blockquote>
<p>八进制与十进制的转换，如有小数部分，对应乘相应8的-i次方【字母O，表示八进制】<br>245O = 3x8^2+4x8^1+5x8^0 = 229</p>
<p>引用自<a href="https://blog.csdn.net/Jishu360/article/details/8112950" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/Jishu360/article/details/8112950</a></p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		String s=<span class="keyword">null</span>;</span><br><span class="line">		BigDecimal r = BigDecimal.valueOf(<span class="number">0.125</span>);</span><br><span class="line">		BigDecimal ans = BigDecimal.ZERO;</span><br><span class="line">		<span class="keyword">while</span>(in.hasNext()) &#123;</span><br><span class="line">			s = in.next();</span><br><span class="line">			r = BigDecimal.valueOf(<span class="number">0.125</span>);</span><br><span class="line">			ans = BigDecimal.ZERO;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">				ans = ans.add(BigDecimal.valueOf(s.charAt(i) - <span class="string">'0'</span>).multiply(r));</span><br><span class="line">				r=r.multiply(BigDecimal.valueOf(<span class="number">0.125</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(s+<span class="string">" [8] = "</span>+ans+<span class="string">" [10]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1182[NOI2001]食物链 做题笔记</title>
    <url>/archives/48196.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=1182" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1182</a><br><strong>参考博客：</strong><a href="https://azraeldeath.github.io/POJ1182%20%E3%80%90NOI2001%E3%80%91%20%E9%A3%9F%E7%89%A9%E9%93%BE%20%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="external nofollow noopener noreferrer" target="_blank">Azrael_Death的博客</a></p>
<p>以下引用自Azrael_Death大神：</p>
<blockquote>
<p>逻辑推理的题有一部分和并查集有关，此题是种类并查集的经典例题。<br>首先我们<strong>把每个动物分成三个点</strong>，对于点i，点i表示第i个动物的种类，点i+n表示第i个动物的食物，点i+2n表示第i个动物的天敌。<br>这样一来，提供信息：x和y同类，相当于提供三条信息：<br>1.x、y在同一个集中<br>2.x+n、y+n在同一个集中<br>3.x+2n、y+2n在同一个集中<br>于是我们merge(x, y), merge(x+n, y+n), merge(x+2n, y+2n);<br>同理，提供信息：x吃y，相当于提供三条信息：<br>1.x、y+2n在同一个集中<br>2.x+n、y在同一个集中<br>3.x+2n、y+n在同一个集中<br>于是我们merge(x, y+2n), merge(x+n, y), merge(x+2n, y+n);<br>如果在接到信息x和y同类后，发现x和y+n同类或x和y+2n同类，则此信息与先前信息矛盾。因为对称性，我们不用再判断y是否和x+n或x+2n同类。同理可处理x吃y的情况。</p>
</blockquote>
<p>感觉最重要的思想是那个拆点。。这样就把各种关系具体化了<br><a id="more"></a></p>
<p>然后贴上自己的代码。。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">50009</span>*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fa[x]!=x) fa[x]=getfa(fa[x]);<span class="comment">//return (fa[x]=getfa(fa[x]));不理解为什么用注释部分替换掉return语句后运行不出正确结果</span></span><br><span class="line">	<span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ancx=getfa(x);</span><br><span class="line">	<span class="keyword">int</span> ancy=getfa(y);</span><br><span class="line">	<span class="keyword">if</span> (ancx!=ancy) fa[ancx]=ancy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d,x,y,tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">3</span>;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;d,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span> (x&gt;n||y&gt;n) &#123;</span><br><span class="line">			tot++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (d==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (getfa(x)==getfa(y+n)||getfa(x)==getfa(y+<span class="number">2</span>*n)</span><br><span class="line">				||x&gt;n||y&gt;n) tot++;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				merge(x,y);</span><br><span class="line">				merge(x+n,y+n);</span><br><span class="line">				merge(x+<span class="number">2</span>*n,y+<span class="number">2</span>*n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (getfa(x)==getfa(y)||getfa(x)==getfa(y+n)</span><br><span class="line">				||x&gt;n||y&gt;n||x==y) tot++;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				merge(x,y+<span class="number">2</span>*n);</span><br><span class="line">				merge(x+n,y);</span><br><span class="line">				merge(x+<span class="number">2</span>*n,y+n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,tot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1442 (Black Box)做题笔记</title>
    <url>/archives/25507.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=1442" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1442</a></p>
<p>这题题意是给定两个序列，第一个序列是输入序列，第二个序列是询问序列，第二个序列的第i个数bi是询问输入第bi个数时黑盒的第i小</p>
<p>乍一看每次询问第i小好像需要用平衡树，但其实这题可以用priority_queue直接水过去，创建两个priority_queue，小根堆中存的数大于大根堆中存的数。严格保持大根堆有i个数，这样小根堆中的根就是整个黑盒的第i+1大了。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">30009</span>;</span><br><span class="line"><span class="keyword">int</span> a[M];</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; big;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt; &gt; small;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">		<span class="keyword">for</span> (;pos&lt;t;pos++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!small.empty()&amp;&amp;small.top()&gt;a[pos]) &#123;</span><br><span class="line">				small.push(a[pos]);</span><br><span class="line">				tmp=small.top();</span><br><span class="line">				small.pop();</span><br><span class="line">				big.push(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> big.push(a[pos]);<span class="comment">//,printf("%d %d*\n",a[pos]);</span></span><br><span class="line">		&#125;</span><br><span class="line">		tmp=big.top();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tmp);</span><br><span class="line">		small.push(tmp);</span><br><span class="line">		big.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1365 (Prime Land)做题笔记</title>
    <url>/archives/3926.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=1365" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1365</a></p>
<p>这题是质因数分解，首先生成一个素数表，然后通过这个表来找出x-1的每个质因数以及质因数的次数。需要注意的一点是不同于一般的筛法，这个生成素数表的算法要枚举出范围内所有的素数，因而第一层循环不能只循环到sqrt(r)，而必须需要循环到r。另外在对x-1做质因数分解的时候不要忽略x-1是大质数的情况。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">32768</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[N];</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fac[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> cn=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="keyword">sizeof</span>(prime));</span><br><span class="line">	<span class="built_in">memset</span>(primes,<span class="number">0</span>,<span class="keyword">sizeof</span>(primes));</span><br><span class="line">	t=<span class="number">0</span>;</span><br><span class="line">	prime[<span class="number">0</span>]=<span class="number">1</span>; prime[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="keyword">if</span> (!prime[i]) &#123;</span><br><span class="line">			primes[t++]=i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=i*i;j&lt;=r;j+=i)</span><br><span class="line">				prime[j]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,tmppow;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	get_prime(<span class="number">32767</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">		<span class="keyword">if</span> (x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;y);</span><br><span class="line">		tmppow=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;y;i++) tmppow*=x;</span><br><span class="line">		sum*=tmppow;</span><br><span class="line">		ch=getchar();</span><br><span class="line">		<span class="keyword">if</span> (ch==<span class="string">'\n'</span>) &#123;</span><br><span class="line">			sum--;</span><br><span class="line">			<span class="keyword">int</span> m=<span class="built_in">sqrt</span>(sum);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t&amp;&amp;sum&gt;<span class="number">1</span>;i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (sum%primes[i]==<span class="number">0</span>) &#123;</span><br><span class="line">					fac[cn]=primes[i];</span><br><span class="line">					cnt[cn]++;</span><br><span class="line">					sum/=primes[i];</span><br><span class="line">					<span class="keyword">while</span> (sum%primes[i]==<span class="number">0</span>) &#123;</span><br><span class="line">						cnt[cn]++;</span><br><span class="line">						sum/=primes[i];</span><br><span class="line">					&#125;</span><br><span class="line">					cn++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=cn<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">"%d %d "</span>,fac[i],cnt[i]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,fac[<span class="number">0</span>],cnt[<span class="number">0</span>]);</span><br><span class="line">			cn=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(fac,<span class="number">0</span>,<span class="keyword">sizeof</span>(fac));</span><br><span class="line">			<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">			sum=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>数论</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1696 (Space Ant)[计算几何]</title>
    <url>/archives/5384.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=1696" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1696</a></p>
<p>这题比较容易想到贪心策略：每次只找当前结点需要向逆时针转最小角度能到达的点即可。每次拓展一个点之后以当前结点为基准对其它点进行极角排序，并找到第一个从当前结点旋转方向为逆时针并没被访问过的点拓展即可。</p>
<p>但有一个坑点：极角排序时如果当前基准点位于许多点中间而非它们的边界上，那么极角序并不是唯一的（极角序转过360度依次减小<strong>形成了一个环</strong>），此时排序的结果是不可用的，因此要在排序前去掉所有在当前结点（准确地说是当前边）顺时针方向的点。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">109</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp=<span class="number">59</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y,<span class="keyword">int</span> _index=<span class="number">0</span>) &#123;</span><br><span class="line">        x=_x;</span><br><span class="line">        y=_y;</span><br><span class="line">        index=_index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.y-y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x-b.x,y-b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x) == <span class="number">0</span> &amp;&amp; sgn(y-b.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.x+y*b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hypot(x-p.x,y-p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x)==<span class="number">0</span> ? sgn(y-b.y)&lt;<span class="number">0</span> : x&lt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">polygon</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n,n2;</span><br><span class="line">    Point p[maxp];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxp];</span><br><span class="line">    <span class="keyword">int</span> seq[maxp],t;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Point q)</span> </span>&#123;</span><br><span class="line">        p[n++]=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">        Point p;</span><br><span class="line">        cmp(<span class="keyword">const</span> Point &amp;p0) &#123; p=p0; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Point &amp;aa,<span class="keyword">const</span> Point &amp;bb)</span> </span>&#123;</span><br><span class="line">            Point a=aa,b=bb;</span><br><span class="line">            <span class="keyword">int</span> d=sgn((a-p)^(b-p));</span><br><span class="line">            <span class="keyword">if</span>(d==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> sgn(a.distance(p)-b.distance(p)) &lt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> d&gt;<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">norm</span><span class="params">(Point start,Point lim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[p[i].index] || sgn(lim^(p[i]-start))&lt;<span class="number">0</span>) swap(p[i],p[n<span class="number">-1</span>]),n--;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+n,cmp(start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Point start=Point(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        Point lim=Point(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(sgn(start.y-p[i].y)==<span class="number">0</span> ? sgn(start.x-p[i].x)&lt;<span class="number">0</span> : start.y&lt;p[i].y)) &#123;</span><br><span class="line">                start=p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[start.index]=<span class="literal">true</span>;</span><br><span class="line">        seq[t++]=start.index;</span><br><span class="line">        Point nex;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            norm(start,lim);</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[p[i].index] &amp;&amp; sgn(lim^(p[i]-start))&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    nex=p[i];</span><br><span class="line">                    vis[p[i].index]=<span class="number">1</span>;</span><br><span class="line">                    seq[t++]=p[i].index;</span><br><span class="line">                    lim=nex-start;</span><br><span class="line">                    start=nex;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++) <span class="built_in">printf</span>(i==t<span class="number">-1</span>? <span class="string">"%d"</span> :<span class="string">"%d "</span>,seq[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;poly;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> index,x,y;</span><br><span class="line">    <span class="keyword">int</span> miy;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        poly.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;index,&amp;x,&amp;y);</span><br><span class="line">            poly.add(Point(x,y,index));</span><br><span class="line">        &#125;</span><br><span class="line">        poly.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1700 (Crossing River)[贪心]</title>
    <url>/archives/52670.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=1700" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1700</a></p>
<p>思路引用自<a href="https://blog.csdn.net/u014492609/article/details/40918435" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u014492609/article/details/40918435</a></p>
<blockquote>
<p>当n=1,2,3时所需要的最小时间很容易求得,现在由n&gt;=4,假设n个人单独过河所需要的时间存储在数组t中,将数组t按升序排序,那么 这时将单独过河所需要时间最多的两个旅行者送到对岸去,有两种方式:</p>
<ol>
<li>最快的(即所用时间t[0])和次快的过河,然后最快的将船划回来,再次慢的和最慢的过河,然后次快的将船划回来。即所需时间为:t[0]+2*t[1]+t[n-1]</li>
<li>最快的和最慢的过河,然后最快的将船划回来,再最快的和次慢的过河,然后最快的将船划回来,即所需时间为:2*t[0]+t[n-2]+t[n-1]</li>
</ol>
</blockquote>
<p>注意这两种过河方式是两种最优的过河方式，每一次过河都应该判断具体采用哪一种。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1009</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T,f,s;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(a[<span class="number">1</span>],a[<span class="number">2</span>]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[<span class="number">1</span>]+a[<span class="number">2</span>]+a[<span class="number">3</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">			f=a[<span class="number">1</span>];</span><br><span class="line">			s=a[<span class="number">2</span>];</span><br><span class="line">			r=n;</span><br><span class="line">			<span class="keyword">while</span>(r&gt;<span class="number">3</span>) &#123;</span><br><span class="line">				ans+=min(s+f+a[r]+s,a[r]+f+a[r<span class="number">-1</span>]+f);</span><br><span class="line">				r-=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans+=a[<span class="number">1</span>]+a[<span class="number">2</span>]+a[<span class="number">3</span>];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">			f=a[<span class="number">1</span>];</span><br><span class="line">			s=a[<span class="number">2</span>];</span><br><span class="line">			r=n;</span><br><span class="line">			<span class="keyword">while</span>(r&gt;<span class="number">2</span>) &#123;</span><br><span class="line">				ans+=min(s+f+a[r]+s,a[r]+f+a[r<span class="number">-1</span>]+f);</span><br><span class="line">				r-=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans+=s;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1731 (Orders)做题笔记</title>
    <url>/archives/16178.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=1731" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1731</a><br>STL中的next_permutation，作用是生成当前序列的字典序较大的下一个序列，如果能生成则返回true，否则返回false。<br>还有一个反向的函数prev_permutation。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">	sort(str.begin(),str.end());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span>(next_permutation(str.begin(),str.end())) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2187 (Beauty Contest)[凸包，旋转卡壳，平面最远点对]</title>
    <url>/archives/28516.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=2187" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=2187</a></p>
<blockquote>
<p>首先，距离最大的点对一定都在凸包上。<br>若凸包上两个顶点能落在一对平行切线上，则称他们为对踵点。<br>显然，答案一定取在一组对踵点对。<br>如何做？<br>类似双指针<br>枚举凸包上的边，找出距离此边最远的点，因为<strong>凸包上点到边距离为单峰函数，也就是说点到边构成的三角形面积是单峰函数</strong>，因此可以利用叉积比较面积。<br>注意：不能枚举凸包上的点（而不是枚举边），用上述做法找出距离此固定点最远的点。因为不满足最重要的单峰性<br>引用自HIT_Tom课件</p>
</blockquote>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200009</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y) &#123;</span><br><span class="line">        x=_x;</span><br><span class="line">        y=_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqr(p.x-x)+sqr(p.y-y);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    double len() &#123;</span></span><br><span class="line"><span class="comment">//        return hypot(x,y);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dis2</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqr(p.x-x)+sqr(p.y-y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x)==<span class="number">0</span> &amp;&amp; sgn(y-b.y)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x)==<span class="number">0</span> ? sgn(y-b.y)&lt;<span class="number">0</span>:x&lt;b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x-b.x,y-b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> +(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x+b.x,y+b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.y-y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Point&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.x+y*b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">polygon</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Point p[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Point q)</span> </span>&#123;</span><br><span class="line">        p[n++]=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i+<span class="number">1</span>)%n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">abs</span>((p[nex(i)]-p[i])^(p[nex(j)]-p[i])) &gt; <span class="built_in">abs</span>((p[nex(i)]-p[i])^(p[j]-p[i])))</span><br><span class="line">                j=nex(j);</span><br><span class="line">            ans=max(ans,p[i].dis2(p[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">        Point p;</span><br><span class="line">        cmp(<span class="keyword">const</span> Point&amp; p0) &#123; p=p0; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> Point&amp; aa,<span class="keyword">const</span> Point&amp; bb)</span> </span>&#123;</span><br><span class="line">            Point a=aa,b=bb;</span><br><span class="line">            <span class="keyword">int</span> d=sgn((a-p)^(b-p));</span><br><span class="line">            <span class="keyword">if</span>(d==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> sgn(a.distance(p)-b.distance(p)) &lt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> d &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">norm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Point mi=p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) mi=min(mi,p[i]);</span><br><span class="line">        sort(p,p+n,cmp(mi));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Graham</span><span class="params">(polygon &amp;convex)</span> </span>&#123;</span><br><span class="line">        norm();</span><br><span class="line">        <span class="keyword">int</span> &amp;top=convex.n;</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">            top=<span class="number">1</span>;</span><br><span class="line">            convex.p[<span class="number">0</span>]=p[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) &#123;</span><br><span class="line">            top=<span class="number">2</span>;</span><br><span class="line">            convex.p[<span class="number">0</span>]=p[<span class="number">0</span>];</span><br><span class="line">            convex.p[<span class="number">1</span>]=p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(convex.p[<span class="number">0</span>]==convex.p[<span class="number">1</span>]) top--;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        convex.p[<span class="number">0</span>]=p[<span class="number">0</span>];</span><br><span class="line">        convex.p[<span class="number">1</span>]=p[<span class="number">1</span>];</span><br><span class="line">        top=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(top&gt;<span class="number">1</span> &amp;&amp; sgn((convex.p[top<span class="number">-1</span>]-convex.p[top<span class="number">-2</span>])</span><br><span class="line">                ^(p[i]-convex.p[top<span class="number">-2</span>]))&lt;=<span class="number">0</span>)</span><br><span class="line">                    top--;</span><br><span class="line">            convex.p[top++]=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(convex.n==<span class="number">2</span> &amp;&amp; (convex.p[<span class="number">0</span>]==convex.p[<span class="number">1</span>])) convex.n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;poly,con;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    poly.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        poly.add(Point(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    con.init();</span><br><span class="line">    poly.Graham(con);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,con.getans());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>旋转卡壳</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1934 (Trip)[LCS，DFS]</title>
    <url>/archives/3826.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=1934" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=1934</a></p>
<blockquote>
<p>先用动态规划求两个字符串的最长公共子序列的保存在dp[i][j];dp[i][j]表示s1字符串1到i和s2字符串1到j的最长公共子序列的长度</p>
</blockquote>
<blockquote>
<p>然后用两个变量last1[i][j],last2[i][j]来分别保存字符j(a的序号为0，b的序号为1，…..z的序号为25)在字符串1-i中出现的最大标号，要是字符j没有出现,则last[i][j]= 0;</p>
</blockquote>
<blockquote>
<p>然后从两个字符串的长度len1和len2开始枚举a—z字符,比如开始 t1 = last1[len1][0], t2 = last2[len2][0]表示a在s1字符串1—len1的最大下标为t1, 在s2字符串1–len2的最大下标为t2，那么若dp[t1][t2] 的值为s1和s2的最大公共子序列长度cnt则表示这个字符符合，保存起来，否则枚举下一个字符b。若满足情况的话，在继续在t1-1 和 t2 - 1 符合最大公共子序列为cnt - 1的字符串保存，如此循环，知道到达最长公共子序列为0时结束。把保存的字符串放入set集合里面，让它按字典序排序。<br>引用自<a href="https://blog.csdn.net/xiaoxiaoluo/article/details/8169533" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/xiaoxiaoluo/article/details/8169533</a></p>
</blockquote>
<p>动态规划具有重叠子问题的特性，dp数组只保留了相当有限的信息。为了求出所有满足条件的子序列，必须另开一个数组维护信息。<br>另外实现上有一个小细节出错了，就是<code>s[i]</code>下标从0开始，<code>dp[i][j]</code>下标从1开始，一开始混在一起了。<br><a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">100</span>],s2[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">81</span>][<span class="number">81</span>];</span><br><span class="line"><span class="keyword">int</span> last1[<span class="number">81</span>][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> last2[<span class="number">81</span>][<span class="number">26</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">string</span> ss=str+<span class="number">1</span>;	</span><br><span class="line">		ans.insert(ss);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t1=last1[p1][i];</span><br><span class="line">		<span class="keyword">int</span> t2=last2[p2][i];</span><br><span class="line">		<span class="keyword">if</span>(x==f[t1][t2]) &#123;</span><br><span class="line">			str[x]=i+<span class="string">'a'</span>;</span><br><span class="line">			dfs(t1<span class="number">-1</span>,t2<span class="number">-1</span>,x<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s1);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s2);</span><br><span class="line">	<span class="keyword">int</span> l1=<span class="built_in">strlen</span>(s1);</span><br><span class="line">	<span class="keyword">int</span> l2=<span class="built_in">strlen</span>(s2);</span><br><span class="line">	<span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l1;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=l2;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]) f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> f[i][j]=max(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]);</span><br><span class="line">			mx=max(f[i][j],mx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l1;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s1[i<span class="number">-1</span>]==<span class="string">'a'</span>+j) last1[i][j]=i;</span><br><span class="line">			<span class="keyword">else</span> last1[i][j]=last1[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l2;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s2[i<span class="number">-1</span>]==<span class="string">'a'</span>+j) last2[i][j]=i;</span><br><span class="line">			<span class="keyword">else</span> last2[i][j]=last2[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">	dfs(l1,l2,mx);</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span>(it=ans.begin();it!=ans.end();it++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (*it) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2318 (TOYS)[计算几何]</title>
    <url>/archives/27586.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=2318" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=2318</a><br>这题是计算几何题，需要用到叉积判断点在线段的左边还是右边。<br>暴力的话n^2的复杂度应该会超时，这里用了二分的方法。把地图的左右边界各自作为一条直线插入，并且考虑到存在点落在边界的情况，这两条新加的直线要对应向地图外偏移一点。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1e20</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">	Point() &#123;&#125;</span><br><span class="line">	Point(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y) &#123;</span><br><span class="line">		x = _x;</span><br><span class="line">		y = _y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">	&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Point(x - b.x, y - b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x * b.y - y * b.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">	Point s, e;</span><br><span class="line">	Line() &#123;&#125;</span><br><span class="line">	Line(Point _s, Point _e) &#123;</span><br><span class="line">		s = _s;</span><br><span class="line">		e = _e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">		s.x = x1;</span><br><span class="line">		s.y = y1;</span><br><span class="line">		e.x = x2;</span><br><span class="line">		e.y = y2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = sgn((p-s) ^ (e-s));</span><br><span class="line">		<span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">Line lines[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid, Point now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lines[mid].relation(now) == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">	<span class="keyword">int</span> U, L;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)!=EOF &amp;&amp; n) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		lines[<span class="number">0</span>].input(x1<span class="number">-1</span>, y1, x1<span class="number">-1</span>, y2);</span><br><span class="line">		lines[n+<span class="number">1</span>].input(x2+<span class="number">1</span>, y1, x2+<span class="number">1</span>, y2);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;U, &amp;L);</span><br><span class="line">			lines[i].input(U, y1, L, y2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			Point now;</span><br><span class="line">			now.input();</span><br><span class="line">			<span class="keyword">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(l &lt; r<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (check(mid, now)) r = mid;</span><br><span class="line">				<span class="keyword">else</span> l = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			cnt[l]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, i, cnt[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2391 (Ombrophobic Bovines)[网络流，二分，Floyd]</title>
    <url>/archives/19428.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=2391" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=2391</a></p>
<p>这题一开始想成了费用流，不过应该有些细节没考虑到，一直WA。<br>这题的做法是二分网络流，先用Floyd预处理出任意两个结点的距离，二分这个距离，在跑最大流时只走小于这个距离的边，找到最大流能等于奶牛数的最小距离即可。<br>有个细节需要注意，结点是需要拆成入点和出点的，超级源向入点连边，出点向超级汇点连边，出点向入点连距离为最小距离容量为INF的边，这样能防止一些比较奇怪的问题，比如最小距离叠加到新的最小距离上了。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">1000000000L</span>L*<span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x7fffffff</span>,N=<span class="number">409</span>,M=<span class="number">400009</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],head[M],e[M],next[M],ver[M];</span><br><span class="line"><span class="keyword">int</span> et[M];</span><br><span class="line"><span class="keyword">int</span> s,t,m,n,tot=<span class="number">1</span>;</span><br><span class="line">ll dis[<span class="number">209</span>][<span class="number">209</span>];</span><br><span class="line">ll ed[M];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,ll dd=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    ver[++tot]=v;ed[tot]=dd;e[tot]=w;next[tot]=head[u];head[u]=tot;</span><br><span class="line">    ver[++tot]=u;ed[tot]=dd;e[tot]=<span class="number">0</span>;next[tot]=head[v];head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    q.push(s); d[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=next[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i]&amp;&amp;!d[ver[i]]&amp;&amp;ed[i]&lt;=mid) &#123;</span><br><span class="line">                q.push(ver[i]);</span><br><span class="line">                d[ver[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(ver[i]==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,ll mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rest=f;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i&amp;&amp;rest;i=next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]&amp;&amp;d[ver[i]]==d[x]+<span class="number">1</span>&amp;&amp;ed[i]&lt;=mid) &#123;</span><br><span class="line">            <span class="keyword">int</span> now=dinic(ver[i],min(e[i],rest),mid);</span><br><span class="line">            <span class="keyword">if</span>(!now) d[ver[i]]=<span class="number">0</span>;</span><br><span class="line">            e[i]-=now;</span><br><span class="line">            e[i^<span class="number">1</span>]+=now;</span><br><span class="line">            rest-=now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f-rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(e,et,<span class="keyword">sizeof</span>(et));</span><br><span class="line">    <span class="keyword">while</span>(bfs(mid))</span><br><span class="line">        <span class="keyword">while</span>(tmp=dinic(s,inf,mid)) maxflow+=tmp;</span><br><span class="line">    <span class="keyword">return</span> maxflow==cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cm;</span><br><span class="line">    <span class="keyword">int</span> cow,shel;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;cm);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(i!=j) dis[i][j]=INF;</span><br><span class="line">        <span class="keyword">else</span> dis[i][j]=<span class="number">0</span>;</span><br><span class="line">    s=<span class="number">0</span>;</span><br><span class="line">    t=n*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;cow,&amp;shel);</span><br><span class="line">        cnt+=cow;</span><br><span class="line">        <span class="keyword">if</span>(cow&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            add(s,i,cow);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(shel&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            add(i+n,t,shel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cm;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%I64d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        dis[u][v]=dis[v][u]=min(dis[u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(dis[i][j]!=INF) &#123;</span><br><span class="line">            add(i,j+n,inf,dis[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(et,e,<span class="keyword">sizeof</span>(e));</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1000000000L</span>L*<span class="number">1500</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(check(l)) <span class="built_in">printf</span>(<span class="string">"%I64d"</span>,l);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Floyd</tag>
        <tag>二分</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2528 (Mayor&#39;s posters)[线段树，离散化]</title>
    <url>/archives/12493.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=2528" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=2528</a></p>
<p>基本思路是把坐标离散化，然后用线段树维护区间颜色即可。<br>颜色标记有未涂色、某一种具体单色、混合色三种，向上维护的时候需要特别判断。查询区间中颜色总数量时，只需要向下找到单色的节点，并借助一个vis数组统计颜色即可。</p>
<p>需要注意的是这题卡常数，离散化时不能用map，因为<strong>map常数非常大</strong>会被卡掉。可以用<code>lower_bound</code>来搞，也可以直接用一个数组来搞（因为数据范围只有1e7）。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIX=<span class="number">10008</span>;</span><br><span class="line"><span class="keyword">int</span> l[MAXN];</span><br><span class="line"><span class="keyword">int</span> r[MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN*<span class="number">2</span>],ne=<span class="number">0</span>,size;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> rd[<span class="number">10000010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> col,nc;</span><br><span class="line">	<span class="keyword">int</span> lc,rc;</span><br><span class="line">&#125;v[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	v[now].col=<span class="number">0</span>;</span><br><span class="line">	v[now].nc=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		v[now].lc=t;</span><br><span class="line">		build(t++,l,mid);</span><br><span class="line">		v[now].rc=t;</span><br><span class="line">		build(t++,mid,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		v[now].lc=v[now].rc=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> mid,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v[now].nc==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	v[v[now].lc].nc=v[now].nc;</span><br><span class="line">	v[v[now].rc].nc=v[now].nc;</span><br><span class="line">	v[v[now].lc].col=v[now].nc;</span><br><span class="line">	v[v[now].rc].col=v[now].nc;</span><br><span class="line">	v[now].nc=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> lr,<span class="keyword">int</span> rr,<span class="keyword">int</span> nc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lr&lt;=l&amp;&amp;r&lt;=rr) &#123;</span><br><span class="line">		v[now].nc=nc;</span><br><span class="line">		v[now].col=nc;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v[now].nc!=<span class="number">0</span>) update(now,l,mid,r);</span><br><span class="line">	<span class="keyword">if</span>(lr&lt;mid) change(v[now].lc,l,mid,lr,rr,nc);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;rr) change(v[now].rc,mid,r,lr,rr,nc);</span><br><span class="line">	<span class="keyword">if</span>(v[v[now].lc].col==MIX || v[v[now].rc].col==MIX) v[now].col=MIX;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(v[v[now].lc].col==v[v[now].rc].col) v[now].col=v[v[now].lc].col;</span><br><span class="line">	<span class="keyword">else</span> v[now].col=MIX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(v[now].col!=MIX) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v[now].col!=<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v[now].col]) &#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				vis[v[now].col]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v[now].nc!=<span class="number">0</span>) update(now,l,mid,r);</span><br><span class="line">	query(v[now].lc,l,mid);</span><br><span class="line">	query(v[now].rc,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		ne=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,l+i,r+i);</span><br><span class="line">			d[++ne]=l[i];</span><br><span class="line">			d[++ne]=r[i];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(d+<span class="number">1</span>,d+ne+<span class="number">1</span>);</span><br><span class="line">		size=unique(d+<span class="number">1</span>,d+ne+<span class="number">1</span>)-(d+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=size;i++) &#123;</span><br><span class="line">			rd[d[i]]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		t=<span class="number">2</span>; cnt=<span class="number">0</span>;</span><br><span class="line">		build(root,<span class="number">0</span>,size+<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">int</span> ll,rr;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			ll=rd[l[i]];</span><br><span class="line">			rr=rd[r[i]];</span><br><span class="line">			change(root,<span class="number">0</span>,size+<span class="number">2</span>,ll,rr+<span class="number">1</span>,i);</span><br><span class="line">		&#125;</span><br><span class="line">		query(root,<span class="number">0</span>,size+<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2531 (Network Saboteur)做题笔记</title>
    <url>/archives/10512.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=2531" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=2531</a><br>这题需要把所有序号分为两类，直接枚举每一个序号是哪一类就行了，因为N&lt;=20，所以可以直接用一个int类型的每一位来表示每一个序号的类别（某一位是0或1代表其属于对应的类别）。这样直接枚举这个int类型就可以了。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;i++) &#123;</span><br><span class="line">		tmp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;n;k++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (((i&gt;&gt;j)&amp;<span class="number">1</span>)^((i&gt;&gt;k)&amp;<span class="number">1</span>)) tmp+=<span class="built_in">map</span>[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		mx=<span class="built_in">std</span>::max(tmp,mx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,mx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>枚举</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2778 (DNA Sequence)[AC自动机，图论，矩阵乘法]</title>
    <url>/archives/55506.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=2778" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=2778</a></p>
<p>题意：给定m个模板串，问有多少种长度为n的字符串使得它不包含任何一个模板串。</p>
<p>首先根据模板串建出trie图。可以想到任意一个字符串都对应了trie图上从根结点起始的一条路径。因此问题转化为在trie图中从根结点开始长度为n的，且不经过某些点的不同路径数量。</p>
<p>设A是图G的邻接矩阵，即：<br>$$<br>a_{ij}=<br>\begin{cases}<br>0&amp; \text{节点i和节点j之间无边相连} \\<br>n&amp; \text{节点i和节点j之间有边相连且边数为n}<br>\end{cases}<br>$$<br>注：除非有自环，否则$a_{ii}$为$0$<br>令$B=A^l$，则$b_{ij}$表示节点$i$到节点$j$长度为$l$的不同路径的数量。</p>
<p>将邻接矩阵中不能经过的节点（单词节点和能通过后缀链接到达单词节点的节点）对应的行列全部置为0,然后用矩阵快速幂算出结果即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">bool</span> danger[maxn];</span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	sz=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(danger,<span class="number">0</span>,<span class="keyword">sizeof</span>(danger));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">'T'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u=<span class="number">0</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> c=idx(s[i]);</span><br><span class="line">		<span class="keyword">if</span>(!ch[u][c]) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">			danger[sz]=<span class="literal">false</span>;</span><br><span class="line">			ch[u][c]=sz++;</span><br><span class="line">		&#125;</span><br><span class="line">		u=ch[u][c];</span><br><span class="line">	&#125;</span><br><span class="line">	danger[u]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u=ch[<span class="number">0</span>][c];</span><br><span class="line">		<span class="keyword">if</span>(u) &#123; f[u]=<span class="number">0</span>;q.push(u); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> r=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u=ch[r][c];</span><br><span class="line">			<span class="keyword">if</span>(!u) &#123; ch[r][c]=ch[f[r]][c];<span class="keyword">continue</span>; &#125;</span><br><span class="line">			q.push(u);</span><br><span class="line">			<span class="keyword">int</span> v=f[r];</span><br><span class="line">			<span class="keyword">while</span>(v &amp;&amp; !ch[v][c]) v=f[v];</span><br><span class="line">			f[u]=ch[v][c];</span><br><span class="line">			danger[u]|=danger[ch[v][c]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll mat[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span>(mat));</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	memset(vis,false,sizeof(vis));</span></span><br><span class="line"><span class="comment">	queue&lt;int&gt; q;</span></span><br><span class="line"><span class="comment">	while(!q.empty()) q.pop();</span></span><br><span class="line"><span class="comment">	vis[0]=true;</span></span><br><span class="line"><span class="comment">	for(int c=0;c&lt;4;c++) &#123;</span></span><br><span class="line"><span class="comment">		int u=ch[0][c];</span></span><br><span class="line"><span class="comment">		if(!danger[u]) &#123; mat[0][u]=1;vis[u]=true;q.push(u); &#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	while(!q.empty()) &#123;</span></span><br><span class="line"><span class="comment">		int r=q.front(); q.pop();</span></span><br><span class="line"><span class="comment">		for(int c=0;c&lt;4;c++) &#123;</span></span><br><span class="line"><span class="comment">			int u=ch[r][c];</span></span><br><span class="line"><span class="comment">			if(danger[u]) continue;</span></span><br><span class="line"><span class="comment">			mat[r][u]=1;</span></span><br><span class="line"><span class="comment">			if(!vis[u]) &#123; vis[u]=true;q.push(u); &#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) <span class="keyword">if</span>(!danger[i]) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u=ch[i][j];</span><br><span class="line">			<span class="keyword">if</span>(!danger[u]) mat[i][u]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">	ll tmp[maxn][maxn];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">		ans[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++)</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sz;k++) </span><br><span class="line">						tmp[i][j]=((ans[i][k]*mat[k][j])%M+tmp[i][j])%M;</span><br><span class="line">			<span class="built_in">memcpy</span>(ans,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sz;k++) </span><br><span class="line">					tmp[i][j]=((mat[i][k]*mat[k][j])%M+tmp[i][j])%M;</span><br><span class="line">		<span class="built_in">memcpy</span>(mat,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">		insert(s);</span><br><span class="line">	&#125;</span><br><span class="line">	getFail();</span><br><span class="line">	build();</span><br><span class="line">	pow_mod(n,<span class="number">100000</span>);</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">		a=(ans[<span class="number">0</span>][i]+a)%<span class="number">100000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2752 (Seek the Name, Seek the Fame)[KMP]</title>
    <url>/archives/9701.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=2752" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=2752</a><br>题目要求找出所有相同的前后缀，想到KMP算法在计算fail(next)指针时也是找寻相同的前后缀，所以套用KMP算法的模板。getnxt函数执行结束后，从nxt[len]开始向前跳并统计位置即可。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">400009</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> nxt[maxn];</span><br><span class="line"><span class="keyword">int</span> len[maxn], t = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnxt</span><span class="params">(<span class="keyword">char</span> *P, <span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="built_in">strlen</span>(P);</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>; f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = f[i];</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; P[j]!=P[i]) j = f[j];</span><br><span class="line">		f[i+<span class="number">1</span>] = P[j] == P[i] ? j+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	len[t++] = m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m; f[i]; i = f[i]) len[t++] = f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)!=EOF) &#123;</span><br><span class="line">		t = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span>(nxt));</span><br><span class="line">		getnxt(s, nxt);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = t<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d%c"</span>, len[i], i == <span class="number">0</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2891 (Strange Way to Express Integers)[中国剩余定理]</title>
    <url>/archives/27402.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=2891" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=2891</a></p>
<p>这题是中国剩余定理模板题（余数不保证互素的情况）。这里直接贴上模板。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000009</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL a[maxn],r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gcd</span><span class="params">(LL a,LL b,LL&amp; d,LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123; d=a;x=<span class="number">1</span>;y=<span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; gcd(b,a%b,d,y,x); y-=x*(a/b); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">china</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LL M=a[<span class="number">0</span>],R=r[<span class="number">0</span>],x,y,d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        gcd(M,a[i],d,x,y);</span><br><span class="line">        <span class="keyword">if</span>((R-r[i])%d!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x=(R-r[i])/d*x%a[i];</span><br><span class="line">        R-=x*M;</span><br><span class="line">        M=M/d*a[i];</span><br><span class="line">        R%=M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (R%M+M)%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,a+i,r+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,china(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2955 (括号匹配)[区间DP]</title>
    <url>/archives/11571.html</url>
    <content><![CDATA[<p>这题是区间DP，状态转移方程<code>d[l][r]=d[l-1][r-1]+2, s[l]与s[r]可以匹配</code>, <code>d[l][r]=max{d[l][k-1]+d[k][r]}, l&lt;k&lt;=r</code></p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">109</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'('</span> &amp;&amp; b==<span class="string">')'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'['</span> &amp;&amp; b==<span class="string">']'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s,<span class="string">"end"</span>)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(match(s[l<span class="number">-1</span>],s[r<span class="number">-1</span>])) dp[l][r]=dp[l+<span class="number">1</span>][r<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=l+<span class="number">1</span>;k&lt;=r;k++)</span><br><span class="line">                    dp[l][r]=max(dp[l][r],dp[l][k<span class="number">-1</span>]+dp[k][r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3020 (Antenna Placement)[二分图匹配，匈牙利算法]</title>
    <url>/archives/59840.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=3020" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3020</a></p>
<p>给定一个网格，网格中某些格子有点，用一些2*1的挡板覆盖，问在可以重叠覆盖的情况下覆盖掉所有的点至少需要多少挡板。</p>
<p>这题是二分图匹配。一开始想到了是一张图求最小边覆盖集，但却没想到怎么向二分图转化。其实这题不用转化，因为我们可以<strong>给斜行染两种颜色，相邻斜行染不同颜色</strong>，然后就会发现其实所有的边（若结点相邻则连边）都是连接的两种颜色的结点，这已经是二分图了。直接在这张图上跑匈牙利算法求解就行了。答案最小边覆盖集就是n-最大匹配。</p>
<p>另外需要注意的是这样连边正反各自连了一遍，匈牙利算法跑的时候也没有区分两种颜色的结点，因此最大匹配要除二。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> h,w;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> M[<span class="number">45</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">45</span>][<span class="number">20</span>],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">410</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> linker[MAXN];</span><br><span class="line"><span class="keyword">bool</span> used[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=cnt;v++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(g[u][v] &amp;&amp; !used[v]) &#123;</span><br><span class="line">			used[v]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(linker[v]==<span class="number">-1</span> || dfs(linker[v])) &#123;</span><br><span class="line">				linker[v]=u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=cnt;u++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(used,<span class="literal">false</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">		<span class="keyword">if</span>(dfs(u)) res++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">		<span class="built_in">memset</span>(M,<span class="number">0</span>,<span class="keyword">sizeof</span>(M));</span><br><span class="line">		<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%*c"</span>,&amp;h,&amp;w);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=w;j++) &#123;</span><br><span class="line">				M[i][j]=s[j<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">if</span>(M[i][j]==<span class="string">'*'</span>) p[i][j]=++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=w;j++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">					<span class="keyword">if</span>(i+dx[k]&gt;=<span class="number">1</span>&amp;&amp;i+dx[k]&lt;=h&amp;&amp;j+dy[k]&gt;=<span class="number">1</span>&amp;&amp;j+dy[k]&lt;=w) &#123;</span><br><span class="line">						g[p[i][j]][p[i+dx[k]][j+dy[k]]]=<span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">int</span> ans=hungary();</span><br><span class="line">		ans=cnt-ans/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3159 (Candies)[差分约束，栈SPFA]</title>
    <url>/archives/65045.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=3159" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3159</a></p>
<p>这题是裸的差分约束，但是直接使用队列SPFA会超时，使用栈SPFA才能过。。还不是特别理解</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">30009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">150009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf=<span class="number">10000000000000000L</span>L;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> ver[maxm];</span><br><span class="line"><span class="keyword">int</span> next[maxm];</span><br><span class="line"><span class="keyword">int</span> e[maxm];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">ll d[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">10000000</span>],top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    ver[++tot]=v;e[tot]=w;next[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//queue&lt;int&gt; q;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d[i]=inf;</span><br><span class="line">    <span class="comment">//q.push(s);</span></span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    q[++top]=s;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">while</span>(top&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//int now=q.front(); q.pop();</span></span><br><span class="line">        now=q[top--];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now],v;i;i=next[i]) &#123;</span><br><span class="line">            v=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(d[now]+e[i]&lt;d[v]) &#123;</span><br><span class="line">                d[v]=d[now]+e[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">                    vis[v]=<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//q.push(v);</span></span><br><span class="line">                    q[++top]=v;</span><br><span class="line">                    <span class="comment">//r=(r+1)%MOD;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span> || ch&gt;<span class="string">'9'</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span> &amp;&amp; ch&lt;=<span class="string">'9'</span>) ans=ans*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="comment">//scanf("%d%d",&amp;n,&amp;m);</span></span><br><span class="line">    n=read();</span><br><span class="line">    m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="comment">//scanf("%d%d%d",&amp;a,&amp;b,&amp;c);</span></span><br><span class="line">        a=read();</span><br><span class="line">        b=read();</span><br><span class="line">        c=read();</span><br><span class="line">         <span class="comment">//printf("%d %d %d\n",a,b,c);</span></span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    s=<span class="number">1</span>;</span><br><span class="line">    spfa();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>,d[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3233 (Matrix Power Series)[二分，矩阵快速幂]</title>
    <url>/archives/23049.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=3233" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3233</a></p>
<blockquote>
<p>题目分析：分析可以得到<br>k为偶数：sum(k) = (1+A^(k/2)) <em> ( A+A^2+……+A^(k/2)) = (1+A^(k/2)) </em> sum(k/2)<br>k为奇数：sum(k) = (1+A^((k-1)/2)) * sum(k/2) + A^k<br>引用自<code>https://blog.csdn.net/tc_to_top/article/details/43878231</code></p>
</blockquote>
<p>看到这题应该考虑到提公因式，或者凑成多项式相乘的形式，进而想到A^1+A^2+…+A^n的题解拆法</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> MOD;</span><br><span class="line"><span class="keyword">int</span> n,k;<span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">M</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line">	M() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	&#125;</span><br><span class="line">	M <span class="keyword">operator</span> *(<span class="keyword">const</span> M&amp; y) <span class="keyword">const</span> &#123;</span><br><span class="line">		M tmp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">				tmp.a[i][j]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line">					tmp.a[i][j]=((a[i][k]*y.a[k][j])%MOD + tmp.a[i][j])%MOD;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	M <span class="keyword">operator</span> +(<span class="keyword">const</span> M&amp; y) <span class="keyword">const</span> &#123;</span><br><span class="line">		M tmp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">				tmp.a[i][j]=(a[i][j]+y.a[i][j])%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">M init;</span><br><span class="line">M one;</span><br><span class="line"></span><br><span class="line"><span class="function">M <span class="title">pow_mod</span><span class="params">(M&amp; x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	M ans=one;</span><br><span class="line">	<span class="keyword">for</span>(M i=x;y;y&gt;&gt;=<span class="number">1</span>,i=i*i) </span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*i;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">M <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> init;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&amp;<span class="number">1</span>) &#123;</span><br><span class="line">		M tmp=pow_mod(init,x);</span><br><span class="line">		tmp=tmp+(one+pow_mod(init,x&gt;&gt;<span class="number">1</span>))*f(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		M tmp=(one+pow_mod(init,x&gt;&gt;<span class="number">1</span>))*f(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;MOD);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) one.a[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(init.a[i][j]));</span><br><span class="line">			init.a[i][j]%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(j==n ? <span class="string">"%d"</span> : <span class="string">"%d "</span>,init.a[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	M ans=f(k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(j==n ? <span class="string">"%d"</span> : <span class="string">"%d "</span>,ans.a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3281 (Dining)[网络流]</title>
    <url>/archives/40209.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=3281" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3281</a></p>
<p>这题第一眼看上去有点像二分图匹配，奶牛和他们所喜欢的食物饮料匹配，但是这题的食物和饮料作为两种限制条件不好处理。一种用网络流的建图方式是从超级源点向食物连边，从饮料向超级汇点连边，奶牛放在中间，这样一条可行流就是<strong>超级源-&gt;食物-&gt;奶牛-&gt;饮料-&gt;超级汇</strong>，从而保证了每种食物和饮料都各自只能占用一次，奶牛一次只能占用一种食物和一种饮料，因此我们把每头奶牛拆成一个容量为1的边即可。</p>
<p>这样这种有两个限制条件的匹配图，就可以通过把待匹配项放到图两边的方式来解决。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3fffffff</span>,N=<span class="number">11000</span>,M=<span class="number">410000</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],head[M],e[M],next[M],ver[M];</span><br><span class="line"><span class="keyword">int</span> s,t,m,n,tot=<span class="number">1</span>,maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    ver[++tot]=v;e[tot]=w;next[tot]=head[u];head[u]=tot;</span><br><span class="line">    ver[++tot]=u;e[tot]=<span class="number">0</span>;next[tot]=head[v];head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    q.push(s); d[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=next[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i]&amp;&amp;!d[ver[i]]) &#123;</span><br><span class="line">                q.push(ver[i]);</span><br><span class="line">                d[ver[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(ver[i]==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rest=f;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i&amp;&amp;rest;i=next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]&amp;&amp;d[ver[i]]==d[x]+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> now=dinic(ver[i],min(e[i],rest));</span><br><span class="line">            <span class="keyword">if</span>(!now) d[ver[i]]=<span class="number">0</span>;</span><br><span class="line">            e[i]-=now;</span><br><span class="line">            e[i^<span class="number">1</span>]+=now;</span><br><span class="line">            rest-=now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f-rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> food[<span class="number">110</span>],drink[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,F,D,ff,dd;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;F,&amp;D);</span><br><span class="line">    s=<span class="number">0</span>;</span><br><span class="line">    t=F+D+<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=F;i++) add(s,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=D;i++) add(F+i,t,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(F+D+i,F+D+n+i,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;ff,&amp;dd);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=ff;j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,food+j);</span><br><span class="line">            add(food[j],F+D+i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=dd;j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,drink+j);</span><br><span class="line">            add(F+D+n+i,F+drink[j],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())</span><br><span class="line">        <span class="keyword">while</span>(tmp=dinic(s,inf)) maxflow+=tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,maxflow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3304 (Segments)[计算几何]</title>
    <url>/archives/59781.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=3304" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3304</a></p>
<p>题目大意：二维平面上n个线段，问是否存在一条直线，使得<em>所有</em>线段垂直投射到该直线上的投影，都两两有公共点？</p>
<p>所有投影都两两有公共点，那么投影直线一定有一条法线穿过所有的线段，问题转化为是否存在一条直线穿过所有的线段。<br>通过旋转平移的方式我们一定可以让这条直线经过所有线段中的至少两个端点（想象如果没有经过，那么我们把它向外移直到「撞到」一个端点，再通过旋转的方式使它再「撞」到另一个端点）。<br>因此枚举两个端点，并判断经过两端点的直线是否经过所有的线段即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5009</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y) &#123;</span><br><span class="line">        x=_x;</span><br><span class="line">        y=_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> ^(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*b.y-y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x-b.x,y-b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sgn(x-b.x) == <span class="number">0</span> &amp;&amp; sgn(y-b.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;points[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point s,e;</span><br><span class="line">    Line() &#123;&#125;</span><br><span class="line">    Line(Point _s,Point _e) &#123;</span><br><span class="line">        s=_s;</span><br><span class="line">        e=_e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c=sgn((p-s)^(e-s));</span><br><span class="line">        <span class="keyword">if</span>(c&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossseg</span><span class="params">(Line v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d1=sgn((e-s)^(v.s-s));</span><br><span class="line">        <span class="keyword">int</span> d2=sgn((e-s)^(v.e-s));</span><br><span class="line">        <span class="keyword">if</span>((d1^d2)==<span class="number">-2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (d1==<span class="number">0</span> || d2==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;lines[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">double</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            points[++n]=Point(x1,y1);</span><br><span class="line">            points[++n]=Point(x2,y2);</span><br><span class="line">            lines[i]=Line(points[n<span class="number">-1</span>],points[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> found=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n &amp;&amp; !found;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n &amp;&amp; !found;j++) &#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i!=j &amp;&amp; !(points[i]==points[j])) &#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++) <span class="keyword">if</span>(!Line(points[i],points[j]).linecrossseg(lines[k])) &#123;</span><br><span class="line">                        flag=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                    found=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(found ? <span class="string">"Yes!"</span> : <span class="string">"No!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3349 (Snowflake Snow Snowflakes)[Hash]</title>
    <url>/archives/23126.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=3349" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3349</a><br><strong>参考博客：</strong><a href="http://www.cnblogs.com/fightfordream/p/5559268.html" rel="external nofollow noopener noreferrer" target="_blank">Shadowdsp</a><br>数据范围比较大，直接两两比较肯定不行，这时候考虑Hash，把雪花每个枝的长度加起来并取模获得Hash值，拥有相同Hash值的雪花暴力比较。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">14997</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> len[<span class="number">6</span>];</span><br><span class="line">&#125;snow, f[<span class="number">15000</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> Hash[<span class="number">15000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">bool</span> flag;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">		flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=i, k=<span class="number">0</span>; k&lt;<span class="number">6</span>; k++, j=(j+<span class="number">1</span>)%<span class="number">6</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a.len[j] != b.len[k]) &#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">		flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=i, k=<span class="number">0</span>; k&lt;<span class="number">6</span>; k++, j=(j+<span class="number">5</span>)%<span class="number">6</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a.len[j] != b.len[k]) &#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, now;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">		now = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;snow.len[j]);</span><br><span class="line">			now += snow.len[j] % MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">		now %= MOD;</span><br><span class="line">		<span class="keyword">if</span> (Hash[now]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=Hash[now]; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (check(snow, f[now][j])) &#123;</span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Hash[now]++;</span><br><span class="line">		f[now][Hash[now]] = snow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"Twin snowflakes found.\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No two snowflakes are alike.\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3461 (Oulipo)[KMP]</title>
    <url>/archives/29737.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接：</strong><a href="http://poj.org/problem?id=3461" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3461</a><br>这题是KMP算法模板题。直接贴上KMP模板。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>; <span class="comment">//需要注意的是这里的1e6+10以及下一行的1e4+10是double类型，不过经过类型强转后仍然可用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> word[maxm], text[maxn];</span><br><span class="line"><span class="keyword">int</span> nxt[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnxt</span><span class="params">(<span class="keyword">char</span> *P, <span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="built_in">strlen</span>(P) - <span class="number">1</span>; <span class="comment">//主函数中使用了fgets，字符串的最后一位是回车</span></span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>; f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = f[i];</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; P[i]!=P[j]) j = f[j];</span><br><span class="line">		f[i+<span class="number">1</span>] = P[i] == P[j] ? j+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> *T, <span class="keyword">char</span> *P, <span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">strlen</span>(T) - <span class="number">1</span>, m = <span class="built_in">strlen</span>(P) - <span class="number">1</span>; <span class="comment">//去掉字符串最后一位的回车</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	getnxt(P, f);</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; P[j]!=T[i]) j = f[j];</span><br><span class="line">		<span class="keyword">if</span> (P[j] == T[i]) j++;</span><br><span class="line">		<span class="keyword">if</span> (j == m) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%*c"</span>, &amp;cas);</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		fgets(word, maxm, <span class="built_in">stdin</span>);</span><br><span class="line">		fgets(text, maxn, <span class="built_in">stdin</span>);</span><br><span class="line">		<span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="keyword">sizeof</span>(nxt));</span><br><span class="line">		cnt = kmp(text, word, nxt);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3481 (Double Queue)[STL]</title>
    <url>/archives/50714.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=3481" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3481</a></p>
<p>这题可以用set水过，用两个反向的set分别维护最大值和最小值即可（找最大值或最小值这里要用<code>lower_bound</code>）。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C3</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> p,k;</span><br><span class="line">	C3(<span class="keyword">int</span> _p,<span class="keyword">int</span> _k):p(_p),k(_k) &#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> C3&amp; y) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p&lt;y.p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C2</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> p,k;</span><br><span class="line">	C2(<span class="keyword">int</span> _p,<span class="keyword">int</span> _k):p(_p),k(_k) &#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> C2&amp; y) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p&gt;y.p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;C2&gt; l2;</span><br><span class="line"><span class="built_in">set</span>&lt;C3&gt; l3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> op,k,p;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line">		<span class="built_in">set</span>&lt;C2&gt;::iterator it2;</span><br><span class="line">		<span class="built_in">set</span>&lt;C3&gt;::iterator it3;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;k,&amp;p);</span><br><span class="line">			l2.insert(C2(p,k));	</span><br><span class="line">			l3.insert(C3(p,k));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(l2.size()==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			it2=l2.lower_bound(C2(INF,<span class="number">0</span>));</span><br><span class="line">			<span class="keyword">int</span> fp=(*it2).p;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(*it2).k);</span><br><span class="line">			it3=l3.find(C3(fp,<span class="number">0</span>));</span><br><span class="line">			l2.erase(it2);</span><br><span class="line">			l3.erase(it3);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(l3.size()==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			it3=l3.lower_bound(C3(<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">			<span class="keyword">int</span> fp=(*it3).p;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(*it3).k);</span><br><span class="line">			it2=l2.find(C2(fp,<span class="number">0</span>));</span><br><span class="line">			l2.erase(it2);</span><br><span class="line">			l3.erase(it3);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3660 (Cow Contest)[Floyd]</title>
    <url>/archives/40049.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br><strong>题目链接:</strong><a href="http://poj.org/problem?id=3660" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3660</a><br>对于每一头牛，能够确切判断它的名次，当且仅当它与其他n-1头牛都能直接判断胜负。对于给定的战胜关系a-&gt;b，我们连一条从a到b的边。在生成的图上跑一遍Floyd，就可以判断任意两点是否直接或间接相连了，此时枚举每一个点，如果该点与其它n-1个点都相连（包括正向和反向，即战胜和被战胜），那么该点的名次就是确定的。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">bool</span> beat[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">if</span> (beat[i][k] &amp;&amp; beat[k][j])</span><br><span class="line">					beat[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(beat, <span class="number">0</span>, <span class="keyword">sizeof</span>(beat));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		beat[a][b] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	floyd();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (!beat[i][j] &amp;&amp; !beat[j][i] &amp;&amp; i != j) &#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>Floyd</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3678 (Katu Puzzle)[2-SAT]</title>
    <url>/archives/28241.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=3678" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3678</a></p>
<p>2-SAT模板题，注意四种条件中a &amp; b = 1和a | b = 0的情况，前者需要u^1 -&gt; u, v^1 -&gt; v连边，后者需要u -&gt; u^1, v -&gt; v^1连边。<br>相当于无论如何都要选u^1（无论如何都要选v^1）。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">2000009</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[tot].to=v;edge[tot].next=head[u];head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> S[MAXN],top;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u^<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    S[top++]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!dfs(edge[i].to))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Twosat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] || vis[i^<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(i)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(top) vis[S[--top]]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i^<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        u=<span class="number">2</span>*a,v=<span class="number">2</span>*b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'A'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">1</span>) &#123;</span><br><span class="line">				addedge(u,u^<span class="number">1</span>);</span><br><span class="line">				addedge(v,v^<span class="number">1</span>);</span><br><span class="line">				addedge(u^<span class="number">1</span>,v^<span class="number">1</span>);</span><br><span class="line">				addedge(v^<span class="number">1</span>,u^<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                addedge(u^<span class="number">1</span>,v);</span><br><span class="line">                addedge(v^<span class="number">1</span>,u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'O'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>) &#123;</span><br><span class="line">				addedge(u^<span class="number">1</span>,u);</span><br><span class="line">				addedge(v^<span class="number">1</span>,v);</span><br><span class="line">				addedge(u,v);</span><br><span class="line">				addedge(v,u);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                addedge(u,v^<span class="number">1</span>);</span><br><span class="line">                addedge(v,u^<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'X'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>) &#123;</span><br><span class="line">                addedge(u,v);</span><br><span class="line">                addedge(v,u);</span><br><span class="line">                addedge(u^<span class="number">1</span>,v^<span class="number">1</span>);</span><br><span class="line">                addedge(v^<span class="number">1</span>,u^<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                addedge(u,v^<span class="number">1</span>);</span><br><span class="line">                addedge(v^<span class="number">1</span>,u);</span><br><span class="line">                addedge(u^<span class="number">1</span>,v);</span><br><span class="line">                addedge(v,u^<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Twosat(<span class="number">2</span>*n)) <span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>Requests库学习笔记</title>
    <url>/archives/58888.html</url>
    <content><![CDATA[<p>笔记中的解释出处：<a href="https://www.icourse163.org/learn/BIT-1001870001" rel="external nofollow noopener noreferrer" target="_blank">Python网络爬虫与信息提取</a></p>
<h1 id="reponse对象"><a href="#reponse对象" class="headerlink" title="reponse对象"></a>reponse对象</h1><h2 id="构造一个response对象"><a href="#构造一个response对象" class="headerlink" title="构造一个response对象"></a>构造一个response对象</h2><p><code>r = requests.get(&quot;http://www.google.com&quot;, timeout = 30)</code></p>
<h2 id="response对象的属性"><a href="#response对象的属性" class="headerlink" title="response对象的属性"></a>response对象的属性</h2><table>
<thead>
<tr>
<th>对象成员</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>r.status_code</td>
<td>HTTP请求的返回状态，200表示连接成功，404表示失败 </td>
</tr>
<tr>
<td>r.text</td>
<td>HTTP响应内容的字符串形式，即，url对应的页面内容 </td>
</tr>
<tr>
<td>r.encoding</td>
<td>从HTTP header中猜测的响应内容编码方式，如果header中不存在charset，则认为编码方式为ISO-8859-1 </td>
</tr>
<tr>
<td>r.apparent_encoding</td>
<td>从内容中分析出的响应内容编码方式（备选编码方式）这种方法比较慢 </td>
</tr>
<tr>
<td>r.content</td>
<td>HTTP响应内容的二进制形式 </td>
</tr>
</tbody>
</table>
<h1 id="Requests库的异常"><a href="#Requests库的异常" class="headerlink" title="Requests库的异常"></a>Requests库的异常</h1><table>
<thead>
<tr>
<th>异常名称</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>requests.ConnectionError</td>
<td>网络连接错误异常，如DNS查询失败，拒绝连接等 </td>
</tr>
<tr>
<td>requests.HTTPError</td>
<td>HTTP错误异常 </td>
</tr>
<tr>
<td>requests.URLRequired</td>
<td>URL缺失异常 </td>
</tr>
<tr>
<td>requests.TooManyRedirects</td>
<td>超过最大重定向次数，产生重定向异常 </td>
</tr>
<tr>
<td>requests.ConnectTimeout</td>
<td>连接远程服务器超时异常 </td>
</tr>
<tr>
<td>requests.Timeout</td>
<td>请求URL超时，产生超时异常 </td>
</tr>
<tr>
<td>r.raise_for_status()</td>
<td>如果r.status_code不是200，会引发异常requests.HTTPError </td>
</tr>
</tbody>
</table>
<h1 id="Requests库的7个主要方法"><a href="#Requests库的7个主要方法" class="headerlink" title="Requests库的7个主要方法"></a>Requests库的7个主要方法</h1><table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>requests.request()</td>
<td>构造一个请求，支撑以下各方法的基础方法 </td>
</tr>
<tr>
<td>requests.get()</td>
<td>获取HTML网页的主要方法，对应于HTTP的GET </td>
</tr>
<tr>
<td>requests.head()</td>
<td>获取HTML网页头信息的方法，对应于HTTP的HEAD </td>
</tr>
<tr>
<td>requests.post()</td>
<td>向HTML网页提交POST请求的方法，对应于HTTP的POST </td>
</tr>
<tr>
<td>requests.put()</td>
<td>向HTML网页提交PUT请求的方法，对应于HTTP的PUT </td>
</tr>
<tr>
<td>requests.patch()</td>
<td>向HTML网页提交局部修改求求，对应于HTTP的PATCH </td>
</tr>
<tr>
<td>requests.delete()</td>
<td>向HTML页面提交删除请求，对应于HTTP的DELETE </td>
</tr>
</tbody>
</table>
<h1 id="HTTP协议对资源的操作"><a href="#HTTP协议对资源的操作" class="headerlink" title="HTTP协议对资源的操作"></a>HTTP协议对资源的操作</h1><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求获取URL位置的资源 </td>
</tr>
<tr>
<td>HEAD</td>
<td>请求获取URL位置资源的响应消息报告，即获得该资源的头部信息 </td>
</tr>
<tr>
<td>POST</td>
<td>请求向URL位置的资源后附加新的数据 </td>
</tr>
<tr>
<td>PUT</td>
<td>请求向URL位置存储一个资源，覆盖原URL位置的资源 </td>
</tr>
<tr>
<td>PATCH</td>
<td>请求局部更新URL位置的资源，即改变该处资源的部分内容 </td>
</tr>
<tr>
<td>DELETE</td>
<td>请求删除URL位置存储的资源 </td>
</tr>
</tbody>
</table>
<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>SGU154 (Factorial)[二分，思维]</title>
    <url>/archives/268.html</url>
    <content><![CDATA[<p>题目链接：<a href="http://acm.sgu.ru/problem.php?contest=0&amp;problem=154" rel="external nofollow noopener noreferrer" target="_blank">http://acm.sgu.ru/problem.php?contest=0&amp;problem=154</a></p>
<p>一开始用Java打了个表尝试找规律，但找了半天都没有发现什么靠谱的规律。。<br>正确的思路是，可以看到结尾0是5乘2或4或6或8得到的，有一个5就有一个结尾0。所以二分一个n，判断n中5的因子个数即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">	ll cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(mid) &#123;</span><br><span class="line">		cnt+=mid/<span class="number">5</span>;</span><br><span class="line">		mid/=<span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">	ll l=<span class="number">1</span>,r=<span class="number">1000000000L</span>L;</span><br><span class="line">	ll mid;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)&gt;=n) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(check(l)==n)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,l);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA11384 (Help is needed for Dexter)[找规律，二分]</title>
    <url>/archives/31663.html</url>
    <content><![CDATA[<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2379" rel="external nofollow noopener noreferrer" target="_blank"><strong>题目链接</strong></a></p>
<p>手推前几项可以发现，第一次消一定是从数列的正中间消最优，消完这一次后中间会出现一个零，假设n是偶数，那此时两边会出现两个一样的数列，对它们的操作是镜像的，因此只考虑一个并重复上面的操作即可，如果n是奇数，那么每次只考虑较大的那个子数列即可。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(n) &#123;</span><br><span class="line">			n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>UVALive 11732 (strcmp() Anyone?)[Trie（左儿子右兄弟表示法）]</title>
    <url>/archives/57368.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br>这题是刘汝佳老师《算法竞赛入门经典-训练指南》上字符串一节的例题，下文的思路直接来自书上的解析，代码来自<a href="http://code.google.com/p/aoapc-book/" rel="external nofollow noopener noreferrer" target="_blank">代码仓库（需翻墙）</a><br>把所有单词插入一棵Trie树，则在深度为depth的分叉点的任何两个字符串都需要比较2*depth-1次。<br>因为字符集比较大，需要用左儿子右兄弟法保存Trie。这种方法类似于保存图的邻接表。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4000</span> * <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> head[maxn];</span><br><span class="line">	<span class="keyword">int</span> next[maxn];</span><br><span class="line">	<span class="keyword">char</span> ch[maxn];</span><br><span class="line">	<span class="keyword">int</span> tot[maxn];</span><br><span class="line">	<span class="keyword">int</span> sz;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; sz = <span class="number">1</span>; tot[<span class="number">0</span>] = head[<span class="number">0</span>] = next[<span class="number">0</span>] = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>, v, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">		tot[<span class="number">0</span>]++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (v = head[u]; v != <span class="number">0</span>; v = next[v])</span><br><span class="line">				<span class="keyword">if</span> (ch[v] == s[i]) &#123;</span><br><span class="line">					found = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> (!found) &#123;</span><br><span class="line">				v = sz++;</span><br><span class="line">				tot[v] = <span class="number">0</span>;</span><br><span class="line">				ch[v] = s[i];</span><br><span class="line">				next[v] = head[u];</span><br><span class="line">				head[u] = v;</span><br><span class="line">				head[v] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			tot[v]++;</span><br><span class="line">			u = v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head[u] == <span class="number">0</span>)</span><br><span class="line">			ans += tot[u] * (tot[u] - <span class="number">1</span>) * depth;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> v = head[u]; v != <span class="number">0</span>; v = next[v])</span><br><span class="line">				sum += tot[v] * (tot[u] - tot[v]);</span><br><span class="line">			ans += sum / <span class="number">2</span> * (<span class="number">2</span> * depth + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> v = head[u]; v != <span class="number">0</span>; v = next[v])</span><br><span class="line">				dfs(depth + <span class="number">1</span>, v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;trie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> word[maxl];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n) &#123;</span><br><span class="line">		trie.clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, word);</span><br><span class="line">			trie.insert(word);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, cas++, trie.count());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>字符串</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>UVALive 3942 (Remember the Word)[Trie]</title>
    <url>/archives/31303.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br>这题是刘汝佳老师《算法竞赛入门经典-训练指南》上字符串一节的例题，下文的思路直接来自书上的解析，代码来自<a href="http://code.google.com/p/aoapc-book/" rel="external nofollow noopener noreferrer" target="_blank">代码仓库（需翻墙）</a><br>可以想到这样的递推法：令d(i)表示从字符i开始的字符串（即后缀S[i..L]）的分解方案数，则d(i)=sum{d(i+len(x))|x为一个单词并且是S[i..L]的一个前缀}。<br>如果直接枚举x并判断其是否为S[i..L]的前缀会超时，这时可以构建一颗Trie树，并插入所有单词，然后在Trie树中「查找」S[i..L]，经过一个单词结点，就能找到一个上述状态转移方程的x，因为每个单词长度最长为100，所以查找次数最多300000 * 100不会超时。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">4000</span> * <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sigma_size = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">300000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw = <span class="number">4000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxwl = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">20071027</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ch[maxnode][sigma_size];</span><br><span class="line">	<span class="keyword">int</span> val[maxnode];</span><br><span class="line">	<span class="keyword">int</span> sz;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; sz = <span class="number">1</span>; <span class="built_in">memset</span>(ch[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[<span class="number">0</span>])); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="string">'a'</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">			<span class="keyword">if</span> (!ch[u][c]) &#123;</span><br><span class="line">				<span class="built_in">memset</span>(ch[sz], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">				val[sz] = <span class="number">0</span>;</span><br><span class="line">				ch[u][c] = sz++;</span><br><span class="line">			&#125;</span><br><span class="line">			u = ch[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">		val[u] = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">find_prefixes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'\0'</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">			<span class="keyword">if</span> (!ch[u][c]) <span class="keyword">break</span>;</span><br><span class="line">			u = ch[u][c];</span><br><span class="line">			<span class="keyword">if</span> (val[u] != <span class="number">0</span>) ans.push_back(val[u]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> d[maxl], len[maxw], S;</span><br><span class="line"><span class="keyword">char</span> text[maxl], word[maxwl];</span><br><span class="line">Trie trie;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, text, &amp;S) == <span class="number">2</span>) &#123;</span><br><span class="line">		trie.clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, word);</span><br><span class="line">			len[i] = <span class="built_in">strlen</span>(word);</span><br><span class="line">			trie.insert(word, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="keyword">int</span> L = <span class="built_in">strlen</span>(text);</span><br><span class="line">		d[L] = <span class="number">1</span>; <span class="comment">//如果x恰好等于S[i..L]，则d应该加1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = L<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">			trie.find_prefixes(text+i, L-i, p);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.size(); j++) </span><br><span class="line">				d[i] = (d[i] + d[i+len[p[j]]]) % MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, cas++, d[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>acm</tag>
        <tag>字符串</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>UVALive3523 (Knights of the Round Table)[点双连通分量]</title>
    <url>/archives/61861.html</url>
    <content><![CDATA[<p><strong> <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1524" rel="external nofollow noopener noreferrer" target="_blank">题目链接</a> </strong></p>
<blockquote>
<p>本题可以转化为求不在任何一个简单奇圈上的结点个数。<br>简单圈上的所有结点必然属于一个点双连通分量。因此需要先找出所有双连通分量，二分图是没有奇圈的，因此我们只需要关注那些不是二分图的双连通分量，可以证明这些双连通分量一定都在某个奇圈上。<br>对于每个连通分量的每个双连通分量B，若它不是二分图，给B中所有结点标记为“在奇圈上”。注意，由于每个割顶属于多个双连通分量，它可能被标记多次。<br><em>引用自刘汝佳《算法竞赛入门经典 训练指南》</em></p>
</blockquote>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1009</span>;</span><br><span class="line"><span class="keyword">int</span> pre[maxn],iscut[maxn],bccno[maxn],dfs_clock,bcc_cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn],bcc[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">stack</span>&lt;Edge&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowu=pre[u]=++dfs_clock;</span><br><span class="line">    <span class="keyword">int</span> child=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[u][i];</span><br><span class="line">        Edge e=(Edge)&#123;u,v&#125;;</span><br><span class="line">        <span class="keyword">if</span>(!pre[v]) &#123;</span><br><span class="line">            S.push(e);</span><br><span class="line">            child++;</span><br><span class="line">            <span class="keyword">int</span> lowv=dfs(v,u);</span><br><span class="line">            lowu=min(lowu,lowv);</span><br><span class="line">            <span class="keyword">if</span>(lowv&gt;=pre[u]) &#123;</span><br><span class="line">                iscut[u]=<span class="literal">true</span>;</span><br><span class="line">                bcc_cnt++; bcc[bcc_cnt].clear();</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    Edge x=S.top(); S.pop();</span><br><span class="line">                    <span class="keyword">if</span>(bccno[x.u]!=bcc_cnt) &#123; bcc[bcc_cnt].push_back(x.u);bccno[x.u]=bcc_cnt; &#125;</span><br><span class="line">                    <span class="keyword">if</span>(bccno[x.v]!=bcc_cnt) &#123; bcc[bcc_cnt].push_back(x.v);bccno[x.v]=bcc_cnt; &#125;</span><br><span class="line">                    <span class="keyword">if</span>(x.u==u &amp;&amp; x.v==v) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pre[v]&lt;pre[u] &amp;&amp; v!=fa) &#123;</span><br><span class="line">            S.push(e);</span><br><span class="line">            lowu=min(lowu,pre[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fa&lt;<span class="number">0</span> &amp;&amp; child==<span class="number">1</span>) iscut[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> lowu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(iscut,<span class="number">0</span>,<span class="keyword">sizeof</span>(iscut));</span><br><span class="line">    <span class="built_in">memset</span>(bccno,<span class="number">0</span>,<span class="keyword">sizeof</span>(bccno));</span><br><span class="line">    dfs_clock=bcc_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!pre[i]) dfs(i,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> hate[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> col[maxn];</span><br><span class="line"><span class="keyword">bool</span> ok[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_bipartite</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++) &#123;</span><br><span class="line">        v=G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(bccno[v]!=b) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(col[v]==col[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!col[v]) &#123;</span><br><span class="line">            col[v]=<span class="number">3</span>-col[u];</span><br><span class="line">            <span class="keyword">if</span>(!is_bipartite(v,b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(hate,<span class="number">0</span>,<span class="keyword">sizeof</span>(hate));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) G[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            hate[u][v]=hate[v][u]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!hate[i][j]) &#123;</span><br><span class="line">                    G[i].push_back(j);</span><br><span class="line">                    G[j].push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        find_bcc(n);</span><br><span class="line">        <span class="built_in">memset</span>(ok,<span class="number">0</span>,<span class="keyword">sizeof</span>(ok));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bcc_cnt;i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="keyword">sizeof</span>(col));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bcc[i].size();j++) bccno[bcc[i][j]]=i;</span><br><span class="line">            <span class="keyword">int</span> u=bcc[i][<span class="number">0</span>];</span><br><span class="line">            col[u]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!is_bipartite(u,i))</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bcc[i].size();j++) ok[bcc[i][j]]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(ok[i]) ans--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>点双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>gentoo下配置中文输入法（搜狗输入法）</title>
    <url>/archives/35246.html</url>
    <content><![CDATA[<p>其实本来感觉没有必要写这篇文章的，但是几个周前gentoo升级时搜狗输入法滚挂了，解决问题后，我感觉有些之前没有遇到的问题，有必要记下来，以方便以后自己查看。这里汇总一下最近安装fcitx输入法框架遇到的问题，一并把搜狗输入法的安装写进来。<br><a id="more"></a></p>
<h2 id="配置locale"><a href="#配置locale" class="headerlink" title="配置locale"></a>配置locale</h2><p>如果使用的是英文系统，系统区域（system locale）一定不能选C或者POSIX，我个人建议选择en_US.utf8。</p>
<p><strong>对于openRC</strong>：使用<code>eselect locale list</code>查看LANG的可选值，然后<code>eselect locale set 4</code> “4”要用对应的值。<br><strong>对于systemd</strong>：可以使用<code>localectl list-locales</code>查看LANG的可选值，用<code>localectl set-locale LANG=en_US.utf8</code>设置locale</p>
<p><strong>最近遇到的问题：如果单纯设置LANG=en_US.utf8的话，在chromium等程序中会出现输入法无法使用的情况。所以locale还需要进一步配置。</strong></p>
<p>如果使用openRC，那么执行<code>vim /etc/env.d/02locale</code>，在打开的文件尾添加</p>
<blockquote>
<p>LC_CTYPE=”zh_CN.UTF-8”</p>
</blockquote>
<p>这样在chromium中就能正常使用fcitx了。<br>如果使用systemd，这个我还真没有试过。。</p>
<h2 id="安装fcitx框架"><a href="#安装fcitx框架" class="headerlink" title="安装fcitx框架"></a>安装fcitx框架</h2><blockquote>
<p>emerge –ask app-i18n/fcitx</p>
</blockquote>
<p>建议USE FLAG添加gtk,gtk3或qt4</p>
<p>安装完成后还需要配置一下环境变量，才能在Xorg中正常使用输入法。<br>如果使用的是GDM、LightDM等登陆管理器，把下面的语句添加到~/.xprofile文件中，如果用的是startx或SLIM，把下面的语句添加到~/.xinitrc文件中。</p>
<p>如果安装时添加了gtk,gtk3或qt4的USE FLAG，那么下面例子中的<code>&lt;module&gt;</code>就要用fcitx，否则用xim。</p>
<p> <strong>~/.xprofile或~/.xinitrc</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br><span class="line">export QT_IM_MODULE=&lt;module&gt;</span><br><span class="line">export GTK_IM_MODULE=&lt;module&gt;</span><br></pre></td></tr></table></figure></p>
<p>引用一段gentoo wiki上的建议：<br>It is recommended to start the D-Bus session bus before Fcitx starts. Add these to the <strong>beginning</strong> of the X start up file (~/.xprofile or ~/.xinitrc):<br>建议在fcitx启动前启动D-Bus session bus，把下面的语句放到X启动文件（~/.xprofile 或 ~/.xinitrc）<strong>开头</strong>。<strong>不过添加与否貌似差别不大。</strong></p>
<p>FILE ~/.xprofile or ~/.xinitrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval &quot;$(dbus-launch --sh-syntax --exit-with-session)&quot;</span><br></pre></td></tr></table></figure>
<p>FILE ~/.xinitrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval &quot;$(dbus-launch --sh-syntax --exit-with-session)&quot;</span><br></pre></td></tr></table></figure>
<h2 id="安装输入法主体与配置程序"><a href="#安装输入法主体与配置程序" class="headerlink" title="安装输入法主体与配置程序"></a>安装输入法主体与配置程序</h2><p>对于配置程序，如果使用kde，安装app-i18n/kcm-fcitx这个包，否则安装app-i18n/fcitx-configtool（基于GTK）。</p>
<p><strong>注意：如果使用kde，一定要安装app-i18n/fcitx-qt5这个包，否则输入法可能无法在kde的程序下使用。</strong></p>
<p><strong>安装输入法主体</strong></p>
<blockquote>
<p>emerge app-i18n/fcitx-cloudpinyin<br>emerge app-i18n/fcitx-libpinyin</p>
</blockquote>
<p>其中cloudpinyin是fcitx的一个插件，顾名思义，它采用google或百度的api，在实际输入还是非常有帮助的。</p>
<p><strong>安装搜狗输入法</strong></p>
<p>搜狗输入法不在gentoo官方的源里，但存在于gentoo-zh这个overlay里。</p>
<blockquote>
<p>layman -a gentoo-zh<br>layman -s gentoo-zh<br><del>emerge sougoupinyin</del><br>emerge sogoupinyin</p>
</blockquote>
<p>这个overlay还有网易云音乐等一些有用的程序。</p>
]]></content>
      <tags>
        <tag>gentoo</tag>
      </tags>
  </entry>
  <entry>
    <title>hihoCoder1513 (小Hi的烦恼)[bitset]</title>
    <url>/archives/52638.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://hihocoder.com/problemset/problem/1513" rel="external nofollow noopener noreferrer" target="_blank">https://hihocoder.com/problemset/problem/1513</a></p>
<p>题目大意：给定许多人的五门课排名，询问每个人有多少人所有课的排名都能碾压他。</p>
<blockquote>
<p>小Hi：今天我们来解决“五维数点”问题。<br>小Ho：什么是“五维数点”问题呢？<br>小Hi：抽象来说，我们现在有n个在五维空间中的点$(X_i,Y_i,Z_i,Q_i,W_i)$。现在对于每个点，我们需要知道所有坐标均比它小的点的数量。<br>小Ho：这个问题看起来似曾相似，如果是在二维空间中似乎是一个经典的运用线段树解决的题目。<br>小Hi：对。但是现在是在五维空间中，看起来难度大了很多。<br>小Ho：我想用集合的角度去考虑这个问题。对于每一维，比如说X维，我们能通过按X维的坐标排序，不难求出对i点来说X维比i点小的所有点的集合。现在的问题就转化成对点i来说，求出X维，Y维，Z维，Q维，W维分别比i所在那一维小的集合的交的大小。<br>小Hi：对！你的思路很好。但是集合大小是O(N^2)，如果暴力实现的话时间复杂度就达到了O(N^2)。<br>小Ho：那该怎么办呢？<br>小Hi：我们想想可以用什么合理的方法来表示集合以此来加快求集合交的操作。<br>小Ho：我觉得一种比较直观的方法是用一个长度为n的01串，第i位为0表示i不在集合中，1表示i在集合中。<br>小Hi：不错哟！那你仔细观察一下，求集合的交到底具有什么性质？比如对于n=6,集合{1,4,5}和集合{2,4,5,6}来说，它们的交是{4,5}。<br>小Ho：集合求交在01串中可以这么看：若两串第i位都是1，则交的串第i位是1，否则第i位就是0。这个例子中两个集合的01串分别为100110,010111。它们的交就是000110，也就是{4,5}。<br>小Hi：是的。我们把这个问题转化成了对01串的操作。你有没有发现，这其实类似于二进制中”and”的操作。如果我们把01串看成一个二进制的大整数，那么集合求交就变成了对两个大整数做”and”的操作。<br>小Ho：哈！有道理。但是这看起来复杂度似乎依旧是O(N^2)的。<br>小Hi：啊！但是你有没有想过，我们可以利用程序语言中的32位整数加速这个”and”，也就是说我们每32位压缩成一个32位整数，这样本来我们需要32次的操作，一下就变成了做一次位运算“并”的操作。所有我们最后的复杂度能优化成O(N^2/32)。<br>小Ho：原来如此！那具体怎么实现这个“压缩”的过程呢？<br>小Hi：其实c++/Java已经为我们设计了这样一种数据结构来解决这种问题。它的名字叫bitset/BitSet。它类似于数组，但是你可以直接对其做位运算。bitset中还有一些有用的函数，如count/cardinality可以快速算出二进制中有多少个1（这其实是一个不太好做的问题）。<br>引用自题目页提式</p>
</blockquote>
<p>感觉比较难想到的是单独对于每一维排序后可以直接$O(n)$递推出每个人这一科的排名关系。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">30009</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se1[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se2[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se3[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se4[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se5[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line">&#125;stu[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.a[<span class="number">0</span>]&lt;y.a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.a[<span class="number">1</span>]&lt;y.a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp3</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.a[<span class="number">2</span>]&lt;y.a[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp4</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.a[<span class="number">3</span>]&lt;y.a[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp5</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.a[<span class="number">4</span>]&lt;y.a[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp6</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.pos&lt;y.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;maxn&gt; tmp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;stu[i].a[<span class="number">0</span>],&amp;stu[i].a[<span class="number">1</span>],&amp;stu[i].a[<span class="number">2</span>],&amp;stu[i].a[<span class="number">3</span>],&amp;stu[i].a[<span class="number">4</span>]);</span><br><span class="line">		stu[i].pos=i;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(stu,stu+n,cmp1);</span><br><span class="line">	se1[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		tmp.reset();</span><br><span class="line">		tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">		se1[stu[i].pos]=se1[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(stu,stu+n,cmp2);</span><br><span class="line">	se2[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		tmp.reset();</span><br><span class="line">		tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">		se2[stu[i].pos]=se2[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(stu,stu+n,cmp3);</span><br><span class="line">	se3[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		tmp.reset();</span><br><span class="line">		tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">		se3[stu[i].pos]=se3[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(stu,stu+n,cmp4);</span><br><span class="line">	se4[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		tmp.reset();</span><br><span class="line">		tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">		se4[stu[i].pos]=se4[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(stu,stu+n,cmp5);</span><br><span class="line">	se5[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		tmp.reset();</span><br><span class="line">		tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">		se5[stu[i].pos]=se5[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lu\n"</span>,(se1[i]&amp;se2[i]&amp;se3[i]&amp;se4[i]&amp;se5[i]).count());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装无线网卡驱动</title>
    <url>/archives/3353.html</url>
    <content><![CDATA[<p>·· / ·– ·· ·-·· ·-·· / ·–· · ·-· ··· ·· ··· - / ··- -· - ·· ·-·· / ·· / ·– ·· -·<br>相信安装无线网卡驱动是许多linux初学者遇到的一个棘手的问题。Ubuntu默认使用开源网卡驱动，比如针对broadcom网卡，有b43、brcm80211等开源驱动，如果显卡型号适配，那么恭喜你，在安装时你就可以连接至无线网络，但如果不适配，就要手动安装无线网卡驱动。尤其是现在的许多超薄本、变形本和PC平板二合一没有传统网线插口（RJ45接口），安装无线网卡驱动就会变得更加棘手。<br><strong>这篇文章适用于有网络和无网络的情况，也适用于没有网线接口的情况。</strong></p>
<a id="more"></a>
<h2 id="使用软件源的驱动"><a href="#使用软件源的驱动" class="headerlink" title="使用软件源的驱动"></a>使用软件源的驱动</h2><p>如果你在安装后无法连接无线网但能连上有线网，那么恭喜你，使你的电脑连上无线网络只需要简单的两步：</p>
<h4 id="一、更改软件源"><a href="#一、更改软件源" class="headerlink" title="一、更改软件源"></a>一、更改软件源</h4><p>打开“设置”，选择“软件和更新”，然后更改“下载至”的站点为合适的站点（图中以中科大的源为例）。选择合适的服务器后，系统会提示更新索引，确定即可。</p>
<h4 id="二、使用已有的附加驱动"><a href="#二、使用已有的附加驱动" class="headerlink" title="二、使用已有的附加驱动"></a>二、使用已有的附加驱动</h4><p> 在系统设置中打开“软件与更新”面板，进入“附加驱动”选项卡，如果软件源设置正确，则一般能搜到对应的无线网卡驱动，安装之就可以了。</p>
<h4 id="如果电脑连不上有线网"><a href="#如果电脑连不上有线网" class="headerlink" title="如果电脑连不上有线网"></a>如果电脑连不上有线网</h4><p>但如果你的电脑不幸的没有RJ45接口，一种解决方案是购买USB转RJ45外置网卡，然后按照上一种方法安装附加驱动。但仔细一想，如果是在windows下遇到这种问题，我们一般会到无线网卡的官网下载对应的驱动，然后用U盘拷贝到系统上安装，ubuntu下能不能也这样做呢？答案是肯定的。这里以安装broadcom 802.11无线网卡驱动为例，介绍这种解决方案。</p>
<p>这种方案也可以针对完全没有有线网的情况。</p>
<h4 id="一、配置本地软件源"><a href="#一、配置本地软件源" class="headerlink" title="一、配置本地软件源"></a>一、配置本地软件源</h4><p>相比于windows下驱动的“一键安装”，ubuntu安装驱动的一个主要挑战就是处理好编译驱动时所需的依赖包。如果电脑连不上有线网，连接不上在线的软件源，就要去手动安装这些依赖，而依赖包往往又会有它自己的依赖，所以这会是一项相当麻烦的工作。好在ubuntu考虑到了这种情况。还保留有安装ubuntu的iso文件吗？它们不止可以用来安装系统，还可以像winpe那样用来维护系统或充当本地软件源！我们可以用这个iso文件来安装依赖。</p>
<p>首先我们要挂载这个iso文件，按Cirl+Alt+T打开终端，输入</p>
<blockquote>
<p>sudo mount -o loop -t iso9660 /…/ubuntu_trusty.iso /media/cdrom/</p>
</blockquote>
<p>其中的/…/ubuntu_trusty.iso是iso文件所在的路径，要根据自己的实际情况来修改。</p>
<p>然后用apt-cdrom命令来添加这个源：</p>
<blockquote>
<p>sudo apt-cdrom -m -d /media/cdrom add</p>
</blockquote>
<p>接着输入</p>
<blockquote>
<p>sudo gedit /etc/apt/sources.list</p>
</blockquote>
<p>在打开的文本编辑器中删除除了包含deb cdrom以外的所有行，保存（一定要注意备份）。</p>
<p>最后更新源的索引。</p>
<blockquote>
<p>sudo apt-get update</p>
</blockquote>
<h4 id="二、安装依赖"><a href="#二、安装依赖" class="headerlink" title="二、安装依赖"></a>二、安装依赖</h4><p>安装dkms。</p>
<blockquote>
<p>sudo apt-get install dkms</p>
</blockquote>
<h4 id="三、安装无线网卡驱动"><a href="#三、安装无线网卡驱动" class="headerlink" title="三、安装无线网卡驱动"></a>三、安装无线网卡驱动</h4><p>首先，要先下载对应无线网卡驱动的deb安装包（可以通过电脑上的windows系统，也可以通过手机）。这里给出broadcom闭源无线网卡驱动wl的下载地址：<a href="http://mirrors.kernel.org/ubuntu/pool/restricted/b/bcmwl/bcmwl-kernel-source_6.30.223.248%2bbdcom-0ubuntu8_amd64.deb" rel="external nofollow noopener noreferrer" target="_blank">http://mirrors.kernel.org/ubuntu/pool/restricted/b/bcmwl/bcmwl-kernel-source_6.30.223.248%2bbdcom-0ubuntu8_amd64.deb</a>  ，也可以使用ubuntu中文论坛上的下载地址：<a href="http://forum.ubuntu.org.cn/download/file.php?id=183385" rel="external nofollow noopener noreferrer" target="_blank">http://forum.ubuntu.org.cn/download/file.php?id=183385</a> 。</p>
<p>下载好文件后，把文件拷贝到～（你的用户目录）目录下。然后输入</p>
<blockquote>
<p>cd</p>
</blockquote>
<blockquote>
<p>sudo dpkg -i bcmwl*</p>
</blockquote>
<p>进行完这一步以后，应该就可以看见有可用的无线网络的提示了。</p>
<h2 id="进阶：手动编译并使用专有驱动（需有线网）"><a href="#进阶：手动编译并使用专有驱动（需有线网）" class="headerlink" title="进阶：手动编译并使用专有驱动（需有线网）"></a>进阶：手动编译并使用专有驱动（需有线网）</h2><p>如果想要练手，或熟悉系统操作，可以通过这个方法。首先要在broadcom官网<a href="http://www.broadcom.com/support/802.11下载好官方驱动。" rel="external nofollow noopener noreferrer" target="_blank">http://www.broadcom.com/support/802.11下载好官方驱动。</a></p>
<h4 id="一、准备安装环境"><a href="#一、准备安装环境" class="headerlink" title="一、准备安装环境"></a>一、准备安装环境</h4><p>1、首先，因为下载下来的是源代码，需要编译器来编译。<br>按Cirl+Alt+T打开终端，输入</p>
<blockquote>
<p>sudo apt-get install build-essential linux-headers-generic</p>
</blockquote>
<blockquote>
<p>sudo apt-get build-dep linux</p>
</blockquote>
<p>安装好所需编译器。<br>2、因为Broadcom Linux hybrid wireless driver会和一部分已有的驱动（b43, brcmsmac, bcma, ssb）冲突，当它们存在时将不能正常运行，所以要禁用它们。<br>在终端输入</p>
<blockquote>
<p>lsmod  | grep “brcmsmac|b43|ssb|bcma|wl”</p>
</blockquote>
<p>如果在返回信息中有显示其中的任何一个，就要删除之。<br>在终端输入</p>
<blockquote>
<p>sudo rmmod b43sudo rmmod brcmsmacsudo rmmod ssbsudo rmmod bcmasudo rmmod wl</p>
</blockquote>
<p>这样来删除这些模块。<br>3、为了防止以后其中的某个不听话的模块死而复生，我们还需要把它们列入黑名单。<br>输入</p>
<blockquote>
<p>sudo gedit /etc/modprobe.d/blacklist.conf</p>
</blockquote>
<p>在打开的文件最后一行加入下面内容，来给它们打上黑名单。</p>
<blockquote>
<p>blacklist ssb</p>
</blockquote>
<blockquote>
<p>blacklist bcma</p>
</blockquote>
<blockquote>
<p>blacklist b43</p>
</blockquote>
<blockquote>
<p>blacklist brcmsmac</p>
</blockquote>
<p>4、下面是关键，我之前装显卡驱动时就是在这一步上卡了好久。</p>
<p>光是在文件中加入黑名单列表还不够，必须更新当前的ramfs（内存文件系统？这个我真的没有什么研究）。linux系统下的好多操作之后都要执行下面的一步。<br>输入</p>
<p><code>sudo cp /boot/initrd.img-`uname -r\` /home/initrd.img-\`uname -r\`</code></p>
<p>来备份initrd.img<br>输入</p>
<blockquote>
<p>sudo update-initramfs -u</p>
</blockquote>
<p>来更新initrd.img<br>接着重启电脑，使刚才的操作生效。</p>
<h4 id="二、解压并编译安装文件"><a href="#二、解压并编译安装文件" class="headerlink" title="二、解压并编译安装文件"></a>二、解压并编译安装文件</h4><p>1、打开终端，cd到/home （如果说刚打开终端就不用进行这一步了，终端打开后默认就定位在这个文件夹）<br>输入</p>
<blockquote>
<p>mkdir hybrid_wl<br>cd hybrid_wl</p>
</blockquote>
<p>把你下载的.gz格式的驱动程序放到/home/hybrid_wl下，把它重命名成hybrid.tar.gz （重命名是为了下面输入方便）<br>2、在终端输入 tar xzf hybrid.tar.gz 以解压gz文件<br>继续输入</p>
<blockquote>
<p>make clean<br>make</p>
</blockquote>
<p>是的，这两个指令没有参数。。。等操作完成后，在hybrid_wl文件夹下应该已经生成了一个wl.ko文件，它就是无线网卡的驱动模块了！<br>3、这个驱动使用的是cfg80211 API ，所以还要在终端继续输入</p>
<blockquote>
<p>make API=CFG80211</p>
</blockquote>
<p>至此，无线网卡驱动的编译就结束了。</p>
<h4 id="三、激活驱动模块"><a href="#三、激活驱动模块" class="headerlink" title="三、激活驱动模块"></a>三、激活驱动模块</h4><p>1、在激活无线网卡驱动模块之前，还需要激活一个安全模块，ubuntu系统使用的是lib80211<br>在终端中输入</p>
<blockquote>
<p>sudo modprobe lib80211</p>
</blockquote>
<p>2、在终端中输入</p>
<blockquote>
<p>sudo insmod wl.ko</p>
</blockquote>
<p>激动人心的时刻到来了！输完这项指令后无线网卡驱动模块被激活，看看你的右上角，是不是已经能够搜到附近的热点了？ ;)<br>四、设置无线网卡驱动开机自启动<br>经过上面的操作之后，我们已经成功的激活了驱动，但是，注意但是，还有最后一步要走。那就是设置驱动模块开机自启动。<br>输入</p>
<blockquote>
<p>sudo cp wl.ko /lib/modules/<code>uname -r</code>/kernel/drivers/net/wireless //把wl.ko拷到加载模块的文件夹<br>sudo depmod -a //分析模块的相依性，供modprobe在安装模块时使用</p>
</blockquote>
<p>输入</p>
<blockquote>
<p>sudo gedit /etc/rc.local</p>
</blockquote>
<p>在打开的文件exit 0上面一行加入<br>modeprobe wl保存退出<br>这样驱动就可以开机自启动了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>包括无线网卡驱动的安装在内，与windows相比，linux下的许多看似本应简单的操作会变得不简单，也许是安装的困难，也许是安装后的枯燥配置，这就需要我们耐住性子，一步一步寻找解决方案。渐渐地，我们会在这个过程体会到linux的自由之美。</p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>《PyTorch深度学习实践》3.逻辑斯蒂回归 笔记.md</title>
    <url>/archives/17385.html</url>
    <content><![CDATA[<h1 id="逻辑斯蒂回归"><a href="#逻辑斯蒂回归" class="headerlink" title="逻辑斯蒂回归"></a>逻辑斯蒂回归</h1><p>逻辑斯蒂回归是一个<strong>分类模型</strong></p>
<h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>相比于回归，分类问题的结果是离散的值（或者类别的概率）</p>
<a id="more"></a>
<h3 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h3><p>$$<br>\sigma(x)=\frac{1}{1+e^{-x}}<br>$$</p>
<p><img src="/images/3. 逻辑斯蒂回归.assets/image-20200731213425792.png" alt="image-20200731213425792"></p>
<p>上面的逻辑函数是sigmoid函数（其实sigmoid是一类函数的叫法，特征是$[-1,1]$内单增的饱和函数，逻辑函数是其中最典型的一种），它是一个饱和函数（随着值的增大导数趋近于零），作用是把无穷区间上的值映射到$[0.0,1.0]$之间。最简单的做法，可以把线性模型$\hat{y} = x * \omega + b$的输出作为sigmoid的输入，以得到$[0.0,1.0]$之间的概率：</p>
<p><img src="/images/3. 逻辑斯蒂回归.assets/image-20200731214414898.png" alt="image-20200731214414898"></p>
<p>对应的损失函数也要发生变化：</p>
<p><img src="/images/3. 逻辑斯蒂回归.assets/image-20200731214647221.png" alt="image-20200731214647221"></p>
<p>上图中的第二个loss函数就是交叉熵：</p>
<p>假设有两个概率分布$P_D$和$P_T$，则衡量它们差异的交叉熵公式为：</p>
<p>$$<br>\Sigma_iP_D(X=i)\ln P_T(X=i)<br>$$</p>
<p>与一般的信息熵相比，主要差别在于<strong>事实</strong>的概率乘以<strong>预测</strong>的概率的ln</p>
<p>图中公式二（BCE, Binary Cross Entropy）优化的目标是loss最小，对应事实的分布与预测的分布最接近</p>
<p>针对多个样本的情况可以去一下均值：</p>
<p><img src="/images/3. 逻辑斯蒂回归.assets/image-20200731220930095.png" alt="image-20200731220930095"></p>
<h2 id="实验中所用代码"><a href="#实验中所用代码" class="headerlink" title="实验中所用代码"></a>实验中所用代码</h2><p>模型：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare dataset</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Design model using Class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegressionModel</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    super(LogisticRegressionModel, self).__init__()</span><br><span class="line">    self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    y_pred = torch.sigmoid(self.linear(x))</span><br><span class="line">    <span class="keyword">return</span> y_pred</span><br><span class="line">  </span><br><span class="line">model = LogisticRegressionModel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.BCELoss(size_average=<span class="literal">False</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Training cycle</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">  y_pred = model(x_data)</span><br><span class="line">  loss = criterion(y_pred, y_data)</span><br><span class="line">  print(epoch, loss.item())</span><br><span class="line"></span><br><span class="line">  optimizer.zero_grad()</span><br><span class="line">  loss.backward()</span><br><span class="line">  optimizer.step()</span><br></pre></td></tr></table></figure></p>
<p> 图形化：<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">x_t = torch.Tensor(x).view((<span class="number">200</span>, <span class="number">1</span>))  <span class="comment"># 类似于numpy中的reshape</span></span><br><span class="line">y_t = model(x_t)</span><br><span class="line">y = y_t.data.numpy()</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">10</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>], c=<span class="string">'r'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Hours'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Probability of Pass'</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><a href="https://colab.research.google.com/drive/1PrzFcvMjWJAPF1KJqFyUk186wZuKdYKW?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">在Colab上运行</a></p>
<p>课程来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=2" rel="external nofollow noopener noreferrer" target="_blank">《PyTorch深度学习实践》完结合集</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>《PyTorch深度学习实践》1.Overview 笔记</title>
    <url>/archives/5957.html</url>
    <content><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="几种思维方式"><a href="#几种思维方式" class="headerlink" title="几种思维方式"></a>几种思维方式</h2><h3 id="算法课"><a href="#算法课" class="headerlink" title="算法课"></a>算法课</h3><p>计算过程来自人工设计</p>
<ul>
<li>穷举法</li>
<li>贪心法</li>
<li>分治法</li>
<li>动态规划</li>
<li>…</li>
</ul>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>计算过程来自数据，基于统计，方法如最大似然、最大后验</p>
<ul>
<li>Data</li>
<li>DataSet</li>
</ul>
<a id="more"></a>
<h2 id="人工智能领域分类（出自Deep-learning-by-Bengio）"><a href="#人工智能领域分类（出自Deep-learning-by-Bengio）" class="headerlink" title="人工智能领域分类（出自Deep learning by Bengio）"></a>人工智能领域分类（出自<em>Deep learning by Bengio</em>）</h2><p><img src="/images/1. Overview 笔记.assets/image-20200727220619808.png" alt="image-20200727220619808"></p>
<p>注意这里面的表示学习，早期方法如shallow autoencoders</p>
<h3 id="基于规则的系统（早期人工智能方案）"><a href="#基于规则的系统（早期人工智能方案）" class="headerlink" title="基于规则的系统（早期人工智能方案）"></a>基于规则的系统（早期人工智能方案）</h3><p><img src="/images/1. Overview 笔记.assets/image-20200727221448608.png" alt="image-20200727221448608"></p>
<h3 id="传统机器学习"><a href="#传统机器学习" class="headerlink" title="传统机器学习"></a>传统机器学习</h3><p><img src="/images/1. Overview 笔记.assets/image-20200727221550455.png" alt="image-20200727221550455"></p>
<p>这里强调Hand-designed feature，特征需人工提取。曾经较火的模型如SVM。</p>
<p><img src="/images/1. Overview 笔记.assets/image-20200727223034331.png" alt="image-20200727223034331"></p>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul>
<li>手动设计的特征有限</li>
<li>SVM对大数据集处理能力有限</li>
<li>许多应用需要处理无结构数据，机器学习对这类数据需要手动构建特征</li>
</ul>
<h3 id="表示学习（Representation-learning）"><a href="#表示学习（Representation-learning）" class="headerlink" title="表示学习（Representation learning）"></a>表示学习（Representation learning）</h3><blockquote>
<p>补充：维度诅咒</p>
<p>feature增加，对样本数要求非线性增加<br>对应的需求：压缩维度</p>
</blockquote>
<p>表示学习希望能用低维空间表示高维空间的信息。方法如<em>Manifold流形</em>。</p>
<p><img src="/images/1. Overview 笔记.assets/image-20200727222431377.png" alt="image-20200727222431377"></p>
<p>深度学习所利用的特征更加简单了，不需要手动提取feature。Deep learning的训练过程是end-to-end的<br>目前的神经网络，来源于神经科学，但应用上更接近于数学和工程学<br>神经网络最重要的算法是back-propagation，基于计算图</p>
<h3 id="深度学习近几年的发展"><a href="#深度学习近几年的发展" class="headerlink" title="深度学习近几年的发展"></a>深度学习近几年的发展</h3><ul>
<li>算法更新</li>
<li>数据增多</li>
<li>算力变强</li>
</ul>
<p>课程来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=1" rel="external nofollow noopener noreferrer" target="_blank">《PyTorch深度学习实践》完结合集</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>《PyTorch深度学习实践》2.线性模型 笔记</title>
    <url>/archives/21981.html</url>
    <content><![CDATA[<h1 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol>
<li>Dataset<br> <code>traing set</code>, <code>dev set</code>, <code>test set</code></li>
<li>Model</li>
<li>Training</li>
<li>infering</li>
</ol>
<h2 id="线性模型-1"><a href="#线性模型-1" class="headerlink" title="线性模型"></a>线性模型</h2><h3 id="Linear-model"><a href="#Linear-model" class="headerlink" title="Linear model"></a>Linear model</h3><p>$$<br>\hat{y} = x * \omega<br>$$</p>
<p>上面是本次实验中用到的<br>更一般的线性模型要加一个偏置b，形式如下：</p>
<p>$$<br>\hat{y} = x * \omega + b<br>$$</p>
<h3 id="Training-Loss-Error"><a href="#Training-Loss-Error" class="headerlink" title="Training Loss(Error)"></a>Training Loss(Error)</h3><p>$$<br>loss = (\hat{y}-y)^2=(x*\omega-y)^2<br>$$</p>
<p>这是针对每一个样本的</p>
<a id="more"></a>
<h3 id="Mean-Square-Error"><a href="#Mean-Square-Error" class="headerlink" title="Mean Square Error"></a>Mean Square Error</h3><p>$$<br>cost = \frac{1}{N}\Sigma_{n=1}^{N}(\hat{y_n}-y_n)^2<br>$$</p>
<p>这是针对整个测试集的</p>
<h3 id="实验中所采用代码"><a href="#实验中所采用代码" class="headerlink" title="实验中所采用代码"></a>实验中所采用代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x * w</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  y_pred = forward(x)</span><br><span class="line">  <span class="keyword">return</span> (y_pred - y) * (y_pred - y)</span><br><span class="line"></span><br><span class="line">w_list = []</span><br><span class="line">mse_list = []</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>):</span><br><span class="line">  print(<span class="string">'w='</span>, w)</span><br><span class="line">  l_sum =<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> zip(x_data, y_data):</span><br><span class="line">    y_pred_val = forward(x_val)</span><br><span class="line">    loss_val = loss(x_val, y_val)</span><br><span class="line">    l_sum += loss_val</span><br><span class="line">    print(<span class="string">'\t'</span>, x_val, y_val, y_pred_val, loss_val)</span><br><span class="line">  print(<span class="string">'MSE='</span>, l_sum / <span class="number">3</span>)</span><br><span class="line">  w_list.append(w)</span><br><span class="line">  mse_list.append(l_sum / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(w_list, mse_list)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'w'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>其中对于参数w是采用枚举的方式来找的，实际不会采用这个做法。但调超参的话理论上可以用类似暴力的做法（虽然如果在公用机器上这么做会被骂）</p>
<p><a href="https://colab.research.google.com/drive/1_bwu8HW5jVRRaHwLURPaMkopz6ZwIBTp?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">在Colab上运行</a></p>
<p>课程来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=2" rel="external nofollow noopener noreferrer" target="_blank">《PyTorch深度学习实践》完结合集</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>计蒜客31445 (Made In Heaven)[A*，第K最短路]</title>
    <url>/archives/20320.html</url>
    <content><![CDATA[<p><strong>题目链接：</strong><a href="https://nanti.jisuanke.com/t/31445" rel="external nofollow noopener noreferrer" target="_blank">https://nanti.jisuanke.com/t/31445</a></p>
<p>题目大意：给定一张图，问第K最短路的长度是否小于给定值T<br>求第K最短路，令$f=g+h$，$g$为当前已经走过的距离，$h$为当前点到终点的最短距离<br>从起点开始拓展，每次选择$f$最短的点进行拓展（入队），每次出队时检查是否走到终点并统计终点出队次数，当终点出队次数为$k$时当前点的$g$就是答案<br>可以这样考虑：每次严格按照估价函数进行拓展，则第一次走到终点的方案一定是最短路，第二次就是第2最短路，第k次就是第k最短路<br>这样先用spfa预处理出每个节点的$h$再用A*拓展即可</p>
<p>这题还有一个需要注意的地方：A*用的优先队列很有可能在使用完后没有被清空（因为函数可能提前退出了），此时如果直接用会MLE，而如果用一个一个pop的方式清空会直接TLE，所以比较好的解决方法是直接把优先队列写在函数体内部，这样就不用清空了</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">10009</span>;</span><br><span class="line"><span class="keyword">int</span> s,t,k,up,n,m;</span><br><span class="line"><span class="keyword">int</span> head[maxn],revhead[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,next;</span><br><span class="line"></span><br><span class="line">&#125;ed[maxm],reved[maxm];</span><br><span class="line"><span class="keyword">int</span> ne1=<span class="number">0</span>,ne2=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	    <span class="built_in">memset</span>(revhead,<span class="number">-1</span>,<span class="keyword">sizeof</span>(revhead));</span><br><span class="line">		    ne1=<span class="number">0</span>;</span><br><span class="line">			    ne2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    ed[ne1].v=v;ed[ne1].w=w;ed[ne1].next=head[u];head[u]=ne1++;</span><br><span class="line">	    reved[ne2].v=u;reved[ne2].w=w;reved[ne2].next=revhead[v];revhead[v]=ne2++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) h[i]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">		    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">			    h[t]=<span class="number">0</span>;</span><br><span class="line">				    vis[t]=<span class="literal">true</span>;</span><br><span class="line">					    q.push(t);</span><br><span class="line">						<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">						        <span class="keyword">int</span> now=q.top(); q.pop();</span><br><span class="line">								<span class="keyword">for</span>(<span class="keyword">int</span> i=revhead[now],v;~i;i=reved[i].next) &#123;</span><br><span class="line">								            v=reved[i].v;</span><br><span class="line">											<span class="keyword">if</span>(h[v]&gt;h[now]+reved[i].w) &#123;</span><br><span class="line">											                h[v]=h[now]+reved[i].w;</span><br><span class="line">															<span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">															                    vis[v]=<span class="literal">true</span>;</span><br><span class="line">																				                    q.push(v);</span><br><span class="line">																									                </span><br><span class="line">															&#125;</span><br><span class="line">															            </span><br><span class="line">											&#125;</span><br><span class="line">											        </span><br><span class="line">								&#125;</span><br><span class="line">								        vis[now]=<span class="literal">false</span>;</span><br><span class="line">										    </span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,g,v;</span><br><span class="line">	    Node(<span class="keyword">int</span> _f,<span class="keyword">int</span> _g,<span class="keyword">int</span> _v):f(_f),g(_g),v(_v) &#123;&#125;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;y) <span class="keyword">const</span> &#123;</span><br><span class="line">		        <span class="keyword">if</span>(f==y.f) <span class="keyword">return</span> g&gt;y.g;</span><br><span class="line">				        <span class="keyword">return</span> f&gt;y.f;</span><br><span class="line">						    </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">astar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line">	    <span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">		    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">			    <span class="keyword">if</span>(h[s]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//</span></span><br><span class="line">				    pq.push(Node(<span class="number">0</span>+h[s],<span class="number">0</span>,s));</span><br><span class="line">					    <span class="keyword">if</span>(s==t) k++;</span><br><span class="line">						<span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">						        Node now=pq.top(); pq.pop();</span><br><span class="line">								        <span class="keyword">if</span>(now.v==t) ++cnt;</span><br><span class="line">										<span class="keyword">if</span>(cnt==k) &#123;</span><br><span class="line">										            <span class="keyword">if</span>(now.g&lt;=up) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">													            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">																        </span><br><span class="line">										&#125;</span><br><span class="line">										<span class="keyword">for</span>(<span class="keyword">int</span> i=head[now.v],v;~i;i=ed[i].next) &#123;</span><br><span class="line">										            <span class="comment">//if(i&amp;1) continue;</span></span><br><span class="line">													            v=ed[i].v;</span><br><span class="line">																            pq.push(Node(now.g+ed[i].w+h[v],now.g+ed[i].w,v));</span><br><span class="line">																			        </span><br><span class="line">										&#125;</span><br><span class="line">										    </span><br><span class="line">						&#125;</span><br><span class="line">						    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">	    <span class="comment">//printf("%d",0x3f3f3f3f);</span></span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">	        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;s,&amp;t,&amp;k,&amp;up);</span><br><span class="line">			        init();</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">					            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">								            add(u,v,w);</span><br><span class="line">											        </span><br><span class="line">					&#125;</span><br><span class="line">					        spfa();</span><br><span class="line">							        <span class="built_in">printf</span>(astar()?<span class="string">"yareyaredawa\n"</span>:<span class="string">"Whitesnake!\n"</span>);</span><br><span class="line">									    </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>A\*</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>\[2019春软件构造\]面向可复用的软件构造</title>
    <url>/archives/4111.html</url>
    <content><![CDATA[<h2 id="设计可复用的类"><a href="#设计可复用的类" class="headerlink" title="设计可复用的类"></a>设计可复用的类</h2><h3 id="Liskov替换原则-LSP"><a href="#Liskov替换原则-LSP" class="headerlink" title="Liskov替换原则(LSP)"></a>Liskov替换原则(LSP)</h3><blockquote>
<p>Let q(x) be a property provable about objects x of type T, then q(y) should be provable for objects y of type S where S is a subtype of T.</p>
<p>– Barbara Liskov</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">Animal c1 = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>
<p>在可以使用a的场景，都可以用c1和c2代替而不会有任何问题。</p>
<p>Liskov替换原则是衍生子类需要遵循的重要原则，它使得客户端可用统一的方式处理不同类型的对象，LSP要求子类相对于父类具有：</p>
<ul>
<li>更强的不变量</li>
<li>更弱的前置条件</li>
<li>更强的后置条件</li>
</ul>
<p>注：更强的后置条件要求子类型中不能产生新的异常。</p>
<p>父类与子类的衔接类似于一个漏斗。</p>
<h2 id="委派-Delegation-与组合-Composition"><a href="#委派-Delegation-与组合-Composition" class="headerlink" title="委派(Delegation)与组合(Composition)"></a>委派(Delegation)与组合(Composition)</h2><h3 id="A-simple-Delegation-example"><a href="#A-simple-Delegation-example" class="headerlink" title="A simple Delegation example"></a>A simple Delegation example</h3><p>B类为对A类的一个委派，在B类中的私有字段a绑定了一个A类，B类的foo操作被委派给绑定的a来做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"a.bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a; <span class="comment">// delegation link</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.foo(); <span class="comment">// call foo() on the a-instance</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"b.bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立绑定关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> B(a); <span class="comment">// establish delegation between two objects</span></span><br></pre></td></tr></table></figure>
<h3 id="Delegation-vs-Inheritance"><a href="#Delegation-vs-Inheritance" class="headerlink" title="Delegation vs Inheritance"></a>Delegation vs Inheritance</h3><p>From <a href="https://www.geeksforgeeks.org/delegation-vs-inheritance-java/" rel="external nofollow noopener noreferrer" target="_blank">GeeksforGeeks</a></p>
<blockquote>
<p><strong>Delegation</strong> is simply passing a duty off to someone/something else.</p>
<ul>
<li>Delegation can be an alternative to inheritance.</li>
<li>Delegation means that you use an object of another class as an instance variable, and forward messages to the instance.</li>
<li>It is better than inheritance for many cases because it makes you to think about each message you forward, because the instance is of a known class, rather than a new class, and because it doesn’t force you to accept all the methods of the super class: you can provide only the methods that really make sense.</li>
<li>Delegation can be viewed as a relationship between objects where one object forwards certain method calls to another object, called its delegate.</li>
<li>The primary advantage of delegation is run-time flexibility – the delegate can easily be changed at run-time. But unlike inheritance, delegation is not directly supported by most popular object-oriented languages, and it doesn’t facilitate <a href="https://www.geeksforgeeks.org/dynamic-method-dispatch-runtime-polymorphism-java/" rel="external nofollow noopener noreferrer" target="_blank">dynamic polymorphism</a>.</li>
</ul>
</blockquote>
<p>Delegation可以作为继承的一个替代品，它最主要的优点是<strong>灵活</strong>。相比于继承，它不需要继承另一个类的所有方法，而是可以通过委派机制调用部分方法；同时它支持类的<strong>动态绑定</strong>。</p>
<p><strong>Delegation发生在object层面，Inheritance发生在class层面。</strong></p>
<h2 id="几类常见Delegation"><a href="#几类常见Delegation" class="headerlink" title="几类常见Delegation"></a>几类常见Delegation</h2><h3 id="Dependency-临时性的delegation"><a href="#Dependency-临时性的delegation" class="headerlink" title="Dependency: 临时性的delegation"></a>Dependency: 临时性的delegation</h3><p>Dependency在调用函数时传入delegation类，并将操作委派给传入的类处理，是一种临时的delegation关系。</p>
<p>类与被委派的类之间的关系为<strong>uses-a</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flyable f = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">Duck d = <span class="keyword">new</span> Duck();</span><br><span class="line">d.fly(f);</span><br></pre></td></tr></table></figure>
<p>Duck类的定义如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Association-永久性的delegation"><a href="#Association-永久性的delegation" class="headerlink" title="Association: 永久性的delegation"></a>Association: 永久性的delegation</h3><p>Association是一种永久的delegation关系，delegation关系通过将被委派的类存入字段的方式来实现。</p>
<p>类与被委派的类之间的关系为<strong>has-a</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flyable f = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">Duck d = <span class="keyword">new</span> Duck(f);</span><br><span class="line">d.fly();</span><br><span class="line">d.setFlyBehavior(<span class="keyword">new</span> CannotFly());</span><br><span class="line">d.fly();</span><br></pre></td></tr></table></figure>
<p>Duck类的定义如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    Flyable f;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Duck</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.f = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.f = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Composition-更强的association"><a href="#Composition-更强的association" class="headerlink" title="Composition: 更强的association"></a>Composition: 更强的association</h3><p>Composition与Association类似，均将delegation关系存入字段。但不同之处在于Composition将委派关系的绑定写入了代码，在运行时委派关系不可变。</p>
<p>被委派的类与类之间的关系为<strong>is_part_of</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duck d = <span class="keyword">new</span> Duck();</span><br><span class="line">d.fly();</span><br></pre></td></tr></table></figure>
<p>Duck类的定义如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    Flyable f = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Aggregation-更弱的-association"><a href="#Aggregation-更弱的-association" class="headerlink" title="Aggregation: 更弱的 association"></a>Aggregation: 更弱的 association</h3><p>Aggregation与Composition类似，均将delegation关系存入字段。与Composition的不同之处在于委派关系在运行时可变。</p>
<p>Aggregation与Composition还具有以下不同：Aggregation关系中的两个类不具有相互依存关系，而Composition中的两个类具有依附关系，即如果A has-a B，那么B不能脱离A存在。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>软件构造</tag>
      </tags>
  </entry>
</search>
