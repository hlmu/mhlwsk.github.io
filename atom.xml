<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木屋</title>
  
  <subtitle>mhlwsk的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mhlwsk.com/"/>
  <updated>2020-07-31T14:50:23.590Z</updated>
  <id>https://www.mhlwsk.com/</id>
  
  <author>
    <name>mhlwsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《PyTorch深度学习实践》3.逻辑斯蒂回归 笔记.md</title>
    <link href="https://www.mhlwsk.com/archives/17385.html"/>
    <id>https://www.mhlwsk.com/archives/17385.html</id>
    <published>2020-07-31T14:48:47.000Z</published>
    <updated>2020-07-31T14:50:23.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑斯蒂回归"><a href="#逻辑斯蒂回归" class="headerlink" title="逻辑斯蒂回归"></a>逻辑斯蒂回归</h1><p>逻辑斯蒂回归是一个<strong>分类模型</strong></p><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>相比于回归，分类问题的结果是离散的值（或者类别的概率）</p><a id="more"></a><h3 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h3><p>$$<br>\sigma(x)=\frac{1}{1+e^{-x}}<br>$$</p><p><img src="/images/3. 逻辑斯蒂回归.assets/image-20200731213425792.png" alt="image-20200731213425792"></p><p>上面的逻辑函数是sigmoid函数（其实sigmoid是一类函数的叫法，特征是$[-1,1]$内单增的饱和函数，逻辑函数是其中最典型的一种），它是一个饱和函数（随着值的增大导数趋近于零），作用是把无穷区间上的值映射到$[0.0,1.0]$之间。最简单的做法，可以把线性模型$\hat{y} = x * \omega + b$的输出作为sigmoid的输入，以得到$[0.0,1.0]$之间的概率：</p><p><img src="/images/3. 逻辑斯蒂回归.assets/image-20200731214414898.png" alt="image-20200731214414898"></p><p>对应的损失函数也要发生变化：</p><p><img src="/images/3. 逻辑斯蒂回归.assets/image-20200731214647221.png" alt="image-20200731214647221"></p><p>上图中的第二个loss函数就是交叉熵：</p><p>假设有两个概率分布$P_D$和$P_T$，则衡量它们差异的交叉熵公式为：</p><p>$$<br>\Sigma_iP_D(X=i)\ln P_T(X=i)<br>$$</p><p>与一般的信息熵相比，主要差别在于<strong>事实</strong>的概率乘以<strong>预测</strong>的概率的ln</p><p>图中公式二（BCE, Binary Cross Entropy）优化的目标是loss最小，对应事实的分布与预测的分布最接近</p><p>针对多个样本的情况可以去一下均值：</p><p><img src="/images/3. 逻辑斯蒂回归.assets/image-20200731220930095.png" alt="image-20200731220930095"></p><h2 id="实验中所用代码"><a href="#实验中所用代码" class="headerlink" title="实验中所用代码"></a>实验中所用代码</h2><p>模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare dataset</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Design model using Class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegressionModel</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    super(LogisticRegressionModel, self).__init__()</span><br><span class="line">    self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    y_pred = torch.sigmoid(self.linear(x))</span><br><span class="line">    <span class="keyword">return</span> y_pred</span><br><span class="line">  </span><br><span class="line">model = LogisticRegressionModel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct loss and optimizer</span></span><br><span class="line">criterion = torch.nn.BCELoss(size_average=<span class="literal">False</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Training cycle</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">  y_pred = model(x_data)</span><br><span class="line">  loss = criterion(y_pred, y_data)</span><br><span class="line">  print(epoch, loss.item())</span><br><span class="line"></span><br><span class="line">  optimizer.zero_grad()</span><br><span class="line">  loss.backward()</span><br><span class="line">  optimizer.step()</span><br></pre></td></tr></table></figure></p><p> 图形化：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">x_t = torch.Tensor(x).view((<span class="number">200</span>, <span class="number">1</span>))  <span class="comment"># 类似于numpy中的reshape</span></span><br><span class="line">y_t = model(x_t)</span><br><span class="line">y = y_t.data.numpy()</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">10</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>], c=<span class="string">'r'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Hours'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Probability of Pass'</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><a href="https://colab.research.google.com/drive/1PrzFcvMjWJAPF1KJqFyUk186wZuKdYKW?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">在Colab上运行</a></p><p>课程来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=2" rel="external nofollow noopener noreferrer" target="_blank">《PyTorch深度学习实践》完结合集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;逻辑斯蒂回归&quot;&gt;&lt;a href=&quot;#逻辑斯蒂回归&quot; class=&quot;headerlink&quot; title=&quot;逻辑斯蒂回归&quot;&gt;&lt;/a&gt;逻辑斯蒂回归&lt;/h1&gt;&lt;p&gt;逻辑斯蒂回归是一个&lt;strong&gt;分类模型&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分类问题&quot;&gt;&lt;a href=&quot;#分类问题&quot; class=&quot;headerlink&quot; title=&quot;分类问题&quot;&gt;&lt;/a&gt;分类问题&lt;/h2&gt;&lt;p&gt;相比于回归，分类问题的结果是离散的值（或者类别的概率）&lt;/p&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://www.mhlwsk.com/tags/PyTorch/"/>
    
      <category term="深度学习" scheme="https://www.mhlwsk.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《PyTorch深度学习实践》2.线性模型 笔记</title>
    <link href="https://www.mhlwsk.com/archives/21981.html"/>
    <id>https://www.mhlwsk.com/archives/21981.html</id>
    <published>2020-07-30T16:31:17.000Z</published>
    <updated>2020-07-31T14:47:50.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol><li>Dataset<br> <code>traing set</code>, <code>dev set</code>, <code>test set</code></li><li>Model</li><li>Training</li><li>infering</li></ol><h2 id="线性模型-1"><a href="#线性模型-1" class="headerlink" title="线性模型"></a>线性模型</h2><h3 id="Linear-model"><a href="#Linear-model" class="headerlink" title="Linear model"></a>Linear model</h3><p>$$<br>\hat{y} = x * \omega<br>$$</p><p>上面是本次实验中用到的<br>更一般的线性模型要加一个偏置b，形式如下：</p><p>$$<br>\hat{y} = x * \omega + b<br>$$</p><h3 id="Training-Loss-Error"><a href="#Training-Loss-Error" class="headerlink" title="Training Loss(Error)"></a>Training Loss(Error)</h3><p>$$<br>loss = (\hat{y}-y)^2=(x*\omega-y)^2<br>$$<br>这是针对每一个样本的</p><a id="more"></a><h3 id="Mean-Square-Error"><a href="#Mean-Square-Error" class="headerlink" title="Mean Square Error"></a>Mean Square Error</h3><p>$$<br>cost = \frac{1}{N}\Sigma_{n=1}^{N}(\hat{y_n}-y_n)^2<br>$$<br>这是针对整个测试集的</p><h3 id="实验中所采用代码"><a href="#实验中所采用代码" class="headerlink" title="实验中所采用代码"></a>实验中所采用代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x * w</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  y_pred = forward(x)</span><br><span class="line">  <span class="keyword">return</span> (y_pred - y) * (y_pred - y)</span><br><span class="line"></span><br><span class="line">w_list = []</span><br><span class="line">mse_list = []</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> np.arange(<span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.1</span>):</span><br><span class="line">  print(<span class="string">'w='</span>, w)</span><br><span class="line">  l_sum =<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> zip(x_data, y_data):</span><br><span class="line">    y_pred_val = forward(x_val)</span><br><span class="line">    loss_val = loss(x_val, y_val)</span><br><span class="line">    l_sum += loss_val</span><br><span class="line">    print(<span class="string">'\t'</span>, x_val, y_val, y_pred_val, loss_val)</span><br><span class="line">  print(<span class="string">'MSE='</span>, l_sum / <span class="number">3</span>)</span><br><span class="line">  w_list.append(w)</span><br><span class="line">  mse_list.append(l_sum / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(w_list, mse_list)</span><br><span class="line">plt.ylabel(<span class="string">'Loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'w'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>其中对于参数w是采用枚举的方式来找的，实际不会采用这个做法。但调超参的话理论上可以用类似暴力的做法（虽然如果在公用机器上这么做会被骂）</p><p><a href="https://colab.research.google.com/drive/1_bwu8HW5jVRRaHwLURPaMkopz6ZwIBTp?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">在Colab上运行</a></p><p>课程来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=2" rel="external nofollow noopener noreferrer" target="_blank">《PyTorch深度学习实践》完结合集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性模型&quot;&gt;&lt;a href=&quot;#线性模型&quot; class=&quot;headerlink&quot; title=&quot;线性模型&quot;&gt;&lt;/a&gt;线性模型&lt;/h1&gt;&lt;h2 id=&quot;基本流程&quot;&gt;&lt;a href=&quot;#基本流程&quot; class=&quot;headerlink&quot; title=&quot;基本流程&quot;&gt;&lt;/a&gt;基本流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Dataset&lt;br&gt; &lt;code&gt;traing set&lt;/code&gt;, &lt;code&gt;dev set&lt;/code&gt;, &lt;code&gt;test set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Model&lt;/li&gt;
&lt;li&gt;Training&lt;/li&gt;
&lt;li&gt;infering&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;线性模型-1&quot;&gt;&lt;a href=&quot;#线性模型-1&quot; class=&quot;headerlink&quot; title=&quot;线性模型&quot;&gt;&lt;/a&gt;线性模型&lt;/h2&gt;&lt;h3 id=&quot;Linear-model&quot;&gt;&lt;a href=&quot;#Linear-model&quot; class=&quot;headerlink&quot; title=&quot;Linear model&quot;&gt;&lt;/a&gt;Linear model&lt;/h3&gt;&lt;p&gt;$$&lt;br&gt;\hat{y} = x * \omega&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;上面是本次实验中用到的&lt;br&gt;更一般的线性模型要加一个偏置b，形式如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\hat{y} = x * \omega + b&lt;br&gt;$$&lt;/p&gt;
&lt;h3 id=&quot;Training-Loss-Error&quot;&gt;&lt;a href=&quot;#Training-Loss-Error&quot; class=&quot;headerlink&quot; title=&quot;Training Loss(Error)&quot;&gt;&lt;/a&gt;Training Loss(Error)&lt;/h3&gt;&lt;p&gt;$$&lt;br&gt;loss = (\hat{y}-y)^2=(x*\omega-y)^2&lt;br&gt;$$&lt;br&gt;这是针对每一个样本的&lt;/p&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://www.mhlwsk.com/tags/PyTorch/"/>
    
      <category term="深度学习" scheme="https://www.mhlwsk.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《PyTorch深度学习实践》1.Overview 笔记</title>
    <link href="https://www.mhlwsk.com/archives/5957.html"/>
    <id>https://www.mhlwsk.com/archives/5957.html</id>
    <published>2020-07-30T16:27:18.000Z</published>
    <updated>2020-07-31T14:41:10.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="几种思维方式"><a href="#几种思维方式" class="headerlink" title="几种思维方式"></a>几种思维方式</h2><h3 id="算法课"><a href="#算法课" class="headerlink" title="算法课"></a>算法课</h3><p>计算过程来自人工设计</p><ul><li>穷举法</li><li>贪心法</li><li>分治法</li><li>动态规划</li><li>…</li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>计算过程来自数据，基于统计，方法如最大似然、最大后验</p><ul><li>Data</li><li>DataSet</li></ul><a id="more"></a><h2 id="人工智能领域分类（出自Deep-learning-by-Bengio）"><a href="#人工智能领域分类（出自Deep-learning-by-Bengio）" class="headerlink" title="人工智能领域分类（出自Deep learning by Bengio）"></a>人工智能领域分类（出自<em>Deep learning by Bengio</em>）</h2><p><img src="/images/1. Overview 笔记.assets/image-20200727220619808.png" alt="image-20200727220619808"></p><p>注意这里面的表示学习，早期方法如shallow autoencoders</p><h3 id="基于规则的系统（早期人工智能方案）"><a href="#基于规则的系统（早期人工智能方案）" class="headerlink" title="基于规则的系统（早期人工智能方案）"></a>基于规则的系统（早期人工智能方案）</h3><p><img src="/images/1. Overview 笔记.assets/image-20200727221448608.png" alt="image-20200727221448608"></p><h3 id="传统机器学习"><a href="#传统机器学习" class="headerlink" title="传统机器学习"></a>传统机器学习</h3><p><img src="/images/1. Overview 笔记.assets/image-20200727221550455.png" alt="image-20200727221550455"></p><p>这里强调Hand-designed feature，特征需人工提取。曾经较火的模型如SVM。</p><p><img src="/images/1. Overview 笔记.assets/image-20200727223034331.png" alt="image-20200727223034331"></p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul><li>手动设计的特征有限</li><li>SVM对大数据集处理能力有限</li><li>许多应用需要处理无结构数据，机器学习对这类数据需要手动构建特征</li></ul><h3 id="表示学习（Representation-learning）"><a href="#表示学习（Representation-learning）" class="headerlink" title="表示学习（Representation learning）"></a>表示学习（Representation learning）</h3><blockquote><p>补充：维度诅咒</p><p>feature增加，对样本数要求非线性增加<br>对应的需求：压缩维度</p></blockquote><p>表示学习希望能用低维空间表示高维空间的信息。方法如<em>Manifold流形</em>。</p><p><img src="/images/1. Overview 笔记.assets/image-20200727222431377.png" alt="image-20200727222431377"></p><p>深度学习所利用的特征更加简单了，不需要手动提取feature。Deep learning的训练过程是end-to-end的<br>目前的神经网络，来源于神经科学，但应用上更接近于数学和工程学<br>神经网络最重要的算法是back-propagation，基于计算图</p><h3 id="深度学习近几年的发展"><a href="#深度学习近几年的发展" class="headerlink" title="深度学习近几年的发展"></a>深度学习近几年的发展</h3><ul><li>算法更新</li><li>数据增多</li><li>算力变强</li></ul><p>课程来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=1" rel="external nofollow noopener noreferrer" target="_blank">《PyTorch深度学习实践》完结合集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;h2 id=&quot;几种思维方式&quot;&gt;&lt;a href=&quot;#几种思维方式&quot; class=&quot;headerlink&quot; title=&quot;几种思维方式&quot;&gt;&lt;/a&gt;几种思维方式&lt;/h2&gt;&lt;h3 id=&quot;算法课&quot;&gt;&lt;a href=&quot;#算法课&quot; class=&quot;headerlink&quot; title=&quot;算法课&quot;&gt;&lt;/a&gt;算法课&lt;/h3&gt;&lt;p&gt;计算过程来自人工设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;穷举法&lt;/li&gt;
&lt;li&gt;贪心法&lt;/li&gt;
&lt;li&gt;分治法&lt;/li&gt;
&lt;li&gt;动态规划&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;机器学习&quot;&gt;&lt;a href=&quot;#机器学习&quot; class=&quot;headerlink&quot; title=&quot;机器学习&quot;&gt;&lt;/a&gt;机器学习&lt;/h3&gt;&lt;p&gt;计算过程来自数据，基于统计，方法如最大似然、最大后验&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data&lt;/li&gt;
&lt;li&gt;DataSet&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://www.mhlwsk.com/tags/PyTorch/"/>
    
      <category term="深度学习" scheme="https://www.mhlwsk.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>[2019春软件构造]期末总结(思维导图)</title>
    <link href="https://www.mhlwsk.com/archives/19868.html"/>
    <id>https://www.mhlwsk.com/archives/19868.html</id>
    <published>2019-06-24T13:33:44.000Z</published>
    <updated>2020-07-30T13:07:23.779Z</updated>
    
    <content type="html"><![CDATA[<p>图片较大，请右键另存为查看。<br><a id="more"></a></p><p><img src="/images/2019-software-construction/software-construction.png" alt="pic1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图片较大，请右键另存为查看。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mhlwsk.com/tags/Java/"/>
    
      <category term="软件构造" scheme="https://www.mhlwsk.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>\[2019春软件构造\]优化笔记：我是如何将实验五的建图操作压缩到1.5s的</title>
    <link href="https://www.mhlwsk.com/archives/3309.html"/>
    <id>https://www.mhlwsk.com/archives/3309.html</id>
    <published>2019-05-31T16:49:42.000Z</published>
    <updated>2020-07-30T13:07:23.779Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用JGraphT存储Social Network中的人际关系图结构，使用JGraphT中的预设算法压缩建图时间。</p><p>注：这里的建图时间包含最短路求解与轨道插入，下文重点优化最短路求解时间。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前写完软件构造Lab2时，rainywang有建议过将Lab2的Graph ADT进行封装以便之后的使用。</p><p>在写Lab3时的Social Network时，为了保存和处理关系图，一开始我直接迁移了Lab2的代码，将Lab2的ADT搬到Lab3并添加了数个API。但看到标签为Larger的几个文件，心里还是对Lab2中<strong>naïve</strong>的ADT实现感到担忧。仅仅一个返回邻接顶点的操作时间复杂度都要O(n)，明显它是不能够胜任Lab3或者之后的Lab5的性能要求的。</p><p>rainywang在Lab2课程结束时，不仅建议过封装Lab2的ADT，也提出了这样一个疑问：网上是否已经有相关图算法ADT了？这个既是疑问又带有明显暗示的说法让人感到不安，显然图算法这个轮子已经被人重造过很多次了，我当然有理由相信有人已经为之写出了不错的java库。</p><p>抱着找找看的心理，在Google上尝试搜索了下”java graph library”，在返回的第一个结果发现了<a href="https://jgrapht.org/" rel="external nofollow noopener noreferrer" target="_blank">JGraphT</a>，它的开源许可证为 <code>Eclipse Public License - v 2.0</code>。</p><p><img src="https://jgrapht.org/img/logo.png" alt="JGraphT Logo"></p><blockquote><h3 id="a-Java-library-of-graph-theory-data-structures-and-algorithms"><a href="#a-Java-library-of-graph-theory-data-structures-and-algorithms" class="headerlink" title="a Java library of graph theory data structures and algorithms"></a>a Java library of graph theory data structures and algorithms</h3><h3 id="flexible"><a href="#flexible" class="headerlink" title="flexible"></a><em>flexible</em></h3><h5 id="any-object-can-be-used-for-vertex-and-edge-types-with-full-type-safety-via-generics"><a href="#any-object-can-be-used-for-vertex-and-edge-types-with-full-type-safety-via-generics" class="headerlink" title="any object can be used for vertex and edge types, with full type safety via generics"></a><strong>any object</strong> can be used for vertex and edge types, with full <strong>type safety</strong> via generics</h5><h5 id="edges-can-be-directed-or-undirected-weighted-or-unweighted"><a href="#edges-can-be-directed-or-undirected-weighted-or-unweighted" class="headerlink" title="edges can be directed or undirected, weighted or unweighted"></a>edges can be <strong>directed</strong> or <strong>undirected</strong>, <strong>weighted</strong> or <strong>unweighted</strong></h5><h5 id="simple-graphs-multigraphs-and-pseudographs"><a href="#simple-graphs-multigraphs-and-pseudographs" class="headerlink" title="simple graphs, multigraphs, and pseudographs"></a><strong>simple graphs</strong>, <strong>multigraphs</strong>, and <strong>pseudographs</strong></h5><h3 id="powerful"><a href="#powerful" class="headerlink" title="powerful"></a><em>powerful</em></h3><h5 id="specialized-iterators-for-graph-traversal-DFS-BFS-etc"><a href="#specialized-iterators-for-graph-traversal-DFS-BFS-etc" class="headerlink" title="specialized iterators for graph traversal (DFS, BFS, etc)"></a>specialized <strong>iterators</strong> for graph traversal (<strong>DFS</strong>, <strong>BFS</strong>, etc)</h5><h5 id="algorithms-for-path-finding-clique-detection-isomorphism-detection-coloring-common-ancestors-tours-connectivity-matching-cycle-detection-partitions-cuts-flows-centrality-spanning-and-the-list-goes-on"><a href="#algorithms-for-path-finding-clique-detection-isomorphism-detection-coloring-common-ancestors-tours-connectivity-matching-cycle-detection-partitions-cuts-flows-centrality-spanning-and-the-list-goes-on" class="headerlink" title="algorithms for path finding, clique detection, isomorphism detection, coloring, common ancestors, tours, connectivity, matching, cycle detection, partitions, cuts, flows, centrality, spanning, and the list goes on"></a><strong>algorithms</strong> for path finding, clique detection, isomorphism detection, coloring, common ancestors, tours, connectivity, matching, cycle detection, partitions, cuts, flows, centrality, spanning, <strong>and the list goes on</strong></h5><h3 id="efficient"><a href="#efficient" class="headerlink" title="efficient"></a><em>efficient</em></h3><h5 id="designed-for-performance-with-near-native-speed-in-many-cases"><a href="#designed-for-performance-with-near-native-speed-in-many-cases" class="headerlink" title="designed for performance, with near-native speed in many cases"></a>designed for performance, with <strong>near-native</strong> speed in many cases</h5><h5 id="adapters-for-memory-optimized-fastutil-representation"><a href="#adapters-for-memory-optimized-fastutil-representation" class="headerlink" title="adapters for memory-optimized fastutil representation"></a>adapters for memory-optimized <strong>fastutil</strong> representation</h5></blockquote><p>支持带权有向边、无向边，实现好的BFS和最短路算法，以及<strong>高效率</strong>。满足了Lab3的所有要求，同时也许能顺便满足Lab5的性能需求。此时我还有些犹豫，因为我不确定在Lab3 deadline将至的情况下，JGraphT的学习成本是否可以平衡掉之后代码的调试时间。不过考虑到JGraphT的算法实现较全可以比较容易的满足需求的变化，以及著名的<em>Don’t reinvent the wheel</em>原则，我还是花了两个小时来阅读文档，事后证明这是一个没有让我后悔的决定。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>JGraphT的Graph ADT默认支持两种边：带权边<code>DefaultWeightedEdge</code>和无权边<code>DefaultEdge</code>。Social Network需要保存人与人之间的关系以及亲密度，且<code>312change</code>中人的关系是有向的。因此我创建了两张有向图，分别用于保存人与人之间的关系以及亲密度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Graph&lt;String, DefaultWeightedEdge&gt; intimacy = <span class="keyword">new</span> SimpleDirectedWeightedGraph&lt;&gt;(DefaultWeightedEdge<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//亲密度图</span></span><br><span class="line"><span class="keyword">protected</span> Graph&lt;String, DefaultEdge&gt; relation = <span class="keyword">new</span> SimpleDirectedGraph&lt;&gt;(DefaultEdge<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//关系图</span></span><br></pre></td></tr></table></figure><p>对节点和边的操作类似于Lab2中定义的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intimacy.addVertex(name1); <span class="comment">//插入节点</span></span><br><span class="line">DefaultWeightedEdge e = intimacy.addEdge(name1, name2); <span class="comment">//插入边</span></span><br><span class="line">intimacy.setEdgeWeight(e, intimacy); <span class="comment">//设置边权</span></span><br><span class="line">relation.removeEdge(name1, name2); <span class="comment">//删除边</span></span><br></pre></td></tr></table></figure><p>计算Friend所在的轨道需要得到Friend与中心点User的最短距离。担心之后可能出现奇怪的需求（如要求轨道以亲密度的最短距离来定义），我一开始没有根据<strong>关系没有边权</strong>或者说<strong>图边权相等</strong>这一条件采用BFS，而采用了在最短路问题中适用度更高的Dijkstra算法。JGraphT中的Dijkstra算法实现疑似使用了Decorator模式，调用十分简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DijkstraShortestPath&lt;String, DefaultEdge&gt; dijkstraAlg = <span class="keyword">new</span> DijkstraShortestPath&lt;&gt;(relation); <span class="comment">//定义算法</span></span><br><span class="line">SingleSourcePaths&lt;String, DefaultEdge&gt; iPaths = dijkstraAlg.getPaths(centralName); <span class="comment">//求以centralName为起点的单源最短路</span></span><br><span class="line"></span><br><span class="line">GraphPath&lt;String, DefaultEdge&gt; path = iPaths.getPath(name); <span class="comment">//获取name节点的最短路</span></span><br><span class="line"><span class="keyword">if</span>(path != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> track = path.getLength(); <span class="comment">//得到最短路距离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时对Lab3的Larger文件进行读取和建图操作时间已经压缩到了3s左右。</p><blockquote><p>这里还有一个有趣的插曲：在写完了Lab3不久，在一节形式语言与自动机课上，老师打趣地布置了一个画有2k个点的DFA的任务，并开玩笑说要画出这个图要相当一段时间，能画出这个图的学生期末加5分。JgraphT支持伪图非常适合用来表示自动机，而且自带GraphViz导出API。结果在下午老师布置那个任务之后的3个小时，我就画出了那张图。</p><p>这个项目放在<a href="https://github.com/mhlwsk/DFA" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/mhlwsk/DFA</a></p><p><del>果然软件构造助力数学课程的学习</del>。</p></blockquote><p>Lab5中的数据量急剧扩大，虽然Dijkstra的速度非常快（时间复杂度为O(E*log(E))，单纯建图只需要数秒），但仍有优化的余地。考虑到<strong>关系边权相等</strong>这一条件，我把Lab3中采用的Dijkstra换成了时间复杂度为O(n)的BFS，JGraphT中的BFS采用<strong>迭代器模式</strong>实现，它的调用也非常简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BreadthFirstIterator&lt;String, DefaultEdge&gt; bfsIterator = </span><br><span class="line">    <span class="keyword">new</span> BreadthFirstIterator&lt;&gt;(relation, centralName); <span class="comment">// 定义BFS序迭代器，以centralName为遍历起点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (bfsIterator.hasNext()) &#123;</span><br><span class="line">    String name = bfsIterator.next();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> distance = bfsIterator.getDepth(name); <span class="comment">// 获取BFS深度</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时Lab5中的<code>SocialNetworkCircle.txt</code>文件建图时间已经压缩到了1.5s左右。</p><blockquote><p>这里有一个插曲：搜索JgraphT的API时，我发现一个<a href="https://jgrapht.org/javadoc-SNAPSHOT/org/jgrapht/alg/shortestpath/BFSShortestPath.html" rel="external nofollow noopener noreferrer" target="_blank">BFSShortestPath&lt;V,E&gt;</a>类，它的API与之前用到的<code>DijkstraShortestPath&lt;V,E&gt;</code>一致。一开始我尝试直接把后者改成前者，但编译器提示<code>BFSShortestPath&lt;V,E&gt;</code>不存在。在确认了不是包导入的问题后，我查看了Github上BFSShortestPath的<a href="https://github.com/jgrapht/jgrapht/blob/master/jgrapht-core/src/main/java/org/jgrapht/alg/shortestpath/BFSShortestPath.java" rel="external nofollow noopener noreferrer" target="_blank">源码</a>，发现这个文件是<code>13 Feb</code>创建的。而截至此文写作时（<code>1 June</code>）JgraphT最新的<code>release 1.3.0</code>是在<code>13 Nov 2018</code>发布的。也即JGraphT的doc比release都要新。显然这是Javadoc基于最新的源码自动生成的，这里不得不感叹一下javadoc的强大。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>不要重新发明轮子</strong>，当面对一个具体问题时优先考虑下是否已经有较好的实现了，使用它们可能有助于减轻代码实现与调试导致的焦虑、脱发与偏头痛，并且能够获得较好的可靠性与效率。</p><p>不过，使用JGraphT似乎与过早优化原则相抵触：</p><blockquote><p><strong>Premature optimization is the root of all evil</strong> – Donald Knuth</p></blockquote><p>我的理解是，如果优化使得软件的其它各项指标（如可变性）急剧下降，那么滞后优化是必要的；而采用JGraphT作为一项优化使得应用的changeability反而有所增加，此时就不必拘泥教条。毕竟，软件开发的过程也是软件的各项指标相互折衷的过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文使用JGraphT存储Social Network中的人际关系图结构，使用JGraphT中的预设算法压缩建图时间。&lt;/p&gt;
&lt;p&gt;注：这里的建图时间包含最短路求解与轨道插入，下文重点优化最短路求解时间。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mhlwsk.com/tags/Java/"/>
    
      <category term="软件构造" scheme="https://www.mhlwsk.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>\[2019春软件构造\]面向可复用的软件构造</title>
    <link href="https://www.mhlwsk.com/archives/4111.html"/>
    <id>https://www.mhlwsk.com/archives/4111.html</id>
    <published>2019-05-26T13:51:33.000Z</published>
    <updated>2020-07-30T13:07:23.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计可复用的类"><a href="#设计可复用的类" class="headerlink" title="设计可复用的类"></a>设计可复用的类</h2><h3 id="Liskov替换原则-LSP"><a href="#Liskov替换原则-LSP" class="headerlink" title="Liskov替换原则(LSP)"></a>Liskov替换原则(LSP)</h3><blockquote><p>Let q(x) be a property provable about objects x of type T, then q(y) should be provable for objects y of type S where S is a subtype of T.</p><p>– Barbara Liskov</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">Animal c1 = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><p>在可以使用a的场景，都可以用c1和c2代替而不会有任何问题。</p><p>Liskov替换原则是衍生子类需要遵循的重要原则，它使得客户端可用统一的方式处理不同类型的对象，LSP要求子类相对于父类具有：</p><ul><li>更强的不变量</li><li>更弱的前置条件</li><li>更强的后置条件</li></ul><p>注：更强的后置条件要求子类型中不能产生新的异常。</p><p>父类与子类的衔接类似于一个漏斗。</p><h2 id="委派-Delegation-与组合-Composition"><a href="#委派-Delegation-与组合-Composition" class="headerlink" title="委派(Delegation)与组合(Composition)"></a>委派(Delegation)与组合(Composition)</h2><h3 id="A-simple-Delegation-example"><a href="#A-simple-Delegation-example" class="headerlink" title="A simple Delegation example"></a>A simple Delegation example</h3><p>B类为对A类的一个委派，在B类中的私有字段a绑定了一个A类，B类的foo操作被委派给绑定的a来做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"a.bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a; <span class="comment">// delegation link</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.foo(); <span class="comment">// call foo() on the a-instance</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"b.bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立绑定关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> B(a); <span class="comment">// establish delegation between two objects</span></span><br></pre></td></tr></table></figure><h3 id="Delegation-vs-Inheritance"><a href="#Delegation-vs-Inheritance" class="headerlink" title="Delegation vs Inheritance"></a>Delegation vs Inheritance</h3><p>From <a href="https://www.geeksforgeeks.org/delegation-vs-inheritance-java/" rel="external nofollow noopener noreferrer" target="_blank">GeeksforGeeks</a></p><blockquote><p><strong>Delegation</strong> is simply passing a duty off to someone/something else.</p><ul><li>Delegation can be an alternative to inheritance.</li><li>Delegation means that you use an object of another class as an instance variable, and forward messages to the instance.</li><li>It is better than inheritance for many cases because it makes you to think about each message you forward, because the instance is of a known class, rather than a new class, and because it doesn’t force you to accept all the methods of the super class: you can provide only the methods that really make sense.</li><li>Delegation can be viewed as a relationship between objects where one object forwards certain method calls to another object, called its delegate.</li><li>The primary advantage of delegation is run-time flexibility – the delegate can easily be changed at run-time. But unlike inheritance, delegation is not directly supported by most popular object-oriented languages, and it doesn’t facilitate <a href="https://www.geeksforgeeks.org/dynamic-method-dispatch-runtime-polymorphism-java/" rel="external nofollow noopener noreferrer" target="_blank">dynamic polymorphism</a>.</li></ul></blockquote><p>Delegation可以作为继承的一个替代品，它最主要的优点是<strong>灵活</strong>。相比于继承，它不需要继承另一个类的所有方法，而是可以通过委派机制调用部分方法；同时它支持类的<strong>动态绑定</strong>。</p><p><strong>Delegation发生在object层面，Inheritance发生在class层面。</strong></p><h2 id="几类常见Delegation"><a href="#几类常见Delegation" class="headerlink" title="几类常见Delegation"></a>几类常见Delegation</h2><h3 id="Dependency-临时性的delegation"><a href="#Dependency-临时性的delegation" class="headerlink" title="Dependency: 临时性的delegation"></a>Dependency: 临时性的delegation</h3><p>Dependency在调用函数时传入delegation类，并将操作委派给传入的类处理，是一种临时的delegation关系。</p><p>类与被委派的类之间的关系为<strong>uses-a</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flyable f = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">Duck d = <span class="keyword">new</span> Duck();</span><br><span class="line">d.fly(f);</span><br></pre></td></tr></table></figure><p>Duck类的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Association-永久性的delegation"><a href="#Association-永久性的delegation" class="headerlink" title="Association: 永久性的delegation"></a>Association: 永久性的delegation</h3><p>Association是一种永久的delegation关系，delegation关系通过将被委派的类存入字段的方式来实现。</p><p>类与被委派的类之间的关系为<strong>has-a</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flyable f = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">Duck d = <span class="keyword">new</span> Duck(f);</span><br><span class="line">d.fly();</span><br><span class="line">d.setFlyBehavior(<span class="keyword">new</span> CannotFly());</span><br><span class="line">d.fly();</span><br></pre></td></tr></table></figure><p>Duck类的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    Flyable f;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Duck</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.f = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.f = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Composition-更强的association"><a href="#Composition-更强的association" class="headerlink" title="Composition: 更强的association"></a>Composition: 更强的association</h3><p>Composition与Association类似，均将delegation关系存入字段。但不同之处在于Composition将委派关系的绑定写入了代码，在运行时委派关系不可变。</p><p>被委派的类与类之间的关系为<strong>is_part_of</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Duck d = <span class="keyword">new</span> Duck();</span><br><span class="line">d.fly();</span><br></pre></td></tr></table></figure><p>Duck类的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    Flyable f = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Aggregation-更弱的-association"><a href="#Aggregation-更弱的-association" class="headerlink" title="Aggregation: 更弱的 association"></a>Aggregation: 更弱的 association</h3><p>Aggregation与Composition类似，均将delegation关系存入字段。与Composition的不同之处在于委派关系在运行时可变。</p><p>Aggregation与Composition还具有以下不同：Aggregation关系中的两个类不具有相互依存关系，而Composition中的两个类具有依附关系，即如果A has-a B，那么B不能脱离A存在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计可复用的类&quot;&gt;&lt;a href=&quot;#设计可复用的类&quot; class=&quot;headerlink&quot; title=&quot;设计可复用的类&quot;&gt;&lt;/a&gt;设计可复用的类&lt;/h2&gt;&lt;h3 id=&quot;Liskov替换原则-LSP&quot;&gt;&lt;a href=&quot;#Liskov替换原则-LSP&quot; cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mhlwsk.com/tags/Java/"/>
    
      <category term="软件构造" scheme="https://www.mhlwsk.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>[2018 HIT CSAPP大作业] 程序人生 Hello’s P2P</title>
    <link href="https://www.mhlwsk.com/archives/44834.html"/>
    <id>https://www.mhlwsk.com/archives/44834.html</id>
    <published>2018-12-29T18:19:42.000Z</published>
    <updated>2020-07-30T13:07:23.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘-要"><a href="#摘-要" class="headerlink" title="摘  要"></a>摘  要</h1><p>计算机系统是由硬件和软件组成的，它们共同工作来运行应用程序。即使是最简单的一个应用程序，也需要计算机系统中的每个主要组成部分协调工作。本文以hello程序的运行为切入点，解释了当在系统上运行hello程序时，系统发生的编译、链接、加载、进程管理、存储管理等过程，以及它们的运行机制。<br><strong>关键词</strong>：操作系统；计算机组成原理；汇编<br><a id="more"></a></p><h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h2><p><strong>Hello的P2P（Program to process）和020（From Zero to Zero）过程</strong><br>用户在文本编辑器中编写代码得到hello.c。hello.c经过预处理（cpp）变成hello.i（修改了的源程序），经过编译（ccl）生成hello.s（汇编程序），经过汇编生成hello.o（可重定位目标程序），经过链接（ld）生成hello（可执行目标程序）。<br>用户键入命令，bash自行fork一个process，并在这个process中调用execve执行hello。execve加载hello，并调用_start函数，不久控制权被转移到hello的main函数。<br>hello调用write等系统函数在屏幕打印信息，随后退出，接下来终止的hello进程被父进程bash回收。<br>实验中所用的hello.c代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大作业的 hello.c 程序</span></span><br><span class="line"><span class="comment">// gcc -m64 -no-pie -fno-PIC hello.c -o hello</span></span><br><span class="line"><span class="comment">// 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等。</span></span><br><span class="line"><span class="comment">// 可以 运行 ps  jobs  pstree fg 等命令</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sleepsecs=<span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage: Hello 学号 姓名！\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello %s %s\n"</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">sleep(sleepsecs);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h2><p>硬件环境：Intel(R) Core(TM) i5-3320M CPU；8.00GB RAM<br>软件环境：Windows 10 64位；Vmware Workstation 14 Pro；Ubuntu 16.04 LTS 64位<br>开发工具：CodeBlocks 64位；Visual Studio Code；GCC 5.4.0；objdump；EDB；readelf；hexedit</p><h2 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h2><p>为编写本论文，生成的中间结果文件的名字以及文件的作用。</p><table><thead><tr><th>文件名称</th><th>文件作用</th></tr></thead><tbody><tr><td>hello.i</td><td>hello预处理之后的文本文件</td></tr><tr><td>hello.s</td><td>hello编译之后的汇编文件</td></tr><tr><td>hello.o</td><td>hello汇编之后的可重定位目标文件</td></tr><tr><td>hello</td><td>hello链接之后的可执行目标文件</td></tr><tr><td>hello_o.objdump</td><td>hello.o的反汇编代码</td></tr><tr><td>hello_o.elf</td><td>hello.o的ELF文件信息</td></tr><tr><td>hello.objdump</td><td>hello的反汇编代码</td></tr><tr><td>hello.elf</td><td>hello的ELF文件信息</td></tr><tr><td>test.c</td><td>测试用代码</td></tr></tbody></table><h2 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h2><p>本章简要介绍了hello的P2P，O2O过程，并列出了本次实验的环境和中间结果。</p><h1 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h1><h2 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h2><p>预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的#include &lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件拓展名。<br>这个过程为接下来的编译过程“简化”了代码。</p><h2 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h2><p><strong>预处理命令：cpp hello.c &gt; hello.i</strong><br><img src="/images/2018-HIT-CSAPP-hello/t1.png" alt="pic1"></p><h2 id="2-3-Hello的预处理结果解析"><a href="#2-3-Hello的预处理结果解析" class="headerlink" title="2.3 Hello的预处理结果解析"></a>2.3 Hello的预处理结果解析</h2><p><img src="/images/2018-HIT-CSAPP-hello/t2.png" alt="pic2"><br>经过预处理的hello代码被展开，在main之前插入了大量代码。这些代码是根据#include从stdio.h、unistd.h、stdlib.h中提取的，其中包含了printf的声明等。<br><img src="/images/2018-HIT-CSAPP-hello/t3.png" alt="pic3"></p><h2 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h2><p>hello.c在编译之前需要经过预处理步骤，该步骤会根据hello.c中以#开头的命令展开相应代码并修改原始的C程序，以便下一步编译。</p><h1 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h1><h2 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h2><p>编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。</p><h2 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h2><p><strong>编译命令：gcc -S hello.i -o hello.s</strong><br><img src="/images/2018-HIT-CSAPP-hello/t4.png" alt="pic4"></p><h2 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h2><h3 id="3-3-1-hello-s中出现的标识"><a href="#3-3-1-hello-s中出现的标识" class="headerlink" title="3.3.1 hello.s中出现的标识"></a>3.3.1 hello.s中出现的标识</h3><ul><li>.file 源文件</li><li>.data 数据段</li><li>.globl 全局标识符</li><li>.string 字符串类型</li><li>.long long类型</li><li>.text 代码段</li></ul><h3 id="3-3-2-数据类型"><a href="#3-3-2-数据类型" class="headerlink" title="3.3.2 数据类型"></a>3.3.2 数据类型</h3><p>hello.c中出现的数据类型有整数类型（int）、字符串、字符指针数组。</p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>hello.c中的整数类型有全局变量int sleepsecs，main的参数int argc，局部变量int i。<br>全局变量int sleepecs的定义如下，可以看到第六行为其分配大小4字节，第八行为其赋初值2。<br><img src="/images/2018-HIT-CSAPP-hello/t5.png" alt="pic5"><br>对sleepecs的调用采用了PC相对寻址：<br><img src="/images/2018-HIT-CSAPP-hello/t6.png" alt="pic6"><br>参数int argc，局部变量i出现在main的栈帧中，它们没有标识符，也不需要被声明，而是直接使用。<br><img src="/images/2018-HIT-CSAPP-hello/t7.png" alt="pic7"><br><img src="/images/2018-HIT-CSAPP-hello/t8.png" alt="pic8"></p><h4 id="字符串和字符指针数组"><a href="#字符串和字符指针数组" class="headerlink" title="字符串和字符指针数组"></a>字符串和字符指针数组</h4><p>两个printf语句中的格式字符串出现在.rodata段。<br><img src="/images/2018-HIT-CSAPP-hello/t9.png" alt="pic9"><br>作为main参数的<code>char *argv[]</code>则出现在栈帧中。<br><img src="/images/2018-HIT-CSAPP-hello/t10.png" alt="pic10"></p><h3 id="3-3-3运算与操作"><a href="#3-3-3运算与操作" class="headerlink" title="3.3.3运算与操作"></a>3.3.3运算与操作</h3><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><p>源程序21行对i赋值为零的操作使用mov语句实现的。<br><img src="/images/2018-HIT-CSAPP-hello/t11.png" alt="pic11"></p><h4 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h4><p>hello.c中的两个比较操作被解析为cmpl操作。<br><strong>argc!=3</strong><br><img src="/images/2018-HIT-CSAPP-hello/t12.png" alt="pic12"><br><strong>i&lt;10</strong><br><img src="/images/2018-HIT-CSAPP-hello/t13.png" alt="pic13"></p><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>for循环中的i++采用addl来实现。<br><img src="/images/2018-HIT-CSAPP-hello/t14.png" alt="pic14"></p><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><p>argv[1]：首先从-32(%rbp)读取argv地址存入rax，接下来rax增加8个字节，此时rax中存放的是&amp;(argv[1])，读取此地址指向的argv[1]放入rax，最后存入rsi。<br><img src="/images/2018-HIT-CSAPP-hello/t15.png" alt="pic15"><br>argv[2]：首先从-32(%rbp)读取argv地址存入rax，接下来rax增加16个字节，此时rax中存放的是&amp;(argv[2])，读取此地址指向的argv[2]放入rdx。<br><img src="/images/2018-HIT-CSAPP-hello/t16.png" alt="pic16"></p><h3 id="3-3-4控制转移"><a href="#3-3-4控制转移" class="headerlink" title="3.3.4控制转移"></a>3.3.4控制转移</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p><strong>if(argc!=3) {}</strong><br>比较argc与3的大小，然后通过条件跳转je，实现若argc==3，则跳过if语句的代码块。<br><img src="/images/2018-HIT-CSAPP-hello/t17.png" alt="pic17"><br><img src="/images/2018-HIT-CSAPP-hello/t18.png" alt="pic18"></p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>.L2初始化<br><img src="/images/2018-HIT-CSAPP-hello/t19.png" alt="pic19"><br>.L3判断循环条件</p><p><img src="/images/2018-HIT-CSAPP-hello/t20.png" alt="pic20"><br>.L4循环块（51行为迭代i）<br><img src="/images/2018-HIT-CSAPP-hello/t21.png" alt="pic21"><br>首先给i赋值为0，然后跳转到.L3以比较i是否小于等于9，如果小于等于9，则跳转到循环块.L4，否则继续执行循环外的语句getchar。而循环块执行到末尾会继续执行循环判断条件.L3，重复以上步骤直至循环结束。</p><h3 id="3-3-5-函数调用"><a href="#3-3-5-函数调用" class="headerlink" title="3.3.5 函数调用"></a>3.3.5 函数调用</h3><p>对printf的调用，参数被存放在寄存器传递。以printf(“Hello %s %s\n”,argv[1],argv[2]);为例，格式化字符串被存放在edi传递，argv[1]被放在rsi，argv[2]被放在rdx。使用call来调用printf，而printf的返回值则会被存入eax返回。<br><img src="/images/2018-HIT-CSAPP-hello/t22.png" alt="pic22"><br>对exit函数的调用，参数被存放在edi传递，然后使用call调用exit。<br><img src="/images/2018-HIT-CSAPP-hello/t23.png" alt="pic23"><br>对sleep的调用，参数被存放在edi传递，然后使用call调用sleep。<br><img src="/images/2018-HIT-CSAPP-hello/t24.png" alt="pic24"><br>对getchar的调用直接使用了call。<br>main函数的返回值放在eax传递。<br><img src="/images/2018-HIT-CSAPP-hello/t25.png" alt="pic25"></p><h2 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h2><p>本章主要阐述了汇编操作是怎样处理源程序中的数据、各种操作、控制转移、函数调用的。<br>编译器将C语言代码转换成汇编代码，并最终转换生成机器码。这个转换过程中需要对原始代码中的数据和操作进行映射得到相应汇编代码下的解决方案，而由于全局变量引用等因素的影响，这个过程不是简单的一一映射关系。</p><h1 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h1><h2 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h2><p>汇编器（as）将hello.s翻译成机器指令，把这些指令打包成可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。</p><h2 id="4-2-在Ubuntu下汇编的命令"><a href="#4-2-在Ubuntu下汇编的命令" class="headerlink" title="4.2 在Ubuntu下汇编的命令"></a>4.2 在Ubuntu下汇编的命令</h2><p><strong>汇编命令as hello.s -o hello.o</strong></p><p><img src="/images/2018-HIT-CSAPP-hello/t26.png" alt="pic26"></p><h2 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h2><p>分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>ELF头</td><td>描述了生成该文件的系统的大小和字节顺序以及帮助链接器语法分析和解释目标文件的信息</td></tr><tr><td>.text</td><td>已编译的程序的机器代码</td></tr><tr><td>.rodata</td><td>只读数据</td></tr><tr><td>.data</td><td>已初始化的全局和静态C变量</td></tr><tr><td>.bss</td><td>未初始化的全局和静态C变量</td></tr><tr><td>.symtab</td><td>一个符号表，存放在程序中定义和引用的函数和全局变量的信息</td></tr><tr><td>.rel.text</td><td>.text节的重定位记录表</td></tr><tr><td>.rel.data</td><td>被模块引用或定义的所有全局变量的重定位信息</td></tr><tr><td>.debug</td><td>一个调试符号表</td></tr><tr><td>.line</td><td>原始C源程序的行号和.text节中机器指令之间的映射</td></tr><tr><td>.strtab</td><td>一个字符串表</td></tr><tr><td>节头部表</td><td>每个节的偏移量大小</td></tr></tbody></table><p>ELF头（ELF header）以一个16字节的序列开始，这个序列描述了生成该文件的系统的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表（section header table）的文件偏移，以及节头部表中条目的大小和数量。<br><img src="/images/2018-HIT-CSAPP-hello/t27.png" alt="pic27"><br>不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。<br><img src="/images/2018-HIT-CSAPP-hello/t28.png" alt="pic28"><br>.rela.text 一个.text节中位置的列表，当链接器把这个目标文件和其它文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。<br>如下图中有八个重定位记录。重定位记录的结构如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> offset;    <span class="comment">/* Offset of the reference to relocate */</span> </span><br><span class="line"><span class="keyword">int</span> symbol:<span class="number">24</span>, <span class="comment">/* Symbol of the reference should point to */</span></span><br><span class="line">type:<span class="number">8</span>;       <span class="comment">/* Relocation type */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure></p><p>以下图对sleepsecs的重定位记录为例。它的offset为0x5c，即需要修改的位置是.text段偏移量0x5c处；sybol为0x9，对应.symtab中第9号索引（sleepsecs）；type是0x2，即类型为重定位PC相对引用。<br><img src="/images/2018-HIT-CSAPP-hello/t29.png" alt="pic29"><br><img src="/images/2018-HIT-CSAPP-hello/t30.png" alt="pic30"><br>.symtab 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。</p><h2 id="4-4-Hello-o的结果解析"><a href="#4-4-Hello-o的结果解析" class="headerlink" title="4.4 Hello.o的结果解析"></a>4.4 Hello.o的结果解析</h2><p><img src="/images/2018-HIT-CSAPP-hello/t31.png" alt="pic31"><br>hello.o的反汇编与hello.s的差别总体不大，主要体现在以下几方面：</p><ol><li>全局变量引用 hello.o反汇编采用的是offset(%rip)的形式，而hello.s采用的是symbol(%rip)的形式。</li><li>函数调用 hello.o反汇编采用的是call offset的形式，而hello.s采用call symbol的形式。</li><li>分支转移 hello.o反汇编采用的是jmp offset的形式，而hello.s采用jmp Label的形式。</li><li>栈帧大小不同。<br>机器指令由指令指示符、（寄存器指示符）、（常数字）组成。</li></ol><p>机器语言与汇编语言大致具有一一对应的关系。但有些特殊情况，比如：</p><ol><li>转移控制 汇编语言中的jmp指令有直接跳转（在hello.o的反汇编中这个地址为绝对地址）和间接跳转，而转换成机器码后跳转指令会有几种不同的编码，最常用的是PC相对的，还有给出绝对地址的。而汇编器和链接器会选择适当的跳转目的编码。</li><li>一条指令可能有多个汇编码中的别名，例如jle和jg。</li><li>函数调用，在hello.o的反汇编文件中，call的地址是下一条指令的地址，而对应机器码中的操作码为0。这是因为hello.c中调用的函数都是共享库中的函数，在链接后才能确定函数的最终地址。因而在hello.o中只是将call的地址置为下一条指令的地址，而机器码的操作数则为目标位置（这里为下一条指令）相对于下一条指令的偏移，即0。</li></ol><h2 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h2><p>本章阐述了hello从hello.s到hello.o的汇编过程。分析了hello.o的ELF格式，并通过查看比较反汇编代码和汇编代码分析了汇编语言与机器码的关系。<br>汇编过程将汇编语言转换为机器码，生成可重定位目标文件，这个文件根据ELF格式对机器码进行打包，并为接下来的链接过程做好了准备。</p><h1 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h1><h2 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h2><p>链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可以被加载（复制）到内存执行。链接可以执行于编译时，也可以执行于加载时，甚至执行于运行时。<br>链接器使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的其中一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其它文件。</p><h2 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h2><p><code>ld -dynamic-linker /lib64/ld-linux-x86-64.so.2  /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o hello.o -lc /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o /usr/lib/x86_64-linux-gnu/crtn.o -z relro -o hello.out</code><br><img src="/images/2018-HIT-CSAPP-hello/t32.png" alt="pic32"></p><h2 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h2><p>Linux的ELF文件格式如下：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>ELF头</td><td>描述文件的总体格式，包括程序的入口点</td></tr><tr><td>段头部表</td><td>将连续的文件映射到运行时内存段</td></tr><tr><td>.init</td><td>定义了一个小函数<code>_init</code></td></tr><tr><td>.text</td><td>已编译的程序的机器代码</td></tr><tr><td>.rodata</td><td>只读数据</td></tr><tr><td>.data</td><td>已初始化的全局和静态C变量</td></tr><tr><td>.bss</td><td>未初始化的全局和静态C变量</td></tr><tr><td>.symtab</td><td>一个符号表，存放在程序中定义和引用的函数和全局变量的信息</td></tr><tr><td>.debug</td><td>一个调试符号表</td></tr><tr><td>.line</td><td>原始C源程序的行号和.text节中机器指令之间的映射</td></tr><tr><td>.strtab</td><td>一个字符串表</td></tr><tr><td>节头部表</td><td>每个节的偏移量大小</td></tr></tbody></table><h4 id="hello的ELF头"><a href="#hello的ELF头" class="headerlink" title="hello的ELF头"></a>hello的ELF头</h4><p><img src="/images/2018-HIT-CSAPP-hello/t33.png" alt="pic33"><br>节头部表 节头部表对hello中所有的节进行了声明，其中Size是每个节的大小，Offset是每个节在程序中的偏移量，Address是程序被载入后各段的虚拟地址。<br><img src="/images/2018-HIT-CSAPP-hello/t34.png" alt="pic34"></p><h4 id="段头部表"><a href="#段头部表" class="headerlink" title="段头部表"></a>段头部表</h4><p><img src="/images/2018-HIT-CSAPP-hello/t35.png" alt="pic35"></p><h2 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h2><p><strong>.plt 位于代码段的plt表</strong><br><img src="/images/2018-HIT-CSAPP-hello/t36.png" alt="pic36"><br><strong>.text 代码段 如图为hello!_start函数</strong><br><img src="/images/2018-HIT-CSAPP-hello/t37.png" alt="pic37"><br><strong>.rodata 只读数据段</strong><br><img src="/images/2018-HIT-CSAPP-hello/t38.png" alt="pic38"><br><strong>.data 数据段</strong><br><img src="/images/2018-HIT-CSAPP-hello/t39.png" alt="pic39"><br><strong>.bss 位初始化和被初始化为零的数据段</strong><br><img src="/images/2018-HIT-CSAPP-hello/t40.png" alt="pic40"><br><strong>.got 初始化前的got表</strong><br><img src="/images/2018-HIT-CSAPP-hello/t41.png" alt="pic41"></p><h2 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h2><p>hello相比hello多了许多节，如:</p><table><thead><tr><th>节</th><th>作用</th></tr></thead><tbody><tr><td>.interp</td><td>保存ld.so的路径</td></tr><tr><td>.rela.plt</td><td>.plt的重定位项目</td></tr><tr><td>.init</td><td>初始化代码</td></tr><tr><td>.plt</td><td>动态链接过程链接表</td></tr><tr><td>.got</td><td>动态链接全局偏移量表，用于存放变量</td></tr><tr><td>.got.plt</td><td>动态链接全局偏移量表，用于存放函数</td></tr></tbody></table><p>hello.o的objdump与hello的objdump主要有以下几点不同：</p><ol><li>hello.o的objdump没有<code>_init</code>函数、<code>_start</code>函数、plt表等。</li><li>hello.o的objdump中对全局变量的引用地址均为0，函数调用的地址也只是当前指令的下一条指令的地址。</li></ol><p>hello的重定位记录有两种，分别是PC相对地址的引用和绝对地址的引用。<br>进行重定位时，hello根据.rela.text和.rela.data中的重定位记录，在.symtab中查找需要修改的记录的符号，并结合符号与重定位记录中的位置信息对目标位置进行 修改。如果需要修改的符号是本地符号，则计算偏移量并修改目标位置；如果是共享库中的符号，则创建.got表项（如果是函数还需创建.plt项），并创建新的重定位记录指向.got表项。</p><h2 id="5-6-hello的执行流程"><a href="#5-6-hello的执行流程" class="headerlink" title="5.6 hello的执行流程"></a>5.6 hello的执行流程</h2><table><thead><tr><th>hello执行过程中调用的函数</th><th>函数的地址</th></tr></thead><tbody><tr><td><code>_dl_start</code></td><td>0x7fb78d93ac38</td></tr><tr><td><code>_dl_init</code></td><td>0x7fb78d9424e0</td></tr><tr><td><code>_start</code></td><td>0x400550</td></tr><tr><td><code>__libc_start_main@plt</code></td><td>0x7fb78d590740</td></tr><tr><td><code>__libc_csu_init</code></td><td>0x4006d0</td></tr><tr><td><code>init</code></td><td>0x4004a8</td></tr><tr><td><code>main</code></td><td>0x400646</td></tr><tr><td><code>__GI_exit</code></td><td>0x7fb78d5aa030</td></tr><tr><td><code>__run_exit_handlers</code></td><td>0x7fb78d5a9f10</td></tr><tr><td><code>_dl_fini</code></td><td>0x7fb78d94aab0</td></tr><tr><td><code>_IO_cleanup</code></td><td>0x7fb78d5ec310</td></tr><tr><td><code>_IO_flush_all_lockp</code></td><td>0x7fb785ec020</td></tr></tbody></table><h2 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h2><p>无论在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。<br>而要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表（GOT）。在GOT中，每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个8字节条目。编译器还为GOT中每个条目生成 一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。<br>hello中对.got的初始化是由_dl_start函数执行的。下面的四张图片反应了这一过程：</p><p><img src="/images/2018-HIT-CSAPP-hello/t42.png" alt="pic42"><br>.got <code>_dl_start</code>执行前<br><img src="/images/2018-HIT-CSAPP-hello/t43.png" alt="pic43"><br>.got.plt <code>_dl_start</code>执行前<br><img src="/images/2018-HIT-CSAPP-hello/t44.png" alt="pic44"><br>.got <code>_dl_start</code>执行后<br><img src="/images/2018-HIT-CSAPP-hello/t45.png" alt="pic45"><br>.got.plt <code>_dl_start</code>执行后</p><p>hello要调取由共享库定义的函数puts，printf，而程序调用一个由共享库定义的函数，编译器没有办法预测这个函数的运行地址，因为定义它的共享模块在运行时可以加载到任何位置。为了解决这个问题，GNU编译系统使用了延迟绑定技术：<br>当hello尝试调用puts时，不直接调用puts，而是调用进入puts对应的PLT条目。这个条目会尝试利用GOT项进行间接跳转。<br><img src="/images/2018-HIT-CSAPP-hello/t46.png" alt="pic46"><br>第一次被调用时，GOT项的值为PLT条目中的下一条指令地址，因而接下来会跳回PLT条目，在把puts的ID 0压入栈后，会转到PLT[0]的位置，PLT[0]通过GOT[1]间接地把动态链接器的一个参数压入栈中，然后通过GOT[2]跳转进动态链接器中。动态链接器使用两个栈条目来确定puts的运行时位置，用这个地址重写puts的GOT项，再把控制传递给puts。<br><img src="/images/2018-HIT-CSAPP-hello/t47.png" alt="pic47"><br>在下一次执行到puts对应的PLT条目时，GOT项已经被修改，因此利用GOT项进行的间接跳转会直接跳转到puts函数。<br><img src="/images/2018-HIT-CSAPP-hello/t48.png" alt="pic48"></p><h2 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h2><p>本章讨论了hello的链接过程。链接过程可以发生在编译时，也可以发生在加载时，甚至可以发生在程序执行时。静态链接直接将目标文件和库文件打包至一个可执行文件中，而动态链接则只在可执行目标文件中添加相应重定向记录，并通过GOT表项和延迟绑定的方法实现对目标模块中符号的引用。</p><h1 id="第6章-hello进程管理"><a href="#第6章-hello进程管理" class="headerlink" title="第6章 hello进程管理"></a>第6章 hello进程管理</h1><h2 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h2><p><strong>概念</strong>：进程是一个执行中的程序的实例，系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p><strong>作用</strong>：进程提供给应用程序两个关键抽象：</p><ol><li>逻辑控制流<br>a)    每个程序似乎独占地使用CPU<br>b)    通过OS内核的上下文切换机制提供</li><li>私有地址空间<br>a)    每个程序似乎独占地使用内存系统<br>b)    OS内核的虚拟内存机制提供</li></ol><h2 id="6-2-简述壳Shell-bash的作用与处理流程"><a href="#6-2-简述壳Shell-bash的作用与处理流程" class="headerlink" title="6.2 简述壳Shell-bash的作用与处理流程"></a>6.2 简述壳Shell-bash的作用与处理流程</h2><p><strong>概念</strong>：shell是一个交互型的应用级程序，它代表用户运行其它程序。它执行一系列的读/求值步骤，然后终止。其中读步骤读取来自用户的一个命令行，求值步骤解析命令行，并代表用户运行程序。</p><p><strong>处理流程</strong>：读取来自用户的命令行并解析，如果是内部命令则直接执行内部命令，否则fork一个shell进程，并在这个进程中用execve加载目标程序，按照命令中的参数决定在前台或者后台运行目标程序，当前台程序结束时用waitpid回收进程。</p><h2 id="6-3-Hello的fork进程创建过程"><a href="#6-3-Hello的fork进程创建过程" class="headerlink" title="6.3 Hello的fork进程创建过程"></a>6.3 Hello的fork进程创建过程</h2><p>在bash中输入 <code>./hello 1******* ***</code> 并敲击回车后，bash解析此条命令，发现./hello不是bash内置命令，于是在当前目录尝试寻找并执行hello文件。此时bash使用fork函数创建一个子进程（这个子进程得到与父进程用户级虚拟地址空间相同但是独立的一份副本），并更改这个子进程的进程组编号。并准备在这个子进程执行execve。</p><h2 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h2><p>在新创建的子进程中，execve函数加载并运行hello，且带参数列表argv和环境变量envp。在execve加载了hello之后，它调用<code>_start</code>，<code>_start</code>设置栈，并将控制传递给新程序的主函数。</p><h2 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h2><p>在输入合适参数执行hello程序之后，hello进程一开始运行在用户模式。内核为hello维持一个上下文，它由一系列的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构（比如页表、进程表、文件表）。</p><p>在hello运行时，也有一些其它进程在并行地运行，这些进程的逻辑流的执行时间与hello的逻辑流重叠，称为并发流。而一个进程和其它进程轮流运行的概念叫作多任务，一个进程执行它的控制流的一部分的每一时间段叫做时间片。因此，多任务也叫做时间分片。<br><img src="/images/2018-HIT-CSAPP-hello/t49.png" alt="pic49"><br>不久hello调用printf与sleep，这两个函数引发系统调用，系统调用使得进程从用户模式变为内核模式，处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式，而执行sleep系统调用时，内核可能会执行上下文切换而非将控制返回给hello进程。在切换的第一部分中，内核代表hello在内核模式下执行指令，然后在某一时刻，它开始代表另一个进程在内核模式下执行指令，在切换之后，内核代表那个进程在用户模式下执行指令。<br>而这个切换过程可以分为三个步骤<br>1) 保存当前进程的上下文<br>2) 恢复某个先前被抢占的进程被保存的上下文<br>3) 将控制传递给这个新恢复的进程。</p><p><img src="/images/2018-HIT-CSAPP-hello/t50.png" alt="pic50"><br>这时我们说内核调度了一个新的进程，在内核调度了一个新的进程后，它就抢占了当前进程。<br>不仅仅是系统调用会导致上下文切换，中断也会。当hello执行了一段时间（通常是1-10ms）后，定时器引发的中断也会导致内核执行上下文切换并调度一个新的进程。<br>接下来的十秒中，内核继续执行上下文切换，轮流运行hello与其它进程，十次循环结束后，hello返回，程序终止。</p><h2 id="6-6-hello的异常与信号处理"><a href="#6-6-hello的异常与信号处理" class="headerlink" title="6.6 hello的异常与信号处理"></a>6.6 hello的异常与信号处理</h2><h3 id="6-6-1-hello在运行时可能会出现的异常"><a href="#6-6-1-hello在运行时可能会出现的异常" class="headerlink" title="6.6.1 hello在运行时可能会出现的异常"></a>6.6.1 hello在运行时可能会出现的异常</h3><p><strong>故障</strong>：缺页异常 加载完成后hello进程的页表被映射到hello文件，但还未将实际代码拷贝至内存，在执行到相应地址的代码时会引发缺页异常，拷贝相关代码。<br><strong>中断</strong>：如来自键盘的信号（见下文） 定时器中断<br><strong>陷阱</strong>：系统调用造成，如sleep函数<br><strong>终止</strong>：不可恢复的错误，如hello执行时硬件被物理伤害造成奇偶校验错误。</p><h3 id="6-6-2-hello在运行时可能会接受到的信号"><a href="#6-6-2-hello在运行时可能会接受到的信号" class="headerlink" title="6.6.2 hello在运行时可能会接受到的信号"></a>6.6.2 hello在运行时可能会接受到的信号</h3><p><strong>SIGINT 中断信号</strong> 当用户键入ctrl+c时会产生这个信号，接受这个信号，程序默认终止，如果有已经定义的handler，则会执行handler。<br><img src="/images/2018-HIT-CSAPP-hello/t51.png" alt="pic51"><br><strong>SIGTSTP 停止信号</strong> 当用户键入ctrl+z时会产生这个信号，接受这个信号的默认行为是中止程序，这个默认行为不可更改。<br><img src="/images/2018-HIT-CSAPP-hello/t52.png" alt="pic52"><br><strong>SIGKILL 终止信号</strong> 使用kill -9向hello发出这个信号，接受这个信号的默认行为是终止程序，这个默认行为不可更改。<br><img src="/images/2018-HIT-CSAPP-hello/t53.png" alt="pic53"><br><strong>SIGCHLD 子进程信号</strong> hello终止或中止时会向父进程（bash）发出这个信号。如果hello中止；则bash会将其标记为中止状态，如果hello已经终止，则bash会回收hello进程。</p><h2 id="6-7本章小结"><a href="#6-7本章小结" class="headerlink" title="6.7本章小结"></a>6.7本章小结</h2><p>本章介绍了进程的概念与作用，并通过hello程序演示了进程的执行过程。<br>简要介绍了shell的工作流程，并分析了linux下的异常处理机制，介绍了应用程序的信号处理。</p><p>shell执行程序是通过fork函数以及execve创建新的进程并执行程序的。<br>程序运行中可能会遇到异常，异常分为中断、陷阱、故障、终止四类，由异常处理子程序来处理，信号作为一种特殊的异常，实现了对程序运行终止等操作的控制。</p><h1 id="第7章-hello的存储管理"><a href="#第7章-hello的存储管理" class="headerlink" title="第7章 hello的存储管理"></a>第7章 hello的存储管理</h1><h2 id="7-1-hello的存储器地址空间"><a href="#7-1-hello的存储器地址空间" class="headerlink" title="7.1 hello的存储器地址空间"></a>7.1 hello的存储器地址空间</h2><p><strong>逻辑地址空间</strong>：段地址：偏移地址<br>23：8048000 段寄存器（CS等16位）：偏移地址（16/32/64）</p><ul><li>实模式下：逻辑地址CS：EA=物理地址CS * 16 + EA</li><li>保护模式下：以段描述符作为下标，到GDT/LDT表查表获得段地址，<br>段地址+偏移地址=线性地址。</li></ul><p><strong>线性地址空间</strong>: 非负整数地址的有序集合:：{0, 1, 2, 3 … }<br><strong>虚拟地址空间</strong>: N = 2n 个虚拟地址的集合=线性地址空间<br>{0, 1, 2, 3, …, N-1}<br><strong>物理地址空间</strong>: M = 2m 个物理地址的集合<br>    {0, 1, 2, 3, …, M-1}<br>Intel采用段页式存储管理（MMU实现）<br><strong>段式管理</strong>：  逻辑地址-&gt;线性地址==虚拟地址<br><strong>页式管理</strong>：  虚拟地址-&gt;物理地址</p><h2 id="7-2-Intel逻辑地址到线性地址的变换-段式管理"><a href="#7-2-Intel逻辑地址到线性地址的变换-段式管理" class="headerlink" title="7.2 Intel逻辑地址到线性地址的变换-段式管理"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h2><p>实模式下：逻辑地址CS：EA=物理地址CS * 16 + EA<br>保护模式下：以段描述符作为下标，到GDT/LDT表查表获得段地址，<br>段地址+偏移地址=线性地址。<br><img src="/images/2018-HIT-CSAPP-hello/t54.png" alt="pic54"></p><h2 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h2><p>hello的线性地址到物理地址的变换需要查询页表得出，hello的线性地址被分成两个部分，第一部分虚拟页号VPN用于在页表查询物理页号PPN，而第二部分虚拟页偏移量VPO则与查询到的物理页号PPN一起组成物理地址。<br><img src="/images/2018-HIT-CSAPP-hello/t55.png" alt="pic55"></p><h2 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h2><p><img src="/images/2018-HIT-CSAPP-hello/t56.png" alt="pic56"><br>虚拟地址VA被分成VPN和VPO两部分，VPN被分为TLBT和TLBI用于在TLB中查询。根据TLBI确定TLB中的组索引，并根据TLBT判断PPN是否已被缓存到TLB中，如果TLB命中，则直接返回PPN，否则会到页表中查询PPN。在页表中查询PPN时，VPN会被分为四个部分，分别用作一二三四级页表的索引，而前三级页表的查询结果为下一级页表的基地址，第四级页表的查询结果为PPN。将查询到的PPN与VPO组合，得到物理地址PA。</p><h2 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h2><p>MMU发送物理地址PA给L1缓存，L1缓存从物理地址中抽取出缓存偏移CO、缓存组索引CI以及缓存标记CT。高速缓存根据CI找到缓存中的一组，并通过CT判断是否已经缓存地址对应的数据，若缓存命中，则根据偏移量直接从缓存中读取数据并返回；若缓存不命中，则继续从L2、L3缓存中查询，若仍未命中，则从主存中读取数据。</p><h2 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h2><p>当fork函数被新进程调用时，内核为新进程创建各种数据结构，并分配给它唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</p><p>当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p><h2 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h2><p>execve函数在当前进程中加载并运行包含在可执行文件hello中的程序，加载并运行hello时出现的内存映射有：</p><ol><li>映射私有区域 为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。Bss区域时请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。 </li><li>映射共享区域 如果hello程序与共享对象（或目标链接），比如C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。<br><img src="/images/2018-HIT-CSAPP-hello/t57.png" alt="pic57"></li></ol><h2 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h2><p><strong>缺页故障</strong>：虚拟内存中的字不在物理内存中（DRAM缓存不命中）<br>如下图，VP3已经被映射到页表中，但却没有被缓存到物理内存中，此时堆VP3的引用会引发缺页故障。<br><img src="/images/2018-HIT-CSAPP-hello/t58.png" alt="pic58"><br>缺页会导致页面出错引发一个缺页中断，而缺页异常处理程序会选择一个牺牲页（如下图选择了VP4，将VP4从内存交换到磁盘，并从磁盘读取VP3交换到物理内存）。<br><img src="/images/2018-HIT-CSAPP-hello/t59.png" alt="pic59"><br>此时令导致缺页的指令重新启动，就可以使得页面命中了。</p><h2 id="7-9动态存储分配管理"><a href="#7-9动态存储分配管理" class="headerlink" title="7.9动态存储分配管理"></a>7.9动态存储分配管理</h2><p>printf会调用malloc，接下来提一下动态内存分配的基本原理。</p><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的需内存片，要么是已分配的，要么是空闲的。已分配的块显示地保留为供应用程序使用。空闲块可以用来分配。空闲块保持空闲，直到它显示地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显示执行的，要么是内存分配器自身隐式执行的。</p><p>两种堆的数据结构组织形式：</p><h4 id="带标签的隐式空闲链表"><a href="#带标签的隐式空闲链表" class="headerlink" title="带标签的隐式空闲链表"></a>带标签的隐式空闲链表</h4><p>带标签的隐式空闲链表的数据组织方式如下图：<br><img src="/images/2018-HIT-CSAPP-hello/t60.png" alt="pic60"><br>空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。</p><h4 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h4><p>显式空闲链表将链表的指针存放在空闲块的主体里面。堆被组织成一个双向空闲链表，在每个空闲块中，都包含一个pred和succ指针，如下图所示：<br><img src="/images/2018-HIT-CSAPP-hello/t61.png" alt="pic61"></p><h2 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h2><p>现代操作系统多采用虚拟内存系统，访存时地址需要从逻辑地址翻译到虚拟地址并进一步翻译成物理地址。<br>操作系统通过地址的页式管理来实现对磁盘的缓存、内存管理、内存保护等功能。<br>虚拟内存为便捷的加载、进程管理提供了可能。<br>程序运行过程中往往涉及动态内存分配，动态内存分配通过动态内存分配器完成。</p><h1 id="第8章-hello的IO管理"><a href="#第8章-hello的IO管理" class="headerlink" title="第8章 hello的IO管理"></a>第8章 hello的IO管理</h1><h2 id="8-1-Linux的IO设备管理方法"><a href="#8-1-Linux的IO设备管理方法" class="headerlink" title="8.1 Linux的IO设备管理方法"></a>8.1 Linux的IO设备管理方法</h2><p>一个linux文件就是一个m个字节的序列：<br>    <strong>B0, B1, … Bk, …, Bm-1</strong></p><p>所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：UNIX I/O。</p><h2 id="8-2-简述Unix-IO接口及其函数"><a href="#8-2-简述Unix-IO接口及其函数" class="headerlink" title="8.2 简述Unix IO接口及其函数"></a>8.2 简述Unix IO接口及其函数</h2><h4 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h4><p><code>int open(char *filename, int flags, mode_t mode);</code><br>open函数将filename转换为一个文件描述符，并返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。<br><code>int close(int fd);</code><br>进程通过调用close关闭一个打开的文件。</p><h4 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h4><p><code>ssize_t read(int fd, void *buf, size_t n);</code><br>read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。<br><code>ssize_t write(int fd, const void *buf, size_t n);</code><br>write函数从内存位置buf复制之多n个字节到描述符fd的当前文件位置。<br><code>DIO *opendir(const char *name);</code><br>函数opendir以路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。<br><code>struct dirent *readdir(DIR *dirp);</code><br>每次对readdir的调用返回的都是指向流dirp中下一个目录项的指针，或者，如果没有更过目录项则返回NULL。<br><code>int closedir(DIR *dirp);</code><br>函数closedir关闭流并释放其所有的资源。</p><h4 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h4><p><code>int dup2(int oldfd, int newfd);</code><br>dup2函数复制描述符表表项oldfd到描述符表项newfd，覆盖描述符表表项newfd以前的内容。如果newfd已经打开了，dup2会在复制oldfd之前关闭newfd。</p><h2 id="8-3-printf的实现分析"><a href="#8-3-printf的实现分析" class="headerlink" title="8.3 printf的实现分析"></a>8.3 printf的实现分析</h2><p>printf函数的实现大致与下面代码一致：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    va_list arg = (va_list)((<span class="keyword">char</span> *)(&amp;fmt) + <span class="number">4</span>);</span><br><span class="line">    i = <span class="built_in">vsprintf</span>(buf, fmt, arg);</span><br><span class="line">    write(buf, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中va_list_arg是边长参数列表中的第一个参数的地址，vsprintf的作用是以fmt作为格式字符串，根据arg中的参数，向buf中输出格式化后的字符串。write则是Unix I/O接口，它将栈中参数存入寄存器，并由它来进行系统调用。write的实现大致如下，其中ecx是字符个数，ebx存放第一个字符地址：<br>write:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   mov eax, _NR_write</span><br><span class="line">   mov ebx, [esp + 4]</span><br><span class="line">   mov ecx, [esp + 8]</span><br><span class="line">int INT_VECTOR_SYS_CALL</span><br></pre></td></tr></table></figure></p><p>接下来syscall将字符串从寄存器中通过总线复制到显卡显存中。字符显示驱动子程序通过ASCII码在字模库中找到点阵信息并将其存储到vram中。接下来显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。此时字符串就被打印到了屏幕上。</p><h2 id="8-4-getchar的实现分析"><a href="#8-4-getchar的实现分析" class="headerlink" title="8.4 getchar的实现分析"></a>8.4 getchar的实现分析</h2><p>getchar函数的大致实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">return</span> (read(<span class="number">0</span>,&amp;c,<span class="number">1</span>)==<span class="number">1</span>)?(<span class="keyword">unsigned</span> <span class="keyword">char</span>)c:EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getchar函数通过调用read函数来读取字符。read函数由三个参数，第一个参数为文件描述符fd，fd为0表示标准输入；第二个参数为输入内容的指针；第三个参数为读入字符的个数。read函数的返回值是读入字符的个数，若出错则返回-1。</p><p>当用户按键时，键盘接口会产生一个键盘扫描码和一个中断请求，中断处理程序会从键盘接口取得按键扫描码并把它转换成ASCII码，保存到系统的键盘缓冲区。</p><p>read执行一个系统调用，按照系统调用从键盘缓冲区读取按键ASCII码，直到接受到回车键才返回。</p><h2 id="8-5本章小结"><a href="#8-5本章小结" class="headerlink" title="8.5本章小结"></a>8.5本章小结</h2><p>I/O时在主存和外部设备之间复制数据的过程。在Linux中，I/O的实现是通过Unix I/O函数来执行的。Linux把所有的I/O设备模型化为文件，并提供统一的Unix I/O接口，这使得所有的输入输出都能以一种统一且一致的方式来执行。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><h1 id="hello的一生"><a href="#hello的一生" class="headerlink" title="hello的一生"></a>hello的一生</h1><ol><li>用户从键盘输入，得到hello.c源文件。</li><li>编译器和汇编器对hello.c进行预处理，然后对其进行编译和汇编，得到可重定位目标文件hello.o。</li><li>链接器对hello.o进行链接，并得到可执行目标文件hello，此时hello已经可以被操作系统加载和执行。</li><li>bash执行hello，首先bash会fork一个进程，然后在这个新的进程中execve hello，execve会清空当前进程的数据并加载hello，然后把rip指向hello的程序入口，把控制权交给hello。</li><li>hello与许多进程并行执行，执行过程中由于系统调用或者计时器中断，会导致上下文切换，内核会选择另一个进程进行调度，并抢占当前的hello进程。</li><li>hello执行的过程中可能收到来自键盘或者其它进程的信号，当收到信号时hello会调用信号处理程序来进行处理，可能出现的行为有停止终止忽略等。</li><li>hello输出信息时需要调用printf和getchar，而printf和getchar的实现需要调用Unix I/O中的write和read函数，而它们的实现需要借助系统调用。</li><li>hello中的访存操作，需要经历逻辑地址到线性地址最后到物理地址的变换，而访问物理地址的数据可能已被缓存至高速缓冲区，也可能位于主存中，也可能位于磁盘中等待被交换到主存。</li><li>hello结束进程后，bash作为hello的父进程会回收hello进程。</li></ol><p>在Kernighan和Ritchie的关于C编程语言的经典教材中，他们通过一个简单的hello程序来向读者介绍C。尽管hello非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，计算机系统课程的学习，就是让我们了解当在系统上执行hello程序时，系统发生了什么以及为什么会这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘-要&quot;&gt;&lt;a href=&quot;#摘-要&quot; class=&quot;headerlink&quot; title=&quot;摘  要&quot;&gt;&lt;/a&gt;摘  要&lt;/h1&gt;&lt;p&gt;计算机系统是由硬件和软件组成的，它们共同工作来运行应用程序。即使是最简单的一个应用程序，也需要计算机系统中的每个主要组成部分协调工作。本文以hello程序的运行为切入点，解释了当在系统上运行hello程序时，系统发生的编译、链接、加载、进程管理、存储管理等过程，以及它们的运行机制。&lt;br&gt;&lt;strong&gt;关键词&lt;/strong&gt;：操作系统；计算机组成原理；汇编&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://www.mhlwsk.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="汇编" scheme="https://www.mhlwsk.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>计蒜客31445 (Made In Heaven)[A*，第K最短路]</title>
    <link href="https://www.mhlwsk.com/archives/20320.html"/>
    <id>https://www.mhlwsk.com/archives/20320.html</id>
    <published>2018-09-09T02:20:15.000Z</published>
    <updated>2020-07-30T13:07:23.802Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="https://nanti.jisuanke.com/t/31445" rel="external nofollow noopener noreferrer" target="_blank">https://nanti.jisuanke.com/t/31445</a></p><p>题目大意：给定一张图，问第K最短路的长度是否小于给定值T<br>求第K最短路，令$f=g+h$，$g$为当前已经走过的距离，$h$为当前点到终点的最短距离<br>从起点开始拓展，每次选择$f$最短的点进行拓展（入队），每次出队时检查是否走到终点并统计终点出队次数，当终点出队次数为$k$时当前点的$g$就是答案<br>可以这样考虑：每次严格按照估价函数进行拓展，则第一次走到终点的方案一定是最短路，第二次就是第2最短路，第k次就是第k最短路<br>这样先用spfa预处理出每个节点的$h$再用A*拓展即可</p><p>这题还有一个需要注意的地方：A*用的优先队列很有可能在使用完后没有被清空（因为函数可能提前退出了），此时如果直接用会MLE，而如果用一个一个pop的方式清空会直接TLE，所以比较好的解决方法是直接把优先队列写在函数体内部，这样就不用清空了</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">10009</span>;</span><br><span class="line"><span class="keyword">int</span> s,t,k,up,n,m;</span><br><span class="line"><span class="keyword">int</span> head[maxn],revhead[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,next;</span><br><span class="line"></span><br><span class="line">&#125;ed[maxm],reved[maxm];</span><br><span class="line"><span class="keyword">int</span> ne1=<span class="number">0</span>,ne2=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(revhead,<span class="number">-1</span>,<span class="keyword">sizeof</span>(revhead));</span><br><span class="line">    ne1=<span class="number">0</span>;</span><br><span class="line">    ne2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    ed[ne1].v=v;ed[ne1].w=w;ed[ne1].next=head[u];head[u]=ne1++;</span><br><span class="line">    reved[ne2].v=u;reved[ne2].w=w;reved[ne2].next=revhead[v];revhead[v]=ne2++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) h[i]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">    h[t]=<span class="number">0</span>;</span><br><span class="line">    vis[t]=<span class="literal">true</span>;</span><br><span class="line">    q.push(t);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now=q.top(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=revhead[now],v;~i;i=reved[i].next) &#123;</span><br><span class="line">            v=reved[i].v;</span><br><span class="line"><span class="keyword">if</span>(h[v]&gt;h[now]+reved[i].w) &#123;</span><br><span class="line">                h[v]=h[now]+reved[i].w;</span><br><span class="line"><span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">                    vis[v]=<span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">        vis[now]=<span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,g,v;</span><br><span class="line">    Node(<span class="keyword">int</span> _f,<span class="keyword">int</span> _g,<span class="keyword">int</span> _v):f(_f),g(_g),v(_v) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;y) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(f==y.f) <span class="keyword">return</span> g&gt;y.g;</span><br><span class="line">        <span class="keyword">return</span> f&gt;y.f;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">astar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(h[s]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//</span></span><br><span class="line">    pq.push(Node(<span class="number">0</span>+h[s],<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">if</span>(s==t) k++;</span><br><span class="line"><span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        Node now=pq.top(); pq.pop();</span><br><span class="line">        <span class="keyword">if</span>(now.v==t) ++cnt;</span><br><span class="line"><span class="keyword">if</span>(cnt==k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(now.g&lt;=up) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now.v],v;~i;i=ed[i].next) &#123;</span><br><span class="line">            <span class="comment">//if(i&amp;1) continue;</span></span><br><span class="line">            v=ed[i].v;</span><br><span class="line">            pq.push(Node(now.g+ed[i].w+h[v],now.g+ed[i].w,v));</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="comment">//printf("%d",0x3f3f3f3f);</span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;s,&amp;t,&amp;k,&amp;up);</span><br><span class="line">        init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">        spfa();</span><br><span class="line">        <span class="built_in">printf</span>(astar()?<span class="string">"yareyaredawa\n"</span>:<span class="string">"Whitesnake!\n"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;https://nanti.jisuanke.com/t/31445&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://nanti.jisuanke.com/t/31445&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意：给定一张图，问第K最短路的长度是否小于给定值T&lt;br&gt;求第K最短路，令$f=g+h$，$g$为当前已经走过的距离，$h$为当前点到终点的最短距离&lt;br&gt;从起点开始拓展，每次选择$f$最短的点进行拓展（入队），每次出队时检查是否走到终点并统计终点出队次数，当终点出队次数为$k$时当前点的$g$就是答案&lt;br&gt;可以这样考虑：每次严格按照估价函数进行拓展，则第一次走到终点的方案一定是最短路，第二次就是第2最短路，第k次就是第k最短路&lt;br&gt;这样先用spfa预处理出每个节点的$h$再用A*拓展即可&lt;/p&gt;
&lt;p&gt;这题还有一个需要注意的地方：A*用的优先队列很有可能在使用完后没有被清空（因为函数可能提前退出了），此时如果直接用会MLE，而如果用一个一个pop的方式清空会直接TLE，所以比较好的解决方法是直接把优先队列写在函数体内部，这样就不用清空了&lt;/p&gt;
    
    </summary>
    
    
      <category term="A\*" scheme="https://www.mhlwsk.com/tags/A/"/>
    
      <category term="最短路" scheme="https://www.mhlwsk.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 100342 (Triatrip)[bitset]</title>
    <link href="https://www.mhlwsk.com/archives/55288.html"/>
    <id>https://www.mhlwsk.com/archives/55288.html</id>
    <published>2018-09-01T02:45:18.000Z</published>
    <updated>2020-07-30T13:07:23.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/gym/100342/attachments" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/gym/100342/attachments</a></p><p>题目大意：给定一张有向图，询问有多少个三元环。</p><blockquote><p>这道题数据范围只有1500,所以可以n^2，我们暴力枚举两个点，假设为A->B，然后我们预处理出有哪些点可以到A，B可以到哪些点，这样就可以得到俩集合，然后再交一下，再统计一下集合里面元素的个数就好了<br>引用自<a href="https://www.cnblogs.com/qscqesze/p/4708878.html" rel="external nofollow noopener noreferrer" target="_blank">qscqesze</a></p></blockquote><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1509</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; g[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"triatrip.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"triatrip.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;s[j]!=<span class="string">'\0'</span>;j++) </span><br><span class="line"><span class="keyword">if</span>(s[j]==<span class="string">'+'</span>) g[i].<span class="built_in">set</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;maxn&gt; <span class="title">tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">tmp.reset();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(g[j].test(i)) tmp.<span class="built_in">set</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(g[i].test(j)) ans+=(tmp&amp;g[j]).count();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans/<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://codeforces.com/gym/100342/attachments&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://codeforces.com/gym/100342/attachments&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意：给定一张有向图，询问有多少个三元环。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这道题数据范围只有1500,所以可以n^2，我们暴力枚举两个点，假设为A-&gt;B，然后我们预处理出有哪些点可以到A，B可以到哪些点，这样就可以得到俩集合，然后再交一下，再统计一下集合里面元素的个数就好了&lt;br&gt;引用自&lt;a href=&quot;https://www.cnblogs.com/qscqesze/p/4708878.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;qscqesze&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="STL" scheme="https://www.mhlwsk.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>hihoCoder1513 (小Hi的烦恼)[bitset]</title>
    <link href="https://www.mhlwsk.com/archives/52638.html"/>
    <id>https://www.mhlwsk.com/archives/52638.html</id>
    <published>2018-09-01T02:36:17.000Z</published>
    <updated>2020-07-30T13:07:23.802Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="https://hihocoder.com/problemset/problem/1513" rel="external nofollow noopener noreferrer" target="_blank">https://hihocoder.com/problemset/problem/1513</a></p><p>题目大意：给定许多人的五门课排名，询问每个人有多少人所有课的排名都能碾压他。</p><blockquote><p>小Hi：今天我们来解决“五维数点”问题。<br>小Ho：什么是“五维数点”问题呢？<br>小Hi：抽象来说，我们现在有n个在五维空间中的点$(X_i,Y_i,Z_i,Q_i,W_i)$。现在对于每个点，我们需要知道所有坐标均比它小的点的数量。<br>小Ho：这个问题看起来似曾相似，如果是在二维空间中似乎是一个经典的运用线段树解决的题目。<br>小Hi：对。但是现在是在五维空间中，看起来难度大了很多。<br>小Ho：我想用集合的角度去考虑这个问题。对于每一维，比如说X维，我们能通过按X维的坐标排序，不难求出对i点来说X维比i点小的所有点的集合。现在的问题就转化成对点i来说，求出X维，Y维，Z维，Q维，W维分别比i所在那一维小的集合的交的大小。<br>小Hi：对！你的思路很好。但是集合大小是O(N^2)，如果暴力实现的话时间复杂度就达到了O(N^2)。<br>小Ho：那该怎么办呢？<br>小Hi：我们想想可以用什么合理的方法来表示集合以此来加快求集合交的操作。<br>小Ho：我觉得一种比较直观的方法是用一个长度为n的01串，第i位为0表示i不在集合中，1表示i在集合中。<br>小Hi：不错哟！那你仔细观察一下，求集合的交到底具有什么性质？比如对于n=6,集合{1,4,5}和集合{2,4,5,6}来说，它们的交是{4,5}。<br>小Ho：集合求交在01串中可以这么看：若两串第i位都是1，则交的串第i位是1，否则第i位就是0。这个例子中两个集合的01串分别为100110,010111。它们的交就是000110，也就是{4,5}。<br>小Hi：是的。我们把这个问题转化成了对01串的操作。你有没有发现，这其实类似于二进制中”and”的操作。如果我们把01串看成一个二进制的大整数，那么集合求交就变成了对两个大整数做”and”的操作。<br>小Ho：哈！有道理。但是这看起来复杂度似乎依旧是O(N^2)的。<br>小Hi：啊！但是你有没有想过，我们可以利用程序语言中的32位整数加速这个”and”，也就是说我们每32位压缩成一个32位整数，这样本来我们需要32次的操作，一下就变成了做一次位运算“并”的操作。所有我们最后的复杂度能优化成O(N^2/32)。<br>小Ho：原来如此！那具体怎么实现这个“压缩”的过程呢？<br>小Hi：其实c++/Java已经为我们设计了这样一种数据结构来解决这种问题。它的名字叫bitset/BitSet。它类似于数组，但是你可以直接对其做位运算。bitset中还有一些有用的函数，如count/cardinality可以快速算出二进制中有多少个1（这其实是一个不太好做的问题）。<br>引用自题目页提式</p></blockquote><p>感觉比较难想到的是单独对于每一维排序后可以直接$O(n)$递推出每个人这一科的排名关系。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">30009</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se1[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se2[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se3[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se4[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; se5[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">&#125;stu[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.a[<span class="number">0</span>]&lt;y.a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.a[<span class="number">1</span>]&lt;y.a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp3</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.a[<span class="number">2</span>]&lt;y.a[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp4</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.a[<span class="number">3</span>]&lt;y.a[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp5</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.a[<span class="number">4</span>]&lt;y.a[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp6</span><span class="params">(S x,S y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.pos&lt;y.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; tmp;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;stu[i].a[<span class="number">0</span>],&amp;stu[i].a[<span class="number">1</span>],&amp;stu[i].a[<span class="number">2</span>],&amp;stu[i].a[<span class="number">3</span>],&amp;stu[i].a[<span class="number">4</span>]);</span><br><span class="line">stu[i].pos=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(stu,stu+n,cmp1);</span><br><span class="line">se1[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">tmp.reset();</span><br><span class="line">tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">se1[stu[i].pos]=se1[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">&#125;</span><br><span class="line">sort(stu,stu+n,cmp2);</span><br><span class="line">se2[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">tmp.reset();</span><br><span class="line">tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">se2[stu[i].pos]=se2[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">&#125;</span><br><span class="line">sort(stu,stu+n,cmp3);</span><br><span class="line">se3[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">tmp.reset();</span><br><span class="line">tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">se3[stu[i].pos]=se3[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">&#125;</span><br><span class="line">sort(stu,stu+n,cmp4);</span><br><span class="line">se4[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">tmp.reset();</span><br><span class="line">tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">se4[stu[i].pos]=se4[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">&#125;</span><br><span class="line">sort(stu,stu+n,cmp5);</span><br><span class="line">se5[stu[<span class="number">0</span>].pos].reset();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">tmp.reset();</span><br><span class="line">tmp.<span class="built_in">set</span>(stu[i<span class="number">-1</span>].pos);</span><br><span class="line">se5[stu[i].pos]=se5[stu[i<span class="number">-1</span>].pos]|tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>,(se1[i]&amp;se2[i]&amp;se3[i]&amp;se4[i]&amp;se5[i]).count());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;https://hihocoder.com/problemset/problem/1513&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://hihocoder.com/problemset/problem/1513&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意：给定许多人的五门课排名，询问每个人有多少人所有课的排名都能碾压他。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小Hi：今天我们来解决“五维数点”问题。&lt;br&gt;小Ho：什么是“五维数点”问题呢？&lt;br&gt;小Hi：抽象来说，我们现在有n个在五维空间中的点$(X_i,Y_i,Z_i,Q_i,W_i)$。现在对于每个点，我们需要知道所有坐标均比它小的点的数量。&lt;br&gt;小Ho：这个问题看起来似曾相似，如果是在二维空间中似乎是一个经典的运用线段树解决的题目。&lt;br&gt;小Hi：对。但是现在是在五维空间中，看起来难度大了很多。&lt;br&gt;小Ho：我想用集合的角度去考虑这个问题。对于每一维，比如说X维，我们能通过按X维的坐标排序，不难求出对i点来说X维比i点小的所有点的集合。现在的问题就转化成对点i来说，求出X维，Y维，Z维，Q维，W维分别比i所在那一维小的集合的交的大小。&lt;br&gt;小Hi：对！你的思路很好。但是集合大小是O(N^2)，如果暴力实现的话时间复杂度就达到了O(N^2)。&lt;br&gt;小Ho：那该怎么办呢？&lt;br&gt;小Hi：我们想想可以用什么合理的方法来表示集合以此来加快求集合交的操作。&lt;br&gt;小Ho：我觉得一种比较直观的方法是用一个长度为n的01串，第i位为0表示i不在集合中，1表示i在集合中。&lt;br&gt;小Hi：不错哟！那你仔细观察一下，求集合的交到底具有什么性质？比如对于n=6,集合{1,4,5}和集合{2,4,5,6}来说，它们的交是{4,5}。&lt;br&gt;小Ho：集合求交在01串中可以这么看：若两串第i位都是1，则交的串第i位是1，否则第i位就是0。这个例子中两个集合的01串分别为100110,010111。它们的交就是000110，也就是{4,5}。&lt;br&gt;小Hi：是的。我们把这个问题转化成了对01串的操作。你有没有发现，这其实类似于二进制中”and”的操作。如果我们把01串看成一个二进制的大整数，那么集合求交就变成了对两个大整数做”and”的操作。&lt;br&gt;小Ho：哈！有道理。但是这看起来复杂度似乎依旧是O(N^2)的。&lt;br&gt;小Hi：啊！但是你有没有想过，我们可以利用程序语言中的32位整数加速这个”and”，也就是说我们每32位压缩成一个32位整数，这样本来我们需要32次的操作，一下就变成了做一次位运算“并”的操作。所有我们最后的复杂度能优化成O(N^2/32)。&lt;br&gt;小Ho：原来如此！那具体怎么实现这个“压缩”的过程呢？&lt;br&gt;小Hi：其实c++/Java已经为我们设计了这样一种数据结构来解决这种问题。它的名字叫bitset/BitSet。它类似于数组，但是你可以直接对其做位运算。bitset中还有一些有用的函数，如count/cardinality可以快速算出二进制中有多少个1（这其实是一个不太好做的问题）。&lt;br&gt;引用自题目页提式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感觉比较难想到的是单独对于每一维排序后可以直接$O(n)$递推出每个人这一科的排名关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="STL" scheme="https://www.mhlwsk.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>POJ3678 (Katu Puzzle)[2-SAT]</title>
    <link href="https://www.mhlwsk.com/archives/28241.html"/>
    <id>https://www.mhlwsk.com/archives/28241.html</id>
    <published>2018-09-01T02:26:29.000Z</published>
    <updated>2020-07-30T13:07:23.800Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=3678" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=3678</a></p><p>2-SAT模板题，注意四种条件中a &amp; b = 1和a | b = 0的情况，前者需要u^1 -&gt; u, v^1 -&gt; v连边，后者需要u -&gt; u^1, v -&gt; v^1连边。<br>相当于无论如何都要选u^1（无论如何都要选v^1）。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">2000009</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[tot].to=v;edge[tot].next=head[u];head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> S[MAXN],top;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u^<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    S[top++]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!dfs(edge[i].to))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Twosat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] || vis[i^<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(i)) &#123;</span><br><span class="line">            <span class="keyword">while</span>(top) vis[S[--top]]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i^<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        u=<span class="number">2</span>*a,v=<span class="number">2</span>*b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'A'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">1</span>) &#123;</span><br><span class="line">addedge(u,u^<span class="number">1</span>);</span><br><span class="line">addedge(v,v^<span class="number">1</span>);</span><br><span class="line">addedge(u^<span class="number">1</span>,v^<span class="number">1</span>);</span><br><span class="line">addedge(v^<span class="number">1</span>,u^<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                addedge(u^<span class="number">1</span>,v);</span><br><span class="line">                addedge(v^<span class="number">1</span>,u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'O'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>) &#123;</span><br><span class="line">addedge(u^<span class="number">1</span>,u);</span><br><span class="line">addedge(v^<span class="number">1</span>,v);</span><br><span class="line">addedge(u,v);</span><br><span class="line">addedge(v,u);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                addedge(u,v^<span class="number">1</span>);</span><br><span class="line">                addedge(v,u^<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'X'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>) &#123;</span><br><span class="line">                addedge(u,v);</span><br><span class="line">                addedge(v,u);</span><br><span class="line">                addedge(u^<span class="number">1</span>,v^<span class="number">1</span>);</span><br><span class="line">                addedge(v^<span class="number">1</span>,u^<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                addedge(u,v^<span class="number">1</span>);</span><br><span class="line">                addedge(v^<span class="number">1</span>,u);</span><br><span class="line">                addedge(u^<span class="number">1</span>,v);</span><br><span class="line">                addedge(v,u^<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Twosat(<span class="number">2</span>*n)) <span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://poj.org/problem?id=3678&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://poj.org/problem?id=3678&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2-SAT模板题，注意四种条件中a &amp;amp; b = 1和a | b = 0的情况，前者需要u^1 -&amp;gt; u, v^1 -&amp;gt; v连边，后者需要u -&amp;gt; u^1, v -&amp;gt; v^1连边。&lt;br&gt;相当于无论如何都要选u^1（无论如何都要选v^1）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="2-SAT" scheme="https://www.mhlwsk.com/tags/2-SAT/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2208 (连通数)[bitset, Floyd]</title>
    <link href="https://www.mhlwsk.com/archives/43015.html"/>
    <id>https://www.mhlwsk.com/archives/43015.html</id>
    <published>2018-09-01T02:20:14.000Z</published>
    <updated>2020-07-30T13:07:23.780Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2208" rel="external nofollow noopener noreferrer" target="_blank">https://www.lydsy.com/JudgeOnline/problem.php?id=2208</a></p><p>其实这题可以用Floyd…<br>用bitset跑Floyd传递闭包处理出每一对点之间的连通关系，然后$O(n^2)$枚举两个点之间是否连通计数即可。<br>感觉bitset常数还是比较小的。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2009</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; g[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">            g[i][i]=<span class="literal">true</span>;<span class="comment">//this is true when using floyd</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;s[j]!=<span class="string">'\0'</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'1'</span>) g[i][j]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[j][i]) g[j]|=g[i]; <span class="comment">// cant swap i and j</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            ans+=g[i].count();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2208&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://www.lydsy.com/JudgeOnline/problem.php?id=2208&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实这题可以用Floyd…&lt;br&gt;用bitset跑Floyd传递闭包处理出每一对点之间的连通关系，然后$O(n^2)$枚举两个点之间是否连通计数即可。&lt;br&gt;感觉bitset常数还是比较小的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="STL" scheme="https://www.mhlwsk.com/tags/STL/"/>
    
      <category term="Floyd" scheme="https://www.mhlwsk.com/tags/Floyd/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2734 (集合选数)[状压DP, 矩阵]</title>
    <link href="https://www.mhlwsk.com/archives/6871.html"/>
    <id>https://www.mhlwsk.com/archives/6871.html</id>
    <published>2018-09-01T01:59:33.000Z</published>
    <updated>2020-07-30T13:07:23.781Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1087" rel="external nofollow noopener noreferrer" target="_blank">https://www.lydsy.com/JudgeOnline/problem.php?id=1087</a></p><p>考虑到选取集合中的元素不能是乘2或乘3相邻，我们尝试构造一个矩阵：<br>$$<br>\begin{bmatrix}<br>    x &amp; 3x &amp; 9x &amp; \cdots \\<br>    2x &amp; 6x &amp; 18x &amp; \cdots \\<br>    4x &amp; 12x &amp; 36x &amp; \cdots \\<br>    \vdots &amp; \vdots &amp; \vdots &amp; \ddots \\<br>\end{bmatrix}<br>$$<br>这样只需要在矩阵中选取不相邻的元素就能满足题意了。<br>这个矩阵的长宽是log级的，因此问题转化成了类似<a href="https://www.mhlwsk.com/archives/33051.html">互不侵犯King</a>的问题。<br>$x$代入不是2或3倍数的数构造多个矩阵，结果根据乘法原理相乘就是答案了。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">1000000001</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">18</span>];</span><br><span class="line">ll dp[<span class="number">18</span>][<span class="number">2049</span>];</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="keyword">sizeof</span>(col));</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i*=<span class="number">2</span>) &#123;</span><br><span class="line">r++;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i*<span class="number">3</span>;j&lt;=n;j*=<span class="number">3</span>) c++;</span><br><span class="line">col[r]=<span class="number">1</span>&lt;&lt;c;</span><br><span class="line">&#125;</span><br><span class="line">col[<span class="number">0</span>]=<span class="number">1</span>; </span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col[i];j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!(j&amp;(j&lt;&lt;<span class="number">1</span>))) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;col[i<span class="number">-1</span>];k++) </span><br><span class="line"><span class="keyword">if</span>(!(k&amp;(k&lt;&lt;<span class="number">1</span>)) &amp;&amp; !(j&amp;k)) </span><br><span class="line">dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][k])%M;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;col[r];i++) </span><br><span class="line">ans=(ans+dp[r][i])%M;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span> &amp;&amp; i%<span class="number">3</span>) </span><br><span class="line">ans=(ans*f(i))%M;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1087&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://www.lydsy.com/JudgeOnline/problem.php?id=1087&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑到选取集合中的元素不能是乘2或乘3相邻，我们尝试构造一个矩阵：&lt;br&gt;$$&lt;br&gt;\begin{bmatrix}&lt;br&gt;    x &amp;amp; 3x &amp;amp; 9x &amp;amp; \cdots \\&lt;br&gt;    2x &amp;amp; 6x &amp;amp; 18x &amp;amp; \cdots \\&lt;br&gt;    4x &amp;amp; 12x &amp;amp; 36x &amp;amp; \cdots \\&lt;br&gt;    \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots \\&lt;br&gt;\end{bmatrix}&lt;br&gt;$$&lt;br&gt;这样只需要在矩阵中选取不相邻的元素就能满足题意了。&lt;br&gt;这个矩阵的长宽是log级的，因此问题转化成了类似&lt;a href=&quot;https://www.mhlwsk.com/archives/33051.html&quot;&gt;互不侵犯King&lt;/a&gt;的问题。&lt;br&gt;$x$代入不是2或3倍数的数构造多个矩阵，结果根据乘法原理相乘就是答案了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="https://www.mhlwsk.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="状压DP" scheme="https://www.mhlwsk.com/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 101343J (Husam and the Broken Present 2)[状压DP]</title>
    <link href="https://www.mhlwsk.com/archives/10840.html"/>
    <id>https://www.mhlwsk.com/archives/10840.html</id>
    <published>2018-09-01T01:45:21.000Z</published>
    <updated>2020-07-30T13:07:23.783Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/gym/101343/problem/J" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/gym/101343/problem/J</a></p><blockquote><p>题意：构造一个序列包含所给的N个子序列(N≤15)，求构造序列的最短长度。<br>考虑状态压缩，有2^N种状态，设dp[i][j]表示状态为i，以第j个子序列结尾的最小长度；<br>状态转移：从以第j个子序列结尾的状态转移到以第k个子序列的状态：<br><strong>dp[i|(1 &lt;&lt; (k-1))][k] = min{dp[i][j]+a[k][0]-num[j][k]}</strong>   （其中，a[k][0]表示第k个子序列的长度，num[j][k]表示第j个子序列的后缀与第k个子序列的前缀重合部分的长度）<br>注意：<strong>先将被其他子序列包含的子序列删去……</strong><br>引用自<a href="http://www.cnblogs.com/GraceSkyer/p/8996659.html" rel="external nofollow noopener noreferrer" target="_blank">GraceSkyer</a></p></blockquote><p>感觉这题有包含的情况是个坑啊，另外需要注意的是两串相等的情况，可以把它们特判成两串不包含的情况。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">16</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">bool</span> cov[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> comm[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">32769</span>][<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=a[i][<span class="number">0</span>];j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j || a[j][<span class="number">0</span>]&gt;a[i][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+a[j][<span class="number">0</span>]<span class="number">-1</span>&lt;=a[i][<span class="number">0</span>];l++) &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=a[j][<span class="number">0</span>];k++)</span><br><span class="line">                    <span class="keyword">if</span>(a[i][l+k<span class="number">-1</span>]!=a[j][k]) &#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag &amp;&amp; !(a[i][<span class="number">0</span>]==a[j][<span class="number">0</span>] &amp;&amp; l==<span class="number">1</span>)) cov[j]=<span class="literal">true</span>; <span class="comment">//特判两串相等的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!cov[i]) pos[++tot]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) &#123; comm[i][i]=a[pos[i]][<span class="number">0</span>];<span class="keyword">continue</span>; &#125;</span><br><span class="line">            comm[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=min(a[pos[i]][<span class="number">0</span>],a[pos[j]][<span class="number">0</span>]);l++) &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=l;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[pos[i]][a[pos[i]][<span class="number">0</span>]-l+k]!=a[pos[j]][k]) &#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) comm[i][j]=l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mx=(<span class="number">1</span>&lt;&lt;tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mx;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=tot;j++)</span><br><span class="line">            dp[i][j]=inf;</span><br><span class="line">    <span class="comment">//dp[0][0]=0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)][j]=a[pos[j]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mx;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=tot;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==k) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i|(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k]=min(dp[i|(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k],dp[i][j]+a[pos[k]][<span class="number">0</span>]-comm[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        ans=min(ans,dp[mx<span class="number">-1</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://codeforces.com/gym/101343/problem/J&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://codeforces.com/gym/101343/problem/J&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题意：构造一个序列包含所给的N个子序列(N≤15)，求构造序列的最短长度。&lt;br&gt;考虑状态压缩，有2^N种状态，设dp[i][j]表示状态为i，以第j个子序列结尾的最小长度；&lt;br&gt;状态转移：从以第j个子序列结尾的状态转移到以第k个子序列的状态：&lt;br&gt;&lt;strong&gt;dp[i|(1 &amp;lt;&amp;lt; (k-1))][k] = min{dp[i][j]+a[k][0]-num[j][k]}&lt;/strong&gt;   （其中，a[k][0]表示第k个子序列的长度，num[j][k]表示第j个子序列的后缀与第k个子序列的前缀重合部分的长度）&lt;br&gt;注意：&lt;strong&gt;先将被其他子序列包含的子序列删去……&lt;/strong&gt;&lt;br&gt;引用自&lt;a href=&quot;http://www.cnblogs.com/GraceSkyer/p/8996659.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;GraceSkyer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感觉这题有包含的情况是个坑啊，另外需要注意的是两串相等的情况，可以把它们特判成两串不包含的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="https://www.mhlwsk.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="状压DP" scheme="https://www.mhlwsk.com/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1087 (互不侵犯King)[状压DP]</title>
    <link href="https://www.mhlwsk.com/archives/33051.html"/>
    <id>https://www.mhlwsk.com/archives/33051.html</id>
    <published>2018-09-01T01:37:59.000Z</published>
    <updated>2020-07-30T13:07:23.780Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1087" rel="external nofollow noopener noreferrer" target="_blank">https://www.lydsy.com/JudgeOnline/problem.php?id=1087</a></p><blockquote><p>状压dp经典题<br>f[i][j][k]保存第i行（包括第i行）之前放了j个国王，当前行用二进制表示后对应十进制数为k的方案数。count[k]表示k所对应的二进制中1的个数。<br>状态转移方程比较显然：f[i][j][k]=sum{f[i-1][j-count[k]][p]}；<br>其中k满足 (k&amp;(k&lt;&lt;1))==0<br>其中p满足 (p&amp;(p&lt;&lt;1))==0&amp;&amp;((p&lt;&lt;1)&amp;k)==0&amp;&amp;(p&amp;k)==0&amp;&amp;((p&gt;&gt;1)&amp;k)==0<br>引用自<a href="https://blog.csdn.net/sunshinezff/article/details/47662651" rel="external nofollow noopener noreferrer" target="_blank">sunshinezff</a></p></blockquote><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">ll dp[<span class="number">10</span>][<span class="number">513</span>][<span class="number">82</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">513</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">513</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=i,cc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp&amp;<span class="number">1</span>) cc++;</span><br><span class="line">            tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[i]=cc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n,K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">int</span> tot=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=K;k++) &#123; <span class="comment">//k starts from 0 instead of 1</span></span><br><span class="line">                <span class="keyword">if</span>(!(j&amp;(j&lt;&lt;<span class="number">1</span>)) &amp;&amp; cnt[j]&lt;=k) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;tot;l++)</span><br><span class="line">                        <span class="keyword">if</span>(!(j&amp;l) &amp;&amp; !(j&amp;(l&lt;&lt;<span class="number">1</span>)) &amp;&amp; !(j&amp;(l&gt;&gt;<span class="number">1</span>)) &amp;&amp; !(l&amp;(l&lt;&lt;<span class="number">1</span>)))</span><br><span class="line">                        dp[i][j][k]+=dp[i<span class="number">-1</span>][l][k-cnt[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line">        ans+=dp[n][i][K];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("%I64d",ans);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans); <span class="comment">// you cannot use %I64d in BZOJ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1087&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://www.lydsy.com/JudgeOnline/problem.php?id=1087&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;状压dp经典题&lt;br&gt;f[i][j][k]保存第i行（包括第i行）之前放了j个国王，当前行用二进制表示后对应十进制数为k的方案数。count[k]表示k所对应的二进制中1的个数。&lt;br&gt;状态转移方程比较显然：f[i][j][k]=sum{f[i-1][j-count[k]][p]}；&lt;br&gt;其中k满足 (k&amp;amp;(k&amp;lt;&amp;lt;1))==0&lt;br&gt;其中p满足 (p&amp;amp;(p&amp;lt;&amp;lt;1))==0&amp;amp;&amp;amp;((p&amp;lt;&amp;lt;1)&amp;amp;k)==0&amp;amp;&amp;amp;(p&amp;amp;k)==0&amp;amp;&amp;amp;((p&amp;gt;&amp;gt;1)&amp;amp;k)==0&lt;br&gt;引用自&lt;a href=&quot;https://blog.csdn.net/sunshinezff/article/details/47662651&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;sunshinezff&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="https://www.mhlwsk.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="状压DP" scheme="https://www.mhlwsk.com/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>HDU2243 (考研路茫茫——单词情结)[AC自动机，矩阵乘法]</title>
    <link href="https://www.mhlwsk.com/archives/16318.html"/>
    <id>https://www.mhlwsk.com/archives/16318.html</id>
    <published>2018-08-29T15:45:16.000Z</published>
    <updated>2020-07-30T13:07:23.787Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2243" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2243</a></p><p>题目大意：给定n个模板串，问有多少个长度不超过L的含至少一个模板串的字符串。<br>首先考虑问题的相反问题，求有多少个不含任何模板串的字符串，并只考虑长度正好为$l$的字符串的数量，这个问题的解题方法见<a href="https://www.mhlwsk.com/archives/55506.html">POJ2778(DNA Sequence)</a>。<br>现在我们已经能计算长度为$l$的字符串的数量，但问题要求的是长度不超过$L$的字符串数量，答案对应的矩阵为 $A^1+A^2+…+A^L$ 。<br>令 $S_n=A^1+A^2+…+A^n$，则$S_n=S_{n-1}A+A$<br>$$<br>\left[ \begin{matrix} S_n &amp; A \end{matrix} \right] = \left[ \begin{matrix} S_{n-1} &amp; A \end{matrix} \right] \left[ \begin{matrix} A &amp; 0 \\ E &amp; E \end{matrix} \right] = \left[ \begin{matrix} 0 &amp; A \end{matrix} \right] {\left[ \begin{matrix} A &amp; 0 \\ E &amp; E \end{matrix} \right]}^n<br>$$<br>这样就能用矩阵快速幂求出不含任何模板串的答案对应的矩阵了。接下来要用总方案数减去这个答案。<br>使用同样的方法求出$T_n=26^1+26^2+…+26^n$，并用$T_n$减去上述答案即可。<br>$$<br>\left[ \begin{matrix} T_n &amp; 26 \end{matrix} \right] = \left[ \begin{matrix} T_{n-1} &amp; 26 \end{matrix} \right] \left[ \begin{matrix} 26 &amp; 0 \\ 1 &amp; 1 \end{matrix} \right] = \left[ \begin{matrix} 0 &amp; 26 \end{matrix} \right] {\left[ \begin{matrix} 26 &amp; 0 \\ 1 &amp; 1 \end{matrix} \right]}^n<br>$$</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">bool</span> danger[maxn];</span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span>&#123;</span><br><span class="line">sz=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(danger,<span class="number">0</span>,<span class="keyword">sizeof</span>(danger));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-<span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">0</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> c=idx(s[i]);</span><br><span class="line"><span class="keyword">if</span>(!ch[u][c]) &#123;</span><br><span class="line"><span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">danger[sz]=<span class="literal">false</span>;</span><br><span class="line">ch[u][c]=sz++;</span><br><span class="line">&#125;</span><br><span class="line">u=ch[u][c];</span><br><span class="line">&#125;</span><br><span class="line">danger[u]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line"><span class="keyword">int</span> u=ch[<span class="number">0</span>][c];</span><br><span class="line"><span class="keyword">if</span>(u) &#123; f[u]=<span class="number">0</span>;q.push(u); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> r=q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line"><span class="keyword">int</span> u=ch[r][c];</span><br><span class="line"><span class="keyword">if</span>(!u) &#123; ch[r][c]=ch[f[r]][c];<span class="keyword">continue</span>; &#125;</span><br><span class="line">q.push(u);</span><br><span class="line"><span class="keyword">int</span> v=f[r];</span><br><span class="line"><span class="keyword">while</span>(v &amp;&amp; !ch[v][c]) v=f[v];</span><br><span class="line">f[u]=ch[v][c];</span><br><span class="line">danger[u]|=danger[ch[v][c]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ull mat[maxn*<span class="number">2</span>][maxn*<span class="number">2</span>];</span><br><span class="line">ull A[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(A));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) <span class="keyword">if</span>(!danger[i]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> u=ch[i][j];</span><br><span class="line"><span class="keyword">if</span>(!danger[u]) A[i][u]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span>(mat));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++) &#123;</span><br><span class="line">            mat[i][j]=A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">        mat[i+sz][i]=mat[i+sz][i+sz]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ull ans[maxn*<span class="number">2</span>][maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ull tmp[maxn*<span class="number">2</span>][maxn*<span class="number">2</span>];</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz*<span class="number">2</span>;i++)</span><br><span class="line">ans[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz*<span class="number">2</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz*<span class="number">2</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sz*<span class="number">2</span>;k++)</span><br><span class="line">tmp[i][j]=((ans[i][k]*mat[k][j])+tmp[i][j]);</span><br><span class="line"><span class="built_in">memcpy</span>(ans,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz*<span class="number">2</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz*<span class="number">2</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sz*<span class="number">2</span>;k++)</span><br><span class="line">tmp[i][j]=((mat[i][k]*mat[k][j])+tmp[i][j]);</span><br><span class="line"><span class="built_in">memcpy</span>(mat,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ull tot[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">ull mat2[<span class="number">2</span>][<span class="number">2</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">26</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow_mod_sum</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ull tmp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">mat2[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">26</span>;</span><br><span class="line">mat2[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">mat2[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">mat2[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(tot,<span class="number">0</span>,<span class="keyword">sizeof</span>(tot));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">tot[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">tmp[i][j]=((tot[i][k]*mat2[k][j])+tmp[i][j]);</span><br><span class="line"><span class="built_in">memcpy</span>(tot,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">tmp[i][j]=((mat2[i][k]*mat2[k][j])+tmp[i][j]);</span><br><span class="line"><span class="built_in">memcpy</span>(mat2,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>];</span><br><span class="line">ull seq[maxn][maxn*<span class="number">2</span>];</span><br><span class="line">ull ans2[maxn][maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l)) &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">            insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        getFail();</span><br><span class="line">        build();</span><br><span class="line">        pow_mod(l);</span><br><span class="line">        <span class="built_in">memset</span>(seq,<span class="number">0</span>,<span class="keyword">sizeof</span>(seq));</span><br><span class="line">        <span class="built_in">memset</span>(ans2,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans2));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++) &#123;</span><br><span class="line">                seq[i][j+sz]=A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*sz;j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>*sz;k++) &#123;</span><br><span class="line">                    ans2[i][j]=seq[i][k]*ans[k][j]+ans2[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ull a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            a=(ans2[<span class="number">0</span>][i]+a);</span><br><span class="line">        &#125;</span><br><span class="line">        pow_mod_sum(l);</span><br><span class="line">        ull sum=tot[<span class="number">1</span>][<span class="number">0</span>]*<span class="number">26</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64u\n"</span>,sum-a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2243&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=2243&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意：给定n个模板串，问有多少个长度不超过L的含至少一个模板串的字符串。&lt;br&gt;首先考虑问题的相反问题，求有多少个不含任何模板串的字符串，并只考虑长度正好为$l$的字符串的数量，这个问题的解题方法见&lt;a href=&quot;https://www.mhlwsk.com/archives/55506.html&quot;&gt;POJ2778(DNA Sequence)&lt;/a&gt;。&lt;br&gt;现在我们已经能计算长度为$l$的字符串的数量，但问题要求的是长度不超过$L$的字符串数量，答案对应的矩阵为 $A^1+A^2+…+A^L$ 。&lt;br&gt;令 $S_n=A^1+A^2+…+A^n$，则$S_n=S_{n-1}A+A$&lt;br&gt;$$&lt;br&gt;\left[ \begin{matrix} S_n &amp;amp; A \end{matrix} \right] = \left[ \begin{matrix} S_{n-1} &amp;amp; A \end{matrix} \right] \left[ \begin{matrix} A &amp;amp; 0 \\ E &amp;amp; E \end{matrix} \right] = \left[ \begin{matrix} 0 &amp;amp; A \end{matrix} \right] {\left[ \begin{matrix} A &amp;amp; 0 \\ E &amp;amp; E \end{matrix} \right]}^n&lt;br&gt;$$&lt;br&gt;这样就能用矩阵快速幂求出不含任何模板串的答案对应的矩阵了。接下来要用总方案数减去这个答案。&lt;br&gt;使用同样的方法求出$T_n=26^1+26^2+…+26^n$，并用$T_n$减去上述答案即可。&lt;br&gt;$$&lt;br&gt;\left[ \begin{matrix} T_n &amp;amp; 26 \end{matrix} \right] = \left[ \begin{matrix} T_{n-1} &amp;amp; 26 \end{matrix} \right] \left[ \begin{matrix} 26 &amp;amp; 0 \\ 1 &amp;amp; 1 \end{matrix} \right] = \left[ \begin{matrix} 0 &amp;amp; 26 \end{matrix} \right] {\left[ \begin{matrix} 26 &amp;amp; 0 \\ 1 &amp;amp; 1 \end{matrix} \right]}^n&lt;br&gt;$$&lt;/p&gt;
    
    </summary>
    
    
      <category term="AC自动机" scheme="https://www.mhlwsk.com/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>POJ2778 (DNA Sequence)[AC自动机，图论，矩阵乘法]</title>
    <link href="https://www.mhlwsk.com/archives/55506.html"/>
    <id>https://www.mhlwsk.com/archives/55506.html</id>
    <published>2018-08-29T15:08:48.000Z</published>
    <updated>2020-07-30T13:07:23.796Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="http://poj.org/problem?id=2778" rel="external nofollow noopener noreferrer" target="_blank">http://poj.org/problem?id=2778</a></p><p>题意：给定m个模板串，问有多少种长度为n的字符串使得它不包含任何一个模板串。</p><p>首先根据模板串建出trie图。可以想到任意一个字符串都对应了trie图上从根结点起始的一条路径。因此问题转化为在trie图中从根结点开始长度为n的，且不经过某些点的不同路径数量。</p><p>设A是图G的邻接矩阵，即：<br>$$<br>a_{ij}=<br>\begin{cases}<br>0&amp; \text{节点i和节点j之间无边相连} \\<br>n&amp; \text{节点i和节点j之间有边相连且边数为n}<br>\end{cases}<br>$$<br>注：除非有自环，否则$a_{ii}$为$0$<br>令$B=A^l$，则$b_{ij}$表示节点$i$到节点$j$长度为$l$的不同路径的数量。</p><p>将邻接矩阵中不能经过的节点（单词节点和能通过后缀链接到达单词节点的节点）对应的行列全部置为0,然后用矩阵快速幂算出结果即可。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">bool</span> danger[maxn];</span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span>&#123;</span><br><span class="line">sz=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(danger,<span class="number">0</span>,<span class="keyword">sizeof</span>(danger));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'T'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u=<span class="number">0</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> c=idx(s[i]);</span><br><span class="line"><span class="keyword">if</span>(!ch[u][c]) &#123;</span><br><span class="line"><span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">danger[sz]=<span class="literal">false</span>;</span><br><span class="line">ch[u][c]=sz++;</span><br><span class="line">&#125;</span><br><span class="line">u=ch[u][c];</span><br><span class="line">&#125;</span><br><span class="line">danger[u]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++) &#123;</span><br><span class="line"><span class="keyword">int</span> u=ch[<span class="number">0</span>][c];</span><br><span class="line"><span class="keyword">if</span>(u) &#123; f[u]=<span class="number">0</span>;q.push(u); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> r=q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++) &#123;</span><br><span class="line"><span class="keyword">int</span> u=ch[r][c];</span><br><span class="line"><span class="keyword">if</span>(!u) &#123; ch[r][c]=ch[f[r]][c];<span class="keyword">continue</span>; &#125;</span><br><span class="line">q.push(u);</span><br><span class="line"><span class="keyword">int</span> v=f[r];</span><br><span class="line"><span class="keyword">while</span>(v &amp;&amp; !ch[v][c]) v=f[v];</span><br><span class="line">f[u]=ch[v][c];</span><br><span class="line">danger[u]|=danger[ch[v][c]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll mat[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span>(mat));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">memset(vis,false,sizeof(vis));</span></span><br><span class="line"><span class="comment">queue&lt;int&gt; q;</span></span><br><span class="line"><span class="comment">while(!q.empty()) q.pop();</span></span><br><span class="line"><span class="comment">vis[0]=true;</span></span><br><span class="line"><span class="comment">for(int c=0;c&lt;4;c++) &#123;</span></span><br><span class="line"><span class="comment">int u=ch[0][c];</span></span><br><span class="line"><span class="comment">if(!danger[u]) &#123; mat[0][u]=1;vis[u]=true;q.push(u); &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">while(!q.empty()) &#123;</span></span><br><span class="line"><span class="comment">int r=q.front(); q.pop();</span></span><br><span class="line"><span class="comment">for(int c=0;c&lt;4;c++) &#123;</span></span><br><span class="line"><span class="comment">int u=ch[r][c];</span></span><br><span class="line"><span class="comment">if(danger[u]) continue;</span></span><br><span class="line"><span class="comment">mat[r][u]=1;</span></span><br><span class="line"><span class="comment">if(!vis[u]) &#123; vis[u]=true;q.push(u); &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) <span class="keyword">if</span>(!danger[i]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> u=ch[i][j];</span><br><span class="line"><span class="keyword">if</span>(!danger[u]) mat[i][u]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">ll tmp[maxn][maxn];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">ans[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sz;k++) </span><br><span class="line">tmp[i][j]=((ans[i][k]*mat[k][j])%M+tmp[i][j])%M;</span><br><span class="line"><span class="built_in">memcpy</span>(ans,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sz;k++) </span><br><span class="line">tmp[i][j]=((mat[i][k]*mat[k][j])%M+tmp[i][j])%M;</span><br><span class="line"><span class="built_in">memcpy</span>(mat,tmp,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">insert(s);</span><br><span class="line">&#125;</span><br><span class="line">getFail();</span><br><span class="line">build();</span><br><span class="line">pow_mod(n,<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">a=(ans[<span class="number">0</span>][i]+a)%<span class="number">100000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://poj.org/problem?id=2778&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://poj.org/problem?id=2778&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意：给定m个模板串，问有多少种长度为n的字符串使得它不包含任何一个模板串。&lt;/p&gt;
&lt;p&gt;首先根据模板串建出trie图。可以想到任意一个字符串都对应了trie图上从根结点起始的一条路径。因此问题转化为在trie图中从根结点开始长度为n的，且不经过某些点的不同路径数量。&lt;/p&gt;
&lt;p&gt;设A是图G的邻接矩阵，即：&lt;br&gt;$$&lt;br&gt;a_{ij}=&lt;br&gt;\begin{cases}&lt;br&gt;0&amp;amp; \text{节点i和节点j之间无边相连} \\&lt;br&gt;n&amp;amp; \text{节点i和节点j之间有边相连且边数为n}&lt;br&gt;\end{cases}&lt;br&gt;$$&lt;br&gt;注：除非有自环，否则$a_{ii}$为$0$&lt;br&gt;令$B=A^l$，则$b_{ij}$表示节点$i$到节点$j$长度为$l$的不同路径的数量。&lt;/p&gt;
&lt;p&gt;将邻接矩阵中不能经过的节点（单词节点和能通过后缀链接到达单词节点的节点）对应的行列全部置为0,然后用矩阵快速幂算出结果即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AC自动机" scheme="https://www.mhlwsk.com/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>HDU2457 (DNA repair)[AC自动机，动态规划]</title>
    <link href="https://www.mhlwsk.com/archives/36543.html"/>
    <id>https://www.mhlwsk.com/archives/36543.html</id>
    <published>2018-08-29T14:52:44.000Z</published>
    <updated>2020-07-30T13:07:23.788Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2457" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2457</a></p><p>题目大意：给定n个模板串，再给一个待匹配串，问至少修改待匹配串的几个字符能使得它不包含任何一个模板串</p><p>可以想到一个满足条件的串一定能在trie图上沿边一直走却遇不到任何一个单词节点（或者能通过后缀链接跳转到单词节点的点），而这个trie图事实上构成了一个状态转移图，我们把它应用到DP的状态转移上。<br>令dp[i][j]表示处理到第i个字符且停留在trie图上第j个状态时的最小修改次数，则状态转移方程为<strong>dp[i+1][ch[j][c]]=min(dp[i][ch[j][c]],dp[i][j]+(idx(s[i])!=c))</strong></p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> f[maxn];</span><br><span class="line">    <span class="keyword">bool</span> danger[maxn];</span><br><span class="line">    <span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sz=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(danger,<span class="number">0</span>,<span class="keyword">sizeof</span>(danger));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'T'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][c]) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">                danger[sz]=<span class="number">0</span>;</span><br><span class="line">                ch[u][c]=sz++;</span><br><span class="line">            &#125;</span><br><span class="line">            u=ch[u][c];</span><br><span class="line">        &#125;</span><br><span class="line">        danger[u]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=ch[<span class="number">0</span>][c];</span><br><span class="line">            <span class="keyword">if</span>(u) &#123; f[u]=<span class="number">0</span>;q.push(u); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u=ch[r][c];</span><br><span class="line">                <span class="keyword">if</span>(!u) &#123; ch[r][c]=ch[f[r]][c];<span class="keyword">continue</span>; &#125;</span><br><span class="line">                q.push(u);</span><br><span class="line">                <span class="keyword">int</span> v=f[r];</span><br><span class="line">                <span class="keyword">while</span>(v &amp;&amp; !ch[v][c]) v=f[v];</span><br><span class="line">                f[u]=ch[v][c];</span><br><span class="line">                danger[u]|=danger[ch[v][c]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++) &#123;</span><br><span class="line">                dp[i][j]=inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sz;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;=inf) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(danger[ch[j][k]]) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[i+<span class="number">1</span>][ch[j][k]]=min(dp[i+<span class="number">1</span>][ch[j][k]],dp[i][j]+(idx(s[i])!=k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            ans=min(ans,dp[n][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==inf) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1009</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> cas=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        tr.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">            tr.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        tr.getFail();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,++cas,tr.getans(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2457&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=2457&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意：给定n个模板串，再给一个待匹配串，问至少修改待匹配串的几个字符能使得它不包含任何一个模板串&lt;/p&gt;
&lt;p&gt;可以想到一个满足条件的串一定能在trie图上沿边一直走却遇不到任何一个单词节点（或者能通过后缀链接跳转到单词节点的点），而这个trie图事实上构成了一个状态转移图，我们把它应用到DP的状态转移上。&lt;br&gt;令dp[i][j]表示处理到第i个字符且停留在trie图上第j个状态时的最小修改次数，则状态转移方程为&lt;strong&gt;dp[i+1][ch[j][c]]=min(dp[i][ch[j][c]],dp[i][j]+(idx(s[i])!=c))&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="https://www.mhlwsk.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="AC自动机" scheme="https://www.mhlwsk.com/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>HDU3065 (病毒侵袭持续中)[AC自动机]</title>
    <link href="https://www.mhlwsk.com/archives/21237.html"/>
    <id>https://www.mhlwsk.com/archives/21237.html</id>
    <published>2018-08-29T14:32:48.000Z</published>
    <updated>2020-07-30T13:07:23.788Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3065" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3065</a></p><p>这题是AC自动机模板题，统计每个模板串在文本串中的出现次数。下面贴上模板。</p><p>需要注意的是找到一个单词时，可以是直接找到了这个单词的单词节点，也可以是通过这个节点经由后缀链接跳转到了其它单词节点。因为有类似这种情况：10是1010的后缀，但如果匹配到1010显然也应该匹配一次10，这时应该通过后缀链接跳转过去修改10对应的匹配数。<br>注：后缀链接指向当前节点能通过fail指针跳转到的上一个单词节点的标号。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50009</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[maxn][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> f[maxn];</span><br><span class="line">    <span class="keyword">int</span> last[maxn];</span><br><span class="line">    <span class="keyword">int</span> val[maxn];</span><br><span class="line">    ll num[maxn];</span><br><span class="line">    <span class="keyword">int</span> index[<span class="number">1009</span>];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        sz=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));</span><br><span class="line">        <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span>(val));</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(index,<span class="number">0</span>,<span class="keyword">sizeof</span>(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c-<span class="string">'A'</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=idx(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(!ch[u][c]) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">                val[sz]=<span class="number">0</span>;</span><br><span class="line">                ch[u][c]=sz++;</span><br><span class="line">            &#125;</span><br><span class="line">            u=ch[u][c];</span><br><span class="line">        &#125;</span><br><span class="line">        val[u]+=<span class="number">1</span>;</span><br><span class="line">        index[v]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(T);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=idx(T[i]);</span><br><span class="line">            <span class="keyword">if</span>(c&lt;<span class="number">0</span> || c&gt;=<span class="number">26</span>) &#123;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; !ch[j][c]) j=f[j];</span><br><span class="line">            j=ch[j][c];</span><br><span class="line">            <span class="keyword">if</span>(val[j]) num[j]++;</span><br><span class="line">            <span class="keyword">int</span> k=j;</span><br><span class="line">            <span class="keyword">while</span>(last[k]) &#123; <span class="comment">//通过后缀链接修改还能匹配到的单词节点</span></span><br><span class="line">                k=last[k];</span><br><span class="line">                num[k]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u=ch[<span class="number">0</span>][c];</span><br><span class="line">            <span class="keyword">if</span>(u) &#123; f[u]=<span class="number">0</span>;q.push(u);last[u]=<span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">                <span class="keyword">int</span> u=ch[r][c];</span><br><span class="line">                <span class="keyword">if</span>(!u) <span class="keyword">continue</span>;</span><br><span class="line">                q.push(u);</span><br><span class="line">                <span class="keyword">int</span> v=f[r];</span><br><span class="line">                <span class="keyword">while</span>(v &amp;&amp; !ch[v][c]) v=f[v];</span><br><span class="line">                f[u]=ch[v][c];</span><br><span class="line">                last[u]=val[f[u]] ? f[u] : last[f[u]]; <span class="comment">//预处理后缀链接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1009</span>][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">2000009</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        tr.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</span><br><span class="line">            tr.insert(s[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        tr.getFail();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">        tr.find(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr.num[tr.index[i]]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s: %I64d\n"</span>,s[i],tr.num[tr.index[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3065&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=3065&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题是AC自动机模板题，统计每个模板串在文本串中的出现次数。下面贴上模板。&lt;/p&gt;
&lt;p&gt;需要注意的是找到一个单词时，可以是直接找到了这个单词的单词节点，也可以是通过这个节点经由后缀链接跳转到了其它单词节点。因为有类似这种情况：10是1010的后缀，但如果匹配到1010显然也应该匹配一次10，这时应该通过后缀链接跳转过去修改10对应的匹配数。&lt;br&gt;注：后缀链接指向当前节点能通过fail指针跳转到的上一个单词节点的标号。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AC自动机" scheme="https://www.mhlwsk.com/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 540D (Bad Luck Island)[概率DP]</title>
    <link href="https://www.mhlwsk.com/archives/42973.html"/>
    <id>https://www.mhlwsk.com/archives/42973.html</id>
    <published>2018-08-27T14:37:27.000Z</published>
    <updated>2020-07-30T13:07:23.784Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="http://codeforces.com/problemset/problem/540/D" rel="external nofollow noopener noreferrer" target="_blank">http://codeforces.com/problemset/problem/540/D</a></p><p>概率DP，<code>dp[i][j][k]</code>表示还剩i个石头，j个剪刀，k个布的概率。</p><p>以石头减少为例，<code>dp[i][j][k]</code>转移到<code>dp[i-1][j][k]</code>的概率为<code>i*k/(i*j+j*k+i*k)</code><br>这样就有<code>dp[i-1][j][k]+=dp[i][j][k]*(1.0*i*k)/(i*j+j*k+i*k)</code></p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">109</span>;</span><br><span class="line"><span class="keyword">double</span> dp[maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r,s,p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;r,&amp;s,&amp;p);</span><br><span class="line">    dp[r][s][p]=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=s;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=p;k&gt;=<span class="number">1</span>;k--) &#123;</span><br><span class="line">        dp[i<span class="number">-1</span>][j][k]+=dp[i][j][k]*(<span class="number">1.0</span>*i*k)/(i*j+j*k+i*k);</span><br><span class="line">        dp[i][j<span class="number">-1</span>][k]+=dp[i][j][k]*(<span class="number">1.0</span>*i*j)/(i*j+j*k+i*k);</span><br><span class="line">        dp[i][j][k<span class="number">-1</span>]+=dp[i][j][k]*(<span class="number">1.0</span>*j*k)/(i*j+j*k+i*k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans1=<span class="number">0.0</span>,ans2=<span class="number">0.0</span>,ans3=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j++) &#123;</span><br><span class="line">            ans1 += dp[i][j][<span class="number">0</span>];</span><br><span class="line">            ans2 += dp[<span class="number">0</span>][i][j];</span><br><span class="line">            ans3 += dp[j][<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10f %.10f %.10f"</span>,ans1,ans2,ans3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/540/D&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://codeforces.com/problemset/problem/540/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;概率DP，&lt;code&gt;dp[i][j][k]&lt;/code&gt;表示还剩i个石头，j个剪刀，k个布的概率。&lt;/p&gt;
&lt;p&gt;以石头减少为例，&lt;code&gt;dp[i][j][k]&lt;/code&gt;转移到&lt;code&gt;dp[i-1][j][k]&lt;/code&gt;的概率为&lt;code&gt;i*k/(i*j+j*k+i*k)&lt;/code&gt;&lt;br&gt;这样就有&lt;code&gt;dp[i-1][j][k]+=dp[i][j][k]*(1.0*i*k)/(i*j+j*k+i*k)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="https://www.mhlwsk.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="概率DP" scheme="https://www.mhlwsk.com/tags/%E6%A6%82%E7%8E%87DP/"/>
    
      <category term="数学期望" scheme="https://www.mhlwsk.com/tags/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
</feed>
